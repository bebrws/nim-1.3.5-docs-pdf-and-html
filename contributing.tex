% This file was generated by Nim.
% Generated: 2020-08-22 06:37:23 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{Contributing }
\author{}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

\tableofcontents \newpage
Contributing happens via "Pull requests" (PR) on github. Every PR needs to be reviewed before it can be merged and the Continuous Integration should be green.

The PR has to be approved (and is often merged too) by one "code owner", either by the code owner who is responsible for the subsystem the PR belongs to or by two core developers or by Araq.

See \href{codeowners.html}{codeowners} for more details.

\rsthA{Writing tests}\label{writing-tests}
There are 4 types of tests:

\begin{enumerate}\item \texttt{runnableExamples} documentation comment tests, ran by \texttt{nim doc mymod.nim} These end up in documentation and ensure documentation stays in sync with code.
\item separate test files, e.g.: \texttt{tests/stdlib/tos.nim}. In nim repo, \texttt{testament} (see below) runs all \texttt{\$nim/tests/*/t*.nim} test files; for nimble packages, see \href{https://github.com/nim-lang/nimble\#tests}{https://github.com/nim-lang/nimble\#tests}.
\item (deprecated) tests in \texttt{when isMainModule:} block, ran by \texttt{nim r mymod.nim}. \texttt{nimble test} can run those in nimble packages when specified in a \texttt{task "test"}.
\item (not preferred) \texttt{.. code-block:: nim} RST snippets; these should only be used in rst sources, in nim sources \texttt{runnableExamples} should now always be preferred to those for several reasons (cleaner syntax, syntax highlights, batched testing, and \texttt{rdoccmd} allows customization).
\end{enumerate}
Not all the tests follow the convention here, feel free to change the ones that don't. Always leave the code cleaner than you found it.

\rsthB{Stdlib}\label{writing-tests-stdlib}
Each stdlib module (anything under \texttt{lib/}, e.g. \texttt{lib/pure/os.nim}) should preferably have a corresponding separate test file, eg \texttt{tests/stdlib/tos.nim}. The old convention was to add a \texttt{when isMainModule:} block in the source file, which only gets executed when the tester is building the file.

Each test should be in a separate \texttt{block:} statement, such that each has its own scope. Use boolean conditions and \texttt{doAssert} for the testing by itself, don't rely on echo statements or similar; in particular avoid things like \texttt{echo "done"}.

Sample test:

\begin{rstpre}
\spanKeyword{block}\spanPunctuation{:} \spanComment{\# bug \#1234}
  \spanKeyword{static}\spanPunctuation{:} \spanIdentifier{doAssert} \spanDecNumber{1}\spanOperator{+}\spanDecNumber{1} \spanOperator{==} \spanDecNumber{2}

\spanKeyword{block}\spanPunctuation{:} \spanComment{\# bug \#1235}
  \spanKeyword{var} \spanIdentifier{seq2D} \spanOperator{=} \spanIdentifier{newSeqWith}\spanPunctuation{(}\spanDecNumber{4}\spanPunctuation{,} \spanIdentifier{newSeq}\spanPunctuation{\symbol{91}}\spanIdentifier{bool}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanDecNumber{2}\spanPunctuation{)}\spanPunctuation{)}
  \spanIdentifier{seq2D}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{true}
  \spanIdentifier{seq2D}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{true}
  \spanIdentifier{seq2D}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{true}
  \spanIdentifier{doAssert} \spanIdentifier{seq2D} \spanOperator{==} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanIdentifier{true}\spanPunctuation{,} \spanIdentifier{true}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanIdentifier{true}\spanPunctuation{,} \spanIdentifier{false}\spanPunctuation{\symbol{93}}\spanPunctuation{,}
                      \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanIdentifier{false}\spanPunctuation{,} \spanIdentifier{false}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanIdentifier{false}\spanPunctuation{,} \spanIdentifier{false}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{93}}
  \spanComment{\# doAssert with \symbol{96}not\symbol{96} can now be done as follows:}
  \spanIdentifier{doAssert} \spanKeyword{not} \spanPunctuation{(}\spanDecNumber{1} \spanOperator{==} \spanDecNumber{2}\spanPunctuation{)}
\end{rstpre}
Always refer to a github issue using the following exact syntax: \texttt{bug \#1234} as shown above, so that it's consistent and easier to search or for tooling. Some browser extensions (eg \href{https://github.com/sindresorhus/refined-github}{https://github.com/sindresorhus/refined-github}) will even turn those in clickable links when it works.

Rationale for using a separate test file instead of \texttt{when isMainModule:} block:

\begin{itemize}\item allows custom compiler flags or testing options (see details below)
\item faster CI since they can be joined in \texttt{megatest} (combined into a single test)
\item avoids making the parser do un-necessary work when a source file is merely imported
\item avoids mixing source and test code when reporting line of code statistics or code coverage
\end{itemize}
\rsthB{Compiler}\label{writing-tests-compiler}
The tests for the compiler use a testing tool called \texttt{testament}. They are all located in \texttt{tests/} (e.g.: \texttt{tests/destructor/tdestructor3.nim}). Each test has its own file. All test files are prefixed with \texttt{t}. If you want to create a file for import into another test only, use the prefix \texttt{m}.

At the beginning of every test is the expected behavior of the test. Possible keys are:

\begin{itemize}\item \texttt{cmd}: A compilation command template e.g. \texttt{nim \$target --threads:on \$options \$file}
\item \texttt{output}: The expected output (stdout + stderr), most likely via \texttt{echo}
\item \texttt{exitcode}: Exit code of the test (via \texttt{exit(number)})
\item \texttt{errormsg}: The expected compiler error message
\item \texttt{file}: The file the errormsg was produced at
\item \texttt{line}: The line the errormsg was produced at
\end{itemize}
For a full spec, see here: \texttt{testament/specs.nim}

An example for a test:

\begin{rstpre}
\spanKeyword{discard} \spanLongStringLit{"""
  errormsg: "type mismatch: got (PTest)"
"""}

\spanKeyword{type}
  \spanIdentifier{PTest} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object}

\spanKeyword{proc} \spanIdentifier{test}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{PTest}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=} \spanKeyword{nil}

\spanKeyword{var} \spanIdentifier{buf}\spanPunctuation{:} \spanIdentifier{PTest}
\spanIdentifier{buf}\spanOperator{.}\spanIdentifier{test}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
\rsthA{Running tests}\label{running-tests}
You can run the tests with

\begin{rstpre}

./koch tests
\end{rstpre}
which will run a good subset of tests. Some tests may fail. If you only want to see the output of failing tests, go for

\begin{rstpre}

./koch tests --failing all
\end{rstpre}
You can also run only a single category of tests. A category is a subdirectory in the \texttt{tests} directory. There are a couple of special categories; for a list of these, see \texttt{testament/categories.nim}, at the bottom.

\begin{rstpre}

./koch tests c lib \# compiles/runs stdlib modules, including \symbol{96}isMainModule\symbol{96} tests
./koch tests c megatest \# runs a set of tests that can be combined into 1
\end{rstpre}
To run a single test:

\begin{rstpre}

./koch test run <category>/<name>    \# e.g.: tuples/ttuples\_issues
./koch test run tests/stdlib/tos.nim \# can also provide relative path
\end{rstpre}
For reproducible tests (to reproduce an environment more similar to the one run by Continuous Integration on travis/appveyor), you may want to disable your local configuration (e.g. in \texttt{\symbol{126}/.config/nim/nim.cfg}) which may affect some tests; this can also be achieved by using \texttt{export XDG\_CONFIG\_HOME=pathtoAlternateConfig} before running \texttt{./koch} commands.

\rsthA{Comparing tests}\label{comparing-tests}
Test failures can be grepped using \texttt{Failure:}.

The tester can compare two test runs. First, you need to create the reference test. You'll also need to the commit id, because that's what the tester needs to know in order to compare the two.

\begin{rstpre}

git checkout devel
DEVEL\_COMMIT=\$(git rev-parse HEAD)
./koch tests
\end{rstpre}
Then switch over to your changes and run the tester again.

\begin{rstpre}

git checkout your-changes
./koch tests
\end{rstpre}
Then you can ask the tester to create a \texttt{testresults.html} which will tell you if any new tests passed/failed.

\begin{rstpre}

./koch tests --print html \$DEVEL\_COMMIT
\end{rstpre}
\rsthA{Deprecation}\label{deprecation}
Backward compatibility is important, so instead of a rename you need to deprecate the old name and introduce a new name:

\begin{rstpre}
\spanComment{\# for routines (proc/template/macro/iterator) and types:}
\spanKeyword{proc} \spanIdentifier{oldProc}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{float}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{deprecated}\spanPunctuation{:}
    \spanStringLit{"deprecated since v1.2.3; use \symbol{96}newImpl: string -> int\symbol{96} instead"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{discard}

\spanComment{\# for (const/var/let/fields) the msg is not yet supported:}
\spanKeyword{const} \spanIdentifier{Foo} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{deprecated}\spanOperator{.}\spanPunctuation{\symbol{125}}  \spanOperator{=} \spanDecNumber{1}

\spanComment{\# for enum types, you can deprecate the type or some elements}
\spanComment{\# (likewise with object types and their fields):}
\spanKeyword{type} \spanIdentifier{Bar} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{deprecated}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{enum} \spanIdentifier{bar0}\spanPunctuation{,} \spanIdentifier{bar1}
\spanKeyword{type} \spanIdentifier{Barz}  \spanOperator{=} \spanKeyword{enum} \spanIdentifier{baz0}\spanPunctuation{,} \spanIdentifier{baz1} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{deprecated}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{,} \spanIdentifier{baz2}
\end{rstpre}
See also \href{manual.html\#pragmas-deprecated-pragma}{Deprecated} pragma in the manual.

\rsthA{Documentation}\label{documentation}
When contributing new procs, be sure to add documentation, especially if the proc is public. Even private procs benefit from documentation and can be viewed using \texttt{nim doc --docInternal foo.nim}. Documentation begins on the line following the \texttt{proc} definition, and is prefixed by \texttt{\#\#} on each line.

Runnable code examples are also encouraged, to show typical behavior with a few test cases (typically 1 to 3 \texttt{assert} statements, depending on complexity). These \texttt{runnableExamples} are automatically run by \texttt{nim doc mymodule.nim} as well as \texttt{testament} and guarantee they stay in sync.

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{addBar}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanComment{\#\# Adds "Bar" to \symbol{96}a\symbol{96}.}
  \spanIdentifier{runnableExamples}\spanPunctuation{:}
    \spanIdentifier{assert} \spanStringLit{"baz"}\spanOperator{.}\spanIdentifier{addBar} \spanOperator{==} \spanStringLit{"bazBar"}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{a} \spanOperator{\&} \spanStringLit{"Bar"}
\end{rstpre}
See \href{os.html\#parentDir,string}{parentDir} example.

The RestructuredText Nim uses has a special syntax for including code snippets embedded in documentation; these are not run by \texttt{nim doc} and therefore are not guaranteed to stay in sync, so \texttt{runnableExamples} is usually preferred:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{someproc}\spanOperator{*}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanComment{\#\# Return "something"}
  \spanComment{\#\#}
  \spanComment{\#\# .. code-block::}
  \spanComment{\#\#  echo someproc() \# "something"}
  \spanIdentifier{result} \spanOperator{=} \spanStringLit{"something"} \spanComment{\# single-hash comments do not produce documentation}
\end{rstpre}
The \texttt{.. code-block:: nim} followed by a newline and an indentation instructs the \texttt{nim doc} command to produce syntax-highlighted example code with the documentation (\texttt{.. code-block::} is sufficient from inside a nim module).

When forward declaration is used, the documentation should be included with the first appearance of the proc.

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{hello}\spanOperator{*}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string}
  \spanComment{\#\# Put documentation here}
\spanKeyword{proc} \spanIdentifier{nothing}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}
\spanKeyword{proc} \spanIdentifier{hello}\spanOperator{*}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanComment{\#\# ignore this}
  \spanIdentifier{echo} \spanStringLit{"hello"}
\end{rstpre}
The preferred documentation style is to begin with a capital letter and use the imperative (command) form. That is, between:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{hello}\spanOperator{*}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanComment{\#\# Return "hello"}
  \spanIdentifier{result} \spanOperator{=} \spanStringLit{"hello"}
\end{rstpre}
or

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{hello}\spanOperator{*}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanComment{\#\# says hello}
  \spanIdentifier{result} \spanOperator{=} \spanStringLit{"hello"}
\end{rstpre}
the first is preferred.

\rsthA{Best practices}\label{best-practices}
Note: these are general guidelines, not hard rules; there are always exceptions. Code reviews can just point to a specific section here to save time and propagate best practices.

New \texttt{defined(foo)} symbols need to be prefixed by the nimble package name, or by \texttt{nim} for symbols in nim sources (e.g. compiler, standard library). This is to avoid name conflicts across packages.

\begin{rstpre}
\spanComment{\# if in nim sources}
\spanKeyword{when} \spanIdentifier{defined}\spanPunctuation{(}\spanIdentifier{allocStats}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{discard} \spanComment{\# bad, can cause conflicts}
\spanKeyword{when} \spanIdentifier{defined}\spanPunctuation{(}\spanIdentifier{nimAllocStats}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{discard} \spanComment{\# preferred}
\spanComment{\# if in a pacakge \symbol{96}cligen\symbol{96}:}
\spanKeyword{when} \spanIdentifier{defined}\spanPunctuation{(}\spanIdentifier{debug}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{discard} \spanComment{\# bad, can cause conflicts}
\spanKeyword{when} \spanIdentifier{defined}\spanPunctuation{(}\spanIdentifier{cligenDebug}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{discard} \spanComment{\# preferred}
\end{rstpre}
Take advantage of no implicit bool conversion

\begin{rstpre}
\spanIdentifier{doAssert} \spanIdentifier{isValid}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{==} \spanIdentifier{true}
\spanIdentifier{doAssert} \spanIdentifier{isValid}\spanPunctuation{(}\spanPunctuation{)} \spanComment{\# preferred}
\end{rstpre}
Design with method call syntax chaining in mind

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{cond}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{,} \spanIdentifier{lines}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanComment{\# bad}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{lines}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{cond}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{)} \spanComment{\# preferred}
\spanComment{\# can be called as: \symbol{96}getLines().foo(false)\symbol{96}}
\end{rstpre}
Use exceptions (including assert / doAssert) instead of \texttt{quit} rationale: \href{https://forum.nim-lang.org/t/4089}{https://forum.nim-lang.org/t/4089}

\begin{rstpre}
\spanIdentifier{quit}\spanPunctuation{(}\spanPunctuation{)} \spanComment{\# bad in almost all cases}
\spanIdentifier{doAssert}\spanPunctuation{(}\spanPunctuation{)} \spanComment{\# preferred}
\end{rstpre}
Use \texttt{doAssert} (or \texttt{require}, etc), not \texttt{assert} in all tests so they'll be enabled even in release mode (except for tests in \texttt{runnableExamples} blocks which for which \texttt{nim doc} ignores \texttt{-d:release}).

\begin{rstpre}
\spanKeyword{when} \spanIdentifier{isMainModule}\spanPunctuation{:}
  \spanIdentifier{assert} \spanIdentifier{foo}\spanPunctuation{(}\spanPunctuation{)} \spanComment{\# bad}
  \spanIdentifier{doAssert} \spanIdentifier{foo}\spanPunctuation{(}\spanPunctuation{)} \spanComment{\# preferred}
\end{rstpre}
Delegate printing to caller: return \texttt{string} instead of calling \texttt{echo} rationale: it's more flexible (e.g. allows caller to call custom printing, including prepending location info, writing to log files, etc).

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanStringLit{"bar"} \spanComment{\# bad}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanStringLit{"bar"} \spanComment{\# preferred (usually)}
\end{rstpre}
\symbol{91}Ongoing debate\symbol{93} Consider using Option instead of return bool + var argument, unless stack allocation is needed (e.g. for efficiency).

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{Bar}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Option}\spanPunctuation{\symbol{91}}\spanIdentifier{Bar}\spanPunctuation{\symbol{93}}
\end{rstpre}
Tests (including in testament) should always prefer assertions over \texttt{echo}, except when that's not possible. It's more precise, easier for readers and maintaners to where expected values refer to. See for example \href{https://github.com/nim-lang/Nim/pull/9335}{https://github.com/nim-lang/Nim/pull/9335} and \href{https://forum.nim-lang.org/t/4089}{https://forum.nim-lang.org/t/4089}

\begin{rstpre}
\spanIdentifier{echo} \spanIdentifier{foo}\spanPunctuation{(}\spanPunctuation{)} \spanComment{\# adds a line for testament in \symbol{96}output:\symbol{96} block inside \symbol{96}discard\symbol{96}.}
\spanIdentifier{doAssert} \spanIdentifier{foo}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{==} \spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{\symbol{93}} \spanComment{\# preferred, except when not possible to do so.}
\end{rstpre}
\rsthA{The Git stuff}\label{the-git-stuff}
\rsthB{General commit rules}\label{the-git-stuff-general-commit-rules}
\begin{enumerate}\item Important, critical bugfixes that have a tiny chance of breaking somebody's code should be backported to the latest stable release branch (currently 1.2.x) and maybe also to the 1.0 branch. The commit message should contain the tag \texttt{\symbol{91}backport\symbol{93}} for "backport to all stable releases" and the tag \texttt{\symbol{91}backport:\$VERSION\symbol{93}} for backporting to the given \$VERSION.
\item If you introduce changes which affect backwards compatibility, make breaking changes, or have PR which is tagged as \texttt{\symbol{91}feature\symbol{93}}, the changes should be mentioned in \href{https://github.com/nim-lang/Nim/blob/devel/changelog.md}{the changelog}.
\item All changes introduced by the commit (diff lines) must be related to the subject of the commit.

If you change something unrelated to the subject parts of the file, because your editor reformatted automatically the code or whatever different reason, this should be excluded from the commit.

\emph{Tip:} Never commit everything as is using \texttt{git commit -a}, but review carefully your changes with \texttt{git add -p}.


\item Changes should not introduce any trailing whitespace.

Always check your changes for whitespace errors using \texttt{git diff --check} or add following \texttt{pre-commit} hook:

\begin{rstpre}

\#!/bin/sh
git diff --check --cached || exit \$?
\end{rstpre}

\end{enumerate}
\begin{enumerate}\item Describe your commit and use your common sense. Example commit message:

\texttt{Fixes \#123; refs \#124}

indicates that issue \texttt{\#123} is completely fixed (github may automatically close it when the PR is committed), wheres issue \texttt{\#124} is referenced (e.g.: partially fixed) and won't close the issue when committed.


\item Commits should be always be rebased against devel (so a fast forward merge can happen)

e.g.: use \texttt{git pull --rebase origin devel}. This is to avoid messing up git history. Exceptions should be very rare: when rebase gives too many conflicts, simply squash all commits using the script shown in \href{https://github.com/nim-lang/Nim/pull/9356}{https://github.com/nim-lang/Nim/pull/9356}


\item Do not mix pure formatting changes (e.g. whitespace changes, nimpretty) or automated changes (e.g. nimfix) with other code changes: these should be in separate commits (and the merge on github should not squash these into 1).
\end{enumerate}
\rsthB{Continuous Integration (CI)}\label{the-git-stuff-continuous-integration-ci}
\begin{enumerate}\item Continuous Integration is by default run on every push in a PR; this clogs the CI pipeline and affects other PR's; if you don't need it (e.g. for WIP or documentation only changes), add \texttt{\symbol{91}ci skip\symbol{93}} to your commit message title. This convention is supported by \href{https://www.appveyor.com/docs/how-to/filtering-commits/\#skip-directive-in-commit-message}{Appveyor} and \href{https://docs.travis-ci.com/user/customizing-the-build/\#skipping-a-build}{Travis}.
\item Consider enabling CI (travis and appveyor) in your own Nim fork, and waiting for CI to be green in that fork (fixing bugs as needed) before opening your PR in original Nim repo, so as to reduce CI congestion. Same applies for updates on a PR: you can test commits on a separate private branch before updating the main PR.
\end{enumerate}
\rsthB{Code reviews}\label{the-git-stuff-code-reviews}
\begin{enumerate}\item Whenever possible, use github's new 'Suggested change' in code reviews, which saves time explaining the change or applying it; see also \href{https://forum.nim-lang.org/t/4317}{https://forum.nim-lang.org/t/4317}
\item When reviewing large diffs that may involve code moving around, github's interface doesn't help much as it doesn't highlight moves. Instead you can use something like this, see visual results \href{https://github.com/nim-lang/Nim/pull/10431\#issuecomment-456968196}{here}:\begin{rstpre}

git fetch origin pull/10431/head \&\& git checkout FETCH\_HEAD
git diff --color-moved-ws=allow-indentation-change --color-moved=blocks HEAD\symbol{94}
\end{rstpre}

\end{enumerate}
\begin{enumerate}\item In addition, you can view github-like diffs locally to identify what was changed within a code block using \texttt{diff-highlight} or \texttt{diff-so-fancy}, e.g.:\begin{rstpre}

\# put this in \symbol{126}/.gitconfig:
\symbol{91}core\symbol{93}
  pager = "diff-so-fancy | less -R" \# or: use: \symbol{96}diff-highlight\symbol{96}
\end{rstpre}

\end{enumerate}
\rsthA{Documentation Style}\label{documentation-style}
\rsthB{General Guidelines}\label{documentation-style-general-guidelines}
\begin{itemize}\item See also \href{https://nim-lang.github.io/Nim/nep1.html}{nep1} which should probably be merged here.
\item Authors should document anything that is exported; documentation for private procs can be useful too (visible via \texttt{nim doc --docInternal foo.nim}).
\item Within documentation, a period (\texttt{.}) should follow each sentence (or sentence fragment) in a comment block. The documentation may be limited to one sentence fragment, but if multiple sentences are within the documentation, each sentence after the first should be complete and in present tense.
\item Documentation is parsed as a custom ReStructuredText (RST) with partial markdown support.
\item In nim sources, prefer single backticks to double backticks since it's simpler and \texttt{nim doc} supports it (even in rst files with \texttt{nim rst2html}).
\item In nim sources, for links, prefer \texttt{\symbol{91}link text\symbol{93}(link.html)} to \begin{rstpre}
 \symbol{96}link text<link.html>\symbol{96}\_ 
\end{rstpre}
 since the syntax is simpler and markdown is more common (likewise, \texttt{nim rst2html} also supports it in rst files).
\end{itemize}
\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{someproc}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{foo}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\#\# Use single backticks for inline code, eg: \symbol{96}s\symbol{96} or \symbol{96}someExpr(true)\symbol{96}.}
  \spanComment{\#\# Use a backlash to follow with alphanumeric char: \symbol{96}int8\symbol{96}\symbol{92}s are great.}
\end{rstpre}
\rsthB{Module-level documentation}\label{documentation-style-moduleminuslevel-documentation}
Documentation of a module is placed at the top of the module itself. Each line of documentation begins with double hashes (\texttt{\#\#}). Sometimes \texttt{\#\#\symbol{91} multiline docs containing code \symbol{93}\#\#} is preferable, see \texttt{lib/pure/times.nim}. Code samples are encouraged, and should follow the general RST syntax:

\begin{rstpre}
\spanComment{\#\# The \symbol{96}universe\symbol{96} module computes the answer to life, the universe, and everything.}
\spanComment{\#\#}
\spanComment{\#\# .. code-block::}
\spanComment{\#\#  doAssert computeAnswerString() == 42}
\end{rstpre}
Within this top-level comment, you can indicate the authorship and copyright of the code, which will be featured in the produced documentation.

\begin{rstpre}
\spanComment{\#\# This is the best module ever. It provides answers to everything!}
\spanComment{\#\#}
\spanComment{\#\# :Author: Steve McQueen}
\spanComment{\#\# :Copyright: 1965}
\spanComment{\#\#}
\end{rstpre}
Leave a space between the last line of top-level documentation and the beginning of Nim code (the imports, etc.).

\rsthB{Procs, Templates, Macros, Converters, and Iterators}\label{documentation-style-procs-templates-macros-converters-and-iterators}
The documentation of a procedure should begin with a capital letter and should be in present tense. Variables referenced in the documentation should be surrounded by single tick marks:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{example1}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\#\# Prints the value of \symbol{96}x\symbol{96}.}
  \spanIdentifier{echo} \spanIdentifier{x}
\end{rstpre}
Whenever an example of usage would be helpful to the user, you should include one within the documentation in RST format as below.

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{addThree}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanIdentifier{z}\spanPunctuation{:} \spanIdentifier{int8}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanComment{\#\# Adds three \symbol{96}int8\symbol{96} values, treating them as unsigned and}
  \spanComment{\#\# truncating the result.}
  \spanComment{\#\#}
  \spanComment{\#\# .. code-block::}
  \spanComment{\#\#  \# things that aren't suitable for a \symbol{96}runnableExamples\symbol{96} go in code-block:}
  \spanComment{\#\#  echo execCmdEx("git pull")}
  \spanComment{\#\#  drawOnScreen()}
  \spanIdentifier{runnableExamples}\spanPunctuation{:}
    \spanComment{\# \symbol{96}runnableExamples\symbol{96} is usually preferred to \symbol{96}code-block\symbol{96}, when possible.}
    \spanIdentifier{doAssert} \spanIdentifier{addThree}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{125}\spanPunctuation{,} \spanDecNumber{6}\spanPunctuation{)} \spanOperator{==} \spanOperator{-}\spanDecNumber{122}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{x} \spanOperator{+\%} \spanIdentifier{y} \spanOperator{+\%} \spanIdentifier{z}
\end{rstpre}
The commands \texttt{nim doc} and \texttt{nim doc2} will then correctly syntax highlight the Nim code within the documentation.

\rsthB{Types}\label{documentation-style-types}
Exported types should also be documented. This documentation can also contain code samples, but those are better placed with the functions to which they refer.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{NamedQueue}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{object} \spanComment{\#\# Provides a linked data structure with names}
                          \spanComment{\#\# throughout. It is named for convenience. I'm making}
                          \spanComment{\#\# this comment long to show how you can, too.}
    \spanIdentifier{name}\spanOperator{*:} \spanIdentifier{string} \spanComment{\#\# The name of the item}
    \spanIdentifier{val}\spanOperator{*:} \spanIdentifier{T} \spanComment{\#\# Its value}
    \spanIdentifier{next}\spanOperator{*:} \spanKeyword{ref} \spanIdentifier{NamedQueue}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanComment{\#\# The next item in the queue}
\end{rstpre}
You have some flexibility when placing the documentation:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{NamedQueue}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{object}
    \spanComment{\#\# Provides a linked data structure with names}
    \spanComment{\#\# throughout. It is named for convenience. I'm making}
    \spanComment{\#\# this comment long to show how you can, too.}
    \spanIdentifier{name}\spanOperator{*:} \spanIdentifier{string} \spanComment{\#\# The name of the item}
    \spanIdentifier{val}\spanOperator{*:} \spanIdentifier{T} \spanComment{\#\# Its value}
    \spanIdentifier{next}\spanOperator{*:} \spanKeyword{ref} \spanIdentifier{NamedQueue}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanComment{\#\# The next item in the queue}
\end{rstpre}
Make sure to place the documentation beside or within the object.

\begin{rstpre}
\spanKeyword{type}
  \spanComment{\#\# Bad: this documentation disappears because it annotates the \symbol{96}\symbol{96}type\symbol{96}\symbol{96} keyword}
  \spanComment{\#\# above, not \symbol{96}\symbol{96}NamedQueue\symbol{96}\symbol{96}.}
  \spanIdentifier{NamedQueue}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{name}\spanOperator{*:} \spanIdentifier{string} \spanComment{\#\# This becomes the main documentation for the object, which}
                  \spanComment{\#\# is not what we want.}
    \spanIdentifier{val}\spanOperator{*:} \spanIdentifier{T} \spanComment{\#\# Its value}
    \spanIdentifier{next}\spanOperator{*:} \spanKeyword{ref} \spanIdentifier{NamedQueue}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanComment{\#\# The next item in the queue}
\end{rstpre}
\rsthB{Var, Let, and Const}\label{documentation-style-var-let-and-const}
When declaring module-wide constants and values, documentation is encouraged. The placement of doc comments is similar to the \texttt{type} sections.

\begin{rstpre}
\spanKeyword{const}
  \spanIdentifier{X}\spanOperator{*} \spanOperator{=} \spanDecNumber{42} \spanComment{\#\# An awesome number.}
  \spanIdentifier{SpreadArray}\spanOperator{*} \spanOperator{=} \spanPunctuation{\symbol{91}}
    \spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,}\spanDecNumber{2}\spanPunctuation{,}\spanDecNumber{3}\spanPunctuation{\symbol{93}}\spanPunctuation{,}
    \spanPunctuation{\symbol{91}}\spanDecNumber{2}\spanPunctuation{,}\spanDecNumber{3}\spanPunctuation{,}\spanDecNumber{1}\spanPunctuation{\symbol{93}}\spanPunctuation{,}
    \spanPunctuation{\symbol{91}}\spanDecNumber{3}\spanPunctuation{,}\spanDecNumber{1}\spanPunctuation{,}\spanDecNumber{2}\spanPunctuation{\symbol{93}}\spanPunctuation{,}
  \spanPunctuation{\symbol{93}} \spanComment{\#\# Doc comment for \symbol{96}\symbol{96}SpreadArray\symbol{96}\symbol{96}.}
\end{rstpre}
Placement of comments in other areas is usually allowed, but will not become part of the documentation output and should therefore be prefaced by a single hash (\texttt{\#}).

\begin{rstpre}
\spanKeyword{const}
  \spanIdentifier{BadMathVals}\spanOperator{*} \spanOperator{=} \spanPunctuation{\symbol{91}}
    \spanFloatNumber{3.14}\spanPunctuation{,} \spanComment{\# pi}
    \spanFloatNumber{2.72}\spanPunctuation{,} \spanComment{\# e}
    \spanFloatNumber{0.58}\spanPunctuation{,} \spanComment{\# gamma}
  \spanPunctuation{\symbol{93}} \spanComment{\#\# A bunch of badly rounded values.}
\end{rstpre}
Nim supports Unicode in comments, so the above can be replaced with the following:

\begin{rstpre}
\spanKeyword{const}
  \spanIdentifier{BadMathVals}\spanOperator{*} \spanOperator{=} \spanPunctuation{\symbol{91}}
    \spanFloatNumber{3.14}\spanPunctuation{,} \spanComment{\# π}
    \spanFloatNumber{2.72}\spanPunctuation{,} \spanComment{\# e}
    \spanFloatNumber{0.58}\spanPunctuation{,} \spanComment{\# γ}
  \spanPunctuation{\symbol{93}} \spanComment{\#\# A bunch of badly rounded values (including π!).}
\end{rstpre}
\rsthA{Evolving the stdlib}\label{evolving-the-stdlib}
As outlined in \href{https://github.com/nim-lang/RFCs/issues/173}{https://github.com/nim-lang/RFCs/issues/173} there are a couple of guidelines about what should go into the stdlib, what should be added and what eventually should be removed.

\rsthB{What the compiler itself needs must be part of the stdlib}\label{evolving-the-stdlib-what-the-compiler-itself-needs-must-be-part-of-the-stdlib}
Maybe in the future the compiler itself can depend on Nimble packages but for the time being, we strive to have zero dependencies in the compiler as the compiler is the root of the bootstrapping process and is also used to build Nimble.

\rsthB{Vocabulary types must be part of the stdlib}\label{evolving-the-stdlib-vocabulary-types-must-be-part-of-the-stdlib}
These are types most packages need to agree on for better interoperability, for example \texttt{Option\symbol{91}T\symbol{93}}. This rule also covers the existing collections like \texttt{Table}, \texttt{CountTable} etc. "Sorted" containers based on a tree-like data structure are still missing and should be added.

Time handling, especially the \texttt{Time} type are also covered by this rule.

\rsthB{Existing, battle-tested modules stay}\label{evolving-the-stdlib-existing-battleminustested-modules-stay}
Reason: There is no benefit in moving them around just to fullfill some design fashion as in "Nim's core MUST BE SMALL". If you don't like an existing module, don't import it. If a compilation target (e.g. JS) cannot support a module, document this limitation.

This covers modules like \texttt{os}, \texttt{osproc}, \texttt{strscans}, \texttt{strutils}, \texttt{strformat}, etc.

\rsthB{Syntactic helpers can start as experimental stdlib modules}\label{evolving-the-stdlib-syntactic-helpers-can-start-as-experimental-stdlib-modules}
Reason: Generally speaking as external dependencies they are not exposed to enough users so that we can see if the shortcuts provide enough benefit or not. Many programmers avoid external dependencies, even moreso for "tiny syntactic improvements". However, this is only true for really good syntactic improvements that have the potential to clean up other parts of the Nim library substantially. If in doubt, new stdlib modules should start as external, successful Nimble packages.

\rsthB{Other new stdlib modules do not start as stdlib modules}\label{evolving-the-stdlib-other-new-stdlib-modules-do-not-start-as-stdlib-modules}
As we strive for higher quality everywhere, it's easier to adopt existing, battle-tested modules eventually rather than creating modules from scratch.

\rsthB{Little additions are acceptable}\label{evolving-the-stdlib-little-additions-are-acceptable}
As long as they are documented and tested well, adding little helpers to existing modules is acceptable. For two reasons:

\begin{enumerate}\item It makes Nim easier to learn and use in the long run. ("Why does sequtils lack a \texttt{countIt}? Because version 1.0 happens to have lacked it? Silly...")
\item To encourage contributions. Contributors often start with PRs that add simple things and then they stay and also fix bugs. Nim is an open source project and lives from people's contributions and involvement. Newly introduced issues have to be balanced against motivating new people. We know where to find perfectly designed pieces of software that have no bugs -- these are the systems that nobody uses.
\end{enumerate}



\end{document}
