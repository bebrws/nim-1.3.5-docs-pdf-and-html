% This file was generated by Nim.
% Generated: 2020-08-22 06:37:23 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{Embedded Stack Trace Profiler (ESTP) User Guide 1.3.5}
\author{Andreas Rumpf}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

Nim comes with a platform independent profiler - the Embedded Stack Trace Profiler (ESTP). The profiler is \emph{embedded} into your executable. To activate the profiler you need to do:

\begin{itemize}\item compile your program with the \texttt{--profiler:on --stackTrace:on} command line options
\item import the \texttt{nimprof} module
\item run your program as usual.
\end{itemize}
You can in fact look at \texttt{nimprof}'s source code to see how to implement your own profiler.

The setting \texttt{--profiler:on} defines the conditional symbol \texttt{profiler}.

After your program has finished the profiler will create a file \texttt{profile\_results.txt} containing the profiling results.

Since the profiler works by examining stack traces, it's essential that the option \texttt{--stackTrace:on} is active! Unfortunately this means that a profiling build is much slower than a release build.

\rsthA{Memory profiler}\label{memory-profiler}
You can also use ESTP as a memory profiler to see which stack traces allocate the most memory and thus create the most GC pressure. It may also help to find memory leaks. To activate the memory profiler you need to do:

\begin{itemize}\item compile your program with the \texttt{--profiler:off --stackTrace:on -d:memProfiler} command line options. Yes it's \texttt{--profiler:off}.
\item import the \texttt{nimprof} module
\item run your program as usual.
\end{itemize}
Define the symbol \texttt{ignoreAllocationSize} so that only the number of allocations is counted and the sizes of the memory allocations do not matter.

\rsthA{Example results file}\label{example-results-file}
The results file lists stack traces ordered by significance.

The following example file has been generated by profiling the Nim compiler itself: It shows that in total 5.4\% of the runtime has been spent in \texttt{crcFromRope} or its children.

In general the stack traces show you immediately where the problem is because the trace acts like an explanation; in traditional profilers you can only find expensive leaf functions easily but the \emph{reason} why they are invoked often remains mysterious.

\begin{rstpre}
total executions of each stack trace:
Entry: 0/3391 Calls: 84/4160 = 2.0\% \symbol{91}sum: 84; 84/4160 = 2.0\%\symbol{93}
  newCrcFromRopeAux
  crcFromRope
  writeRopeIfNotEqual
  shouldRecompile
  writeModule
  myClose
  closePasses
  processModule
  CompileModule
  CompileProject
  CommandCompileToC
  MainCommand
  HandleCmdLine
  nim
Entry: 1/3391 Calls: 46/4160 = 1.1\% \symbol{91}sum: 130; 130/4160 = 3.1\%\symbol{93}
  updateCrc32
  newCrcFromRopeAux
  crcFromRope
  writeRopeIfNotEqual
  shouldRecompile
  writeModule
  myClose
  closePasses
  processModule
  CompileModule
  CompileProject
  CommandCompileToC
  MainCommand
  HandleCmdLine
  nim
Entry: 2/3391 Calls: 41/4160 = 0.99\% \symbol{91}sum: 171; 171/4160 = 4.1\%\symbol{93}
  updateCrc32
  updateCrc32
  newCrcFromRopeAux
  crcFromRope
  writeRopeIfNotEqual
  shouldRecompile
  writeModule
  myClose
  closePasses
  processModule
  CompileModule
  CompileProject
  CommandCompileToC
  MainCommand
  HandleCmdLine
  nim
Entry: 3/3391 Calls: 41/4160 = 0.99\% \symbol{91}sum: 212; 212/4160 = 5.1\%\symbol{93}
  crcFromFile
  writeRopeIfNotEqual
  shouldRecompile
  writeModule
  myClose
  closePasses
  processModule
  CompileModule
  CompileProject
  CommandCompileToC
  MainCommand
  HandleCmdLine
  nim
Entry: 4/3391 Calls: 41/4160 = 0.99\% \symbol{91}sum: 253; 253/4160 = 6.1\%\symbol{93}
  updateCrc32
  crcFromFile
  writeRopeIfNotEqual
  shouldRecompile
  writeModule
  myClose
  closePasses
  processModule
  CompileModule
  CompileProject
  CommandCompileToC
  MainCommand
  HandleCmdLine
  nim
Entry: 5/3391 Calls: 32/4160 = 0.77\% \symbol{91}sum: 285; 285/4160 = 6.9\%\symbol{93}
  pop
  newCrcFromRopeAux
  crcFromRope
  writeRopeIfNotEqual
  shouldRecompile
  writeModule
  myClose
  closePasses
  processModule
  CompileModule
  CompileProject
  CommandCompileToC
  MainCommand
  HandleCmdLine
  nim
Entry: 6/3391 Calls: 17/4160 = 0.41\% \symbol{91}sum: 302; 302/4160 = 7.3\%\symbol{93}
  doOperation
  forAllChildrenAux
  pop
  newCrcFromRopeAux
  crcFromRope
  writeRopeIfNotEqual
  shouldRecompile
  writeModule
  myClose
  closePasses
  processModule
  CompileModule
  CompileProject
  CommandCompileToC
  MainCommand
  HandleCmdLine
  ...
  nim
Entry: 7/3391 Calls: 14/4160 = 0.34\% \symbol{91}sum: 316; 316/4160 = 7.6\%\symbol{93}
  Contains
  isAccessible
  interiorAllocatedPtr
  gcMark
  markStackAndRegisters
  collectCTBody
  collectCT
  rawNewObj
  newObj
  newNode
  copyTree
  matchesAux
  matches
  resolveOverloads
  semOverloadedCall
  semOverloadedCallAnalyseEffects
  ...
  CommandCompileToC
  MainCommand
  HandleCmdLine
\end{rstpre}



\end{document}
