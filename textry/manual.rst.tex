\hypertarget{nim-manual}{%
\section{Nim Manual}\label{nim-manual}}

\begin{description}
\item[Authors]
Andreas Rumpf, Zahary Karadjov
\item[Version]
1.3.5
\end{description}

"Complexity" seems to be a lot like "energy": you can transfer it from
the end user to one/some of the other players, but the total amount
seems to remain pretty much constant for a given task. -\/- Ran

\hypertarget{about-this-document}{%
\subsection{About this document}\label{about-this-document}}

\textbf{Note}: This document is a draft! Several of Nim's features may
need more precise wording. This manual is constantly evolving into a
proper specification.

\textbf{Note}: The experimental features of Nim are covered
\href{manual_experimental.html}{here}.

\textbf{Note}: Assignments, moves and destruction are specified in the
\href{destructors.html}{destructors} document.

This document describes the lexis, the syntax, and the semantics of the
Nim language.

To learn how to compile Nim programs and generate documentation see
\href{nimc.html}{Compiler User Guide} and \href{docgen.html}{DocGen
Tools Guide}.

The language constructs are explained using an extended BNF, in which
\texttt{(a)*} means 0 or more \texttt{a}'s, \texttt{a+} means 1 or more
\texttt{a}'s, and \texttt{(a)?} means an optional \emph{a}. Parentheses
may be used to group elements.

\texttt{\&} is the lookahead operator; \texttt{\&a} means that an
\texttt{a} is expected but not consumed. It will be consumed in the
following rule.

The \texttt{\textbar{}}, \texttt{/} symbols are used to mark
alternatives and have the lowest precedence. \texttt{/} is the ordered
choice that requires the parser to try the alternatives in the given
order. \texttt{/} is often used to ensure the grammar is not ambiguous.

Non-terminals start with a lowercase letter, abstract terminal symbols
are in UPPERCASE. Verbatim terminal symbols (including keywords) are
quoted with \texttt{\textquotesingle{}}. An example:

\begin{verbatim}
ifStmt = 'if' expr ':' stmts ('elif' expr ':' stmts)* ('else' stmts)?
\end{verbatim}

The binary \texttt{\^{}*} operator is used as a shorthand for 0 or more
occurrences separated by its second argument; likewise \texttt{\^{}+}
means 1 or more occurrences: \texttt{a\ \^{}+\ b} is short for
\texttt{a\ (b\ a)*} and \texttt{a\ \^{}*\ b} is short for
\texttt{(a\ (b\ a)*)?}. Example:

\begin{verbatim}
arrayConstructor = '[' expr ^* ',' ']'
\end{verbatim}

Other parts of Nim, like scoping rules or runtime semantics, are
described informally.

\hypertarget{definitions}{%
\subsection{Definitions}\label{definitions}}

Nim code specifies a computation that acts on a memory consisting of
components called \texttt{locations}. A variable is basically a name for
a location. Each variable and location is of a certain \texttt{type}.
The variable's type is called \texttt{static\ type}, the location's type
is called \texttt{dynamic\ type}. If the static type is not the same as
the dynamic type, it is a super-type or subtype of the dynamic type.

An \texttt{identifier} is a symbol declared as a name for a variable,
type, procedure, etc. The region of the program over which a declaration
applies is called the \texttt{scope} of the declaration. Scopes can be
nested. The meaning of an identifier is determined by the smallest
enclosing scope in which the identifier is declared unless overloading
resolution rules suggest otherwise.

An expression specifies a computation that produces a value or location.
Expressions that produce locations are called \texttt{l-values}. An
l-value can denote either a location or the value the location contains,
depending on the context.

A Nim \texttt{program} consists of one or more text
\texttt{source\ files} containing Nim code. It is processed by a Nim
\texttt{compiler} into an \texttt{executable}. The nature of this
executable depends on the compiler implementation; it may, for example,
be a native binary or JavaScript source code.

In a typical Nim program, most of the code is compiled into the
executable. However, some of the code may be executed at
\texttt{compile\ time}. This can include constant expressions, macro
definitions, and Nim procedures used by macro definitions. Most of the
Nim language is supported at compile time, but there are some
restrictions -\/- see
\protect\hyperlink{restrictions-on-compileminustime-execution}{Restrictions
on Compile-Time Execution} for details. We use the term \texttt{runtime}
to cover both compile-time execution and code execution in the
executable.

The compiler parses Nim source code into an internal data structure
called the \texttt{abstract\ syntax\ tree} (\texttt{AST}). Then, before
executing the code or compiling it into the executable, it transforms
the AST through \texttt{semantic\ analysis}. This adds semantic
information such as expression types, identifier meanings, and in some
cases expression values. An error detected during semantic analysis is
called a \texttt{static\ error}. Errors described in this manual are
static errors when not otherwise specified.

A \texttt{panic} is an error that the implementation detects and reports
at runtime. The method for reporting such errors is via \emph{raising
exceptions} or \emph{dying with a fatal error}. However, the
implementation provides a means to disable these
\texttt{runtime\ checks}. See the section
\protect\hyperlink{pragmas}{pragmas} for details.

Whether a panic results in an exception or in a fatal error is
implementation specific. Thus the following program is invalid; even
though the code purports to catch the {IndexDefect} from an
out-of-bounds array access, the compiler may instead choose to allow the
program to die with a fatal error.

\begin{verbatim}
\end{verbatim}

The current implementation allows to switch between these different
behaviors via \texttt{-\/-panics:on\textbar{}off}. When panics are
turned on, the program dies on a panic, if they are turned off the
runtime errors are turned into exceptions. The benefit of
\texttt{-\/-panics:on} is that it produces smaller binary code and the
compiler has more freedom to optimize the code.

An \texttt{unchecked\ runtime\ error} is an error that is not guaranteed
to be detected, and can cause the subsequent behavior of the computation
to be arbitrary. Unchecked runtime errors cannot occur if only
\texttt{safe} language features are used and if no runtime checks are
disabled.

A \texttt{constant\ expression} is an expression whose value can be
computed during semantic analysis of the code in which it appears. It is
never an l-value and never has side effects. Constant expressions are
not limited to the capabilities of semantic analysis, such as constant
folding; they can use all Nim language features that are supported for
compile-time execution. Since constant expressions can be used as an
input to semantic analysis (such as for defining array bounds), this
flexibility requires the compiler to interleave semantic analysis and
compile-time code execution.

It is mostly accurate to picture semantic analysis proceeding top to
bottom and left to right in the source code, with compile-time code
execution interleaved when necessary to compute values that are required
for subsequent semantic analysis. We will see much later in this
document that macro invocation not only requires this interleaving, but
also creates a situation where semantic analysis does not entirely
proceed top to bottom and left to right.

\hypertarget{lexical-analysis}{%
\subsection{Lexical Analysis}\label{lexical-analysis}}

\hypertarget{encoding}{%
\subsubsection{Encoding}\label{encoding}}

All Nim source files are in the UTF-8 encoding (or its ASCII subset).
Other encodings are not supported. Any of the standard platform line
termination sequences can be used - the Unix form using ASCII LF
(linefeed), the Windows form using the ASCII sequence CR LF (return
followed by linefeed), or the old Macintosh form using the ASCII CR
(return) character. All of these forms can be used equally, regardless
of platform.

\hypertarget{indentation}{%
\subsubsection{Indentation}\label{indentation}}

Nim's standard grammar describes an \texttt{indentation\ sensitive}
language. This means that all the control structures are recognized by
indentation. Indentation consists only of spaces; tabulators are not
allowed.

The indentation handling is implemented as follows: The lexer annotates
the following token with the preceding number of spaces; indentation is
not a separate token. This trick allows parsing of Nim with only 1 token
of lookahead.

The parser uses a stack of indentation levels: the stack consists of
integers counting the spaces. The indentation information is queried at
strategic places in the parser but ignored otherwise: The pseudo
terminal \texttt{IND\{\textgreater{}\}} denotes an indentation that
consists of more spaces than the entry at the top of the stack;
\texttt{IND\{=\}} an indentation that has the same number of spaces.
\texttt{DED} is another pseudo terminal that describes the \emph{action}
of popping a value from the stack, \texttt{IND\{\textgreater{}\}} then
implies to push onto the stack.

With this notation we can now easily define the core of the grammar: A
block of statements (simplified example):

\begin{verbatim}
ifStmt = 'if' expr ':' stmt
         (IND{=} 'elif' expr ':' stmt)*
         (IND{=} 'else' ':' stmt)?

simpleStmt = ifStmt / ...

stmt = IND{>} stmt ^+ IND{=} DED  # list of statements
     / simpleStmt                 # or a simple statement
\end{verbatim}

\hypertarget{comments}{%
\subsubsection{Comments}\label{comments}}

Comments start anywhere outside a string or character literal with the
hash character \texttt{\#}. Comments consist of a concatenation of
\texttt{comment\ pieces}. A comment piece starts with \texttt{\#} and
runs until the end of the line. The end of line characters belong to the
piece. If the next line only consists of a comment piece with no other
tokens between it and the preceding one, it does not start a new
comment:

\begin{verbatim}
\end{verbatim}

\texttt{Documentation\ comments} are comments that start with two
\texttt{\#\#}. Documentation comments are tokens; they are only allowed
at certain places in the input file as they belong to the syntax tree!

\hypertarget{multiline-comments}{%
\subsubsection{Multiline comments}\label{multiline-comments}}

Starting with version 0.13.0 of the language Nim supports multiline
comments. They look like:

\begin{verbatim}
\end{verbatim}

Multiline comments support nesting:

\begin{verbatim}
\end{verbatim}

Multiline documentation comments also exist and support nesting too:

\begin{verbatim}
\end{verbatim}

\hypertarget{identifiers-keywords}{%
\subsubsection{Identifiers \& Keywords}\label{identifiers-keywords}}

Identifiers in Nim can be any string of letters, digits and underscores,
with the following restrictions:

\begin{itemize}
\item
  begins with a letter
\item
  does not end with an underscore \texttt{\_}
\item
  two immediate following underscores \texttt{\_\_} are not allowed:

  letter ::= 'A'..'Z' \textbar{} 'a'..'z' \textbar{} 'x80'..'xff' digit
  ::= '0'..'9' IDENTIFIER ::= letter ( {[}'\_'{]} (letter \textbar{}
  digit) )*
\end{itemize}

Currently any Unicode character with an ordinal value \textgreater{} 127
(non ASCII) is classified as a \texttt{letter} and may thus be part of
an identifier but later versions of the language may assign some Unicode
characters to belong to the operator characters instead.

The following keywords are reserved and cannot be used as identifiers:

\begin{verbatim}
\end{verbatim}

Some keywords are unused; they are reserved for future developments of
the language.

\hypertarget{identifier-equality}{%
\subsubsection{Identifier equality}\label{identifier-equality}}

Two identifiers are considered equal if the following algorithm returns
true:

\begin{verbatim}
\end{verbatim}

That means only the first letters are compared in a case sensitive
manner. Other letters are compared case insensitively within the ASCII
range and underscores are ignored.

This rather unorthodox way to do identifier comparisons is called
\texttt{partial\ case\ insensitivity} and has some advantages over the
conventional case sensitivity:

It allows programmers to mostly use their own preferred spelling style,
be it humpStyle or snake\_style, and libraries written by different
programmers cannot use incompatible conventions. A Nim-aware editor or
IDE can show the identifiers as preferred. Another advantage is that it
frees the programmer from remembering the exact spelling of an
identifier. The exception with respect to the first letter allows common
code like \texttt{var\ foo:\ Foo} to be parsed unambiguously.

Note that this rule also applies to keywords, meaning that
\texttt{notin} is the same as \texttt{notIn} and \texttt{not\_in}
(all-lowercase version (\texttt{notin}, \texttt{isnot}) is the preferred
way of writing keywords).

Historically, Nim was a fully \texttt{style-insensitive} language. This
meant that it was not case-sensitive and underscores were ignored and
there was not even a distinction between \texttt{foo} and \texttt{Foo}.

\hypertarget{string-literals}{%
\subsubsection{String literals}\label{string-literals}}

Terminal symbol in the grammar: \texttt{STR\_LIT}.

String literals can be delimited by matching double quotes, and can
contain the following \texttt{escape\ sequences}:

\begin{longtable}[]{@{}ll@{}}
\toprule
Escape sequence & Meaning\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}p}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
platform specific newline: CRLF on Windows, LF on Unix\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}r}, \texttt{\textbackslash{}c}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{carriage\ return}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}n}, \texttt{\textbackslash{}l}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{line\ feed} (often called \texttt{newline})\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}f}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{form\ feed}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}t}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{tabulator}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}v}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{vertical\ tabulator}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}\textbackslash{}}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{backslash}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}"}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{quotation\ mark}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}\textquotesingle{}}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{apostrophe}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}} '0'..'9'+
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{character\ with\ decimal\ value\ d}; all decimal digits directly
following are used for the character\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}a}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{alert}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}b}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{backspace}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}e}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{escape} \texttt{{[}ESC{]}}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}x} HH
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{character\ with\ hex\ value\ HH}; exactly two hex digits are
allowed\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}u} HHHH
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{unicode\ codepoint\ with\ hex\ value\ HHHH}; exactly four hex
digits are allowed\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}u} \{H+\}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{unicode\ codepoint}; all hex digits enclosed in \texttt{\{\}}
are used for the codepoint\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Strings in Nim may contain any 8-bit value, even embedded zeros. However
some operations may interpret the first binary zero as a terminator.

\hypertarget{triple-quoted-string-literals}{%
\subsubsection{Triple quoted string
literals}\label{triple-quoted-string-literals}}

Terminal symbol in the grammar: \texttt{TRIPLESTR\_LIT}.

String literals can also be delimited by three double quotes
\texttt{"""} ... \texttt{"""}. Literals in this form may run for several
lines, may contain \texttt{"} and do not interpret any escape sequences.
For convenience, when the opening \texttt{"""} is followed by a newline
(there may be whitespace between the opening \texttt{"""} and the
newline), the newline (and the preceding whitespace) is not included in
the string. The ending of the string literal is defined by the pattern
\texttt{"""{[}\^{}"{]}}, so this:

\begin{verbatim}
\end{verbatim}

Produces:

\begin{verbatim}
"long string within quotes"
\end{verbatim}

\hypertarget{raw-string-literals}{%
\subsubsection{Raw string literals}\label{raw-string-literals}}

Terminal symbol in the grammar: \texttt{RSTR\_LIT}.

There are also raw string literals that are preceded with the letter
\texttt{r} (or \texttt{R}) and are delimited by matching double quotes
(just like ordinary string literals) and do not interpret the escape
sequences. This is especially convenient for regular expressions or
Windows paths:

\begin{verbatim}
var f = openFile(r"C:\texts\text.txt") # a raw string, so ``\t`` is no tab
\end{verbatim}

To produce a single \texttt{"} within a raw string literal, it has to be
doubled:

\begin{verbatim}
r"a""b"
\end{verbatim}

Produces:

\begin{verbatim}
a"b
\end{verbatim}

\texttt{r""""} is not possible with this notation, because the three
leading quotes introduce a triple quoted string literal. \texttt{r"""}
is the same as \texttt{"""} since triple quoted string literals do not
interpret escape sequences either.

\hypertarget{generalized-raw-string-literals}{%
\subsubsection{Generalized raw string
literals}\label{generalized-raw-string-literals}}

Terminal symbols in the grammar: \texttt{GENERALIZED\_STR\_LIT},
\texttt{GENERALIZED\_TRIPLESTR\_LIT}.

The construct \texttt{identifier"string\ literal"} (without whitespace
between the identifier and the opening quotation mark) is a generalized
raw string literal. It is a shortcut for the construct
\texttt{identifier(r"string\ literal")}, so it denotes a procedure call
with a raw string literal as its only argument. Generalized raw string
literals are especially convenient for embedding mini languages directly
into Nim (for example regular expressions).

The construct \texttt{identifier"""string\ literal"""} exists too. It is
a shortcut for \texttt{identifier("""string\ literal""")}.

\hypertarget{character-literals}{%
\subsubsection{Character literals}\label{character-literals}}

Character literals are enclosed in single quotes
\texttt{\textquotesingle{}\textquotesingle{}} and can contain the same
escape sequences as strings - with one exception: the platform dependent
\texttt{newline} (\texttt{\textbackslash{}p}) is not allowed as it may
be wider than one character (often it is the pair CR/LF for example).
Here are the valid \texttt{escape\ sequences} for character literals:

\begin{longtable}[]{@{}ll@{}}
\toprule
Escape sequence & Meaning\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}r}, \texttt{\textbackslash{}c}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{carriage\ return}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}n}, \texttt{\textbackslash{}l}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{line\ feed}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}f}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{form\ feed}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}t}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{tabulator}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}v}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{vertical\ tabulator}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}\textbackslash{}}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{backslash}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}"}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{quotation\ mark}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}\textquotesingle{}}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{apostrophe}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}} '0'..'9'+
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{character\ with\ decimal\ value\ d}; all decimal digits directly
following are used for the character\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}a}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{alert}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}b}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{backspace}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}e}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{escape} \texttt{{[}ESC{]}}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textbackslash{}x} HH
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\texttt{character\ with\ hex\ value\ HH}; exactly two hex digits are
allowed\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

A character is not an Unicode character but a single byte. The reason
for this is efficiency: for the overwhelming majority of use-cases, the
resulting programs will still handle UTF-8 properly as UTF-8 was
specially designed for this. Another reason is that Nim can thus support
\texttt{array{[}char,\ int{]}} or \texttt{set{[}char{]}} efficiently as
many algorithms rely on this feature. The {Rune} type is used for
Unicode characters, it can represent any Unicode character.
\texttt{Rune} is declared in the \href{unicode.html}{unicode module}.

\hypertarget{numerical-constants}{%
\subsubsection{Numerical constants}\label{numerical-constants}}

Numerical constants are of a single type and have the form:

\begin{verbatim}
hexdigit = digit | 'A'..'F' | 'a'..'f'
octdigit = '0'..'7'
bindigit = '0'..'1'
HEX_LIT = '0' ('x' | 'X' ) hexdigit ( ['_'] hexdigit )*
DEC_LIT = digit ( ['_'] digit )*
OCT_LIT = '0' 'o' octdigit ( ['_'] octdigit )*
BIN_LIT = '0' ('b' | 'B' ) bindigit ( ['_'] bindigit )*

INT_LIT = HEX_LIT
        | DEC_LIT
        | OCT_LIT
        | BIN_LIT

INT8_LIT = INT_LIT ['\''] ('i' | 'I') '8'
INT16_LIT = INT_LIT ['\''] ('i' | 'I') '16'
INT32_LIT = INT_LIT ['\''] ('i' | 'I') '32'
INT64_LIT = INT_LIT ['\''] ('i' | 'I') '64'

UINT_LIT = INT_LIT ['\''] ('u' | 'U')
UINT8_LIT = INT_LIT ['\''] ('u' | 'U') '8'
UINT16_LIT = INT_LIT ['\''] ('u' | 'U') '16'
UINT32_LIT = INT_LIT ['\''] ('u' | 'U') '32'
UINT64_LIT = INT_LIT ['\''] ('u' | 'U') '64'

exponent = ('e' | 'E' ) ['+' | '-'] digit ( ['_'] digit )*
FLOAT_LIT = digit (['_'] digit)* (('.' digit (['_'] digit)* [exponent]) |exponent)
FLOAT32_SUFFIX = ('f' | 'F') ['32']
FLOAT32_LIT = HEX_LIT '\'' FLOAT32_SUFFIX
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) ['\''] FLOAT32_SUFFIX
FLOAT64_SUFFIX = ( ('f' | 'F') '64' ) | 'd' | 'D'
FLOAT64_LIT = HEX_LIT '\'' FLOAT64_SUFFIX
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) ['\''] FLOAT64_SUFFIX
\end{verbatim}

As can be seen in the productions, numerical constants can contain
underscores for readability. Integer and floating point literals may be
given in decimal (no prefix), binary (prefix \texttt{0b}), octal (prefix
\texttt{0o}) and hexadecimal (prefix \texttt{0x}) notation.

There exists a literal for each numerical type that is defined. The
suffix starting with an apostrophe (''') is called a
\texttt{type\ suffix}. Literals without a type suffix are of an integer
type, unless the literal contains a dot or \texttt{E\textbar{}e} in
which case it is of type \texttt{float}. This integer type is
\texttt{int} if the literal is in the range
\texttt{low(i32)..high(i32)}, otherwise it is \texttt{int64}. For
notational convenience the apostrophe of a type suffix is optional if it
is not ambiguous (only hexadecimal floating point literals with a type
suffix can be ambiguous).

The type suffixes are:

\begin{longtable}[]{@{}ll@{}}
\toprule
Type Suffix & Resulting type of literal\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textquotesingle{}i8}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
int8\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textquotesingle{}i16}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
int16\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textquotesingle{}i32}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
int32\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textquotesingle{}i64}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
int64\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textquotesingle{}u}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
uint\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textquotesingle{}u8}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
uint8\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textquotesingle{}u16}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
uint16\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textquotesingle{}u32}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
uint32\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textquotesingle{}u64}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
uint64\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textquotesingle{}f}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
float32\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textquotesingle{}d}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
float64\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textquotesingle{}f32}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
float32\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\begin{quote}
\texttt{\textquotesingle{}f64}
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
float64\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Floating point literals may also be in binary, octal or hexadecimal
notation:
\texttt{0B0\_10001110100\_0000101001000111101011101111111011000101001101001001\textquotesingle{}f64}
is approximately 1.72826e35 according to the IEEE floating point
standard.

Literals are bounds checked so that they fit the datatype. Non base-10
literals are used mainly for flags and bit pattern representations,
therefore bounds checking is done on bit width, not value range. If the
literal fits in the bit width of the datatype, it is accepted. Hence:
0b10000000'u8 == 0x80'u8 == 128, but, 0b10000000'i8 == 0x80'i8 == -1
instead of causing an overflow error.

\hypertarget{operators}{%
\subsubsection{Operators}\label{operators}}

Nim allows user defined operators. An operator is any combination of the
following characters:

\begin{verbatim}
=     +     -     *     /     <     >
@     $     ~     &     %     |
!     ?     ^     .     :     \
\end{verbatim}

(The grammar uses the terminal OPR to refer to operator symbols as
defined here.)

These keywords are also operators:
\texttt{and\ or\ not\ xor\ shl\ shr\ div\ mod\ in\ notin\ is\ isnot\ of\ as\ from}.

\texttt{.} \texttt{=}, \texttt{:}, \texttt{::} are not available as
general operators; they are used for other notational purposes.

\texttt{*:} is as a special case treated as the two tokens \texttt{*}
and \texttt{:} (to support \texttt{var\ v*:\ T}).

The \texttt{not} keyword is always a unary operator, \texttt{a\ not\ b}
is parsed as \texttt{a(not\ b)}, not as \texttt{(a)\ not\ (b)}.

\hypertarget{other-tokens}{%
\subsubsection{Other tokens}\label{other-tokens}}

The following strings denote other tokens:

\begin{verbatim}
`   (    )     {    }     [    ]    ,  ;   [.    .]  {.   .}  (.  .)  [:
\end{verbatim}

The \texttt{slice} operator \texttt{..} takes precedence over other
tokens that contain a dot: \texttt{\{..\}} are the three tokens
\texttt{\{}, \texttt{..}, \texttt{\}} and not the two tokens
\texttt{\{.}, \texttt{.\}}.

\hypertarget{syntax}{%
\subsection{Syntax}\label{syntax}}

This section lists Nim's standard syntax. How the parser handles the
indentation is already described in the
\protect\hyperlink{lexical-analysis}{Lexical Analysis} section.

Nim allows user-definable operators. Binary operators have 11 different
levels of precedence.

\hypertarget{associativity}{%
\subsubsection{Associativity}\label{associativity}}

Binary operators whose first character is \texttt{\^{}} are
right-associative, all other binary operators are left-associative.

\begin{verbatim}
\end{verbatim}

\hypertarget{precedence}{%
\subsubsection{Precedence}\label{precedence}}

Unary operators always bind stronger than any binary operator:
\texttt{\$a\ +\ b} is \texttt{(\$a)\ +\ b} and not \texttt{\$(a\ +\ b)}.

If an unary operator's first character is \texttt{@} it is a
\texttt{sigil-like} operator which binds stronger than a
\texttt{primarySuffix}: \texttt{@x.abc} is parsed as \texttt{(@x).abc}
whereas \texttt{\$x.abc} is parsed as \texttt{\$(x.abc)}.

For binary operators that are not keywords the precedence is determined
by the following rules:

Operators ending in either \texttt{-\textgreater{}},
\texttt{\textasciitilde{}\textgreater{}} or \texttt{=\textgreater{}} are
called \texttt{arrow\ like}, and have the lowest precedence of all
operators.

If the operator ends with \texttt{=} and its first character is none of
\texttt{\textless{}}, \texttt{\textgreater{}}, \texttt{!}, \texttt{=},
\texttt{\textasciitilde{}}, \texttt{?}, it is an \emph{assignment
operator} which has the second lowest precedence.

Otherwise precedence is determined by the first character.

\begin{longtable}[]{@{}llll@{}}
\toprule
Precedence level & Operators & First character & Terminal
symbol\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\begin{quote}
10 (highest)
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{\$\ \ \^{}}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
OP10\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\begin{quote}
9
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{*\ \ \ \ /\ \ \ \ div\ \ \ mod\ \ \ shl\ \ shr\ \ \%}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{*\ \ \%\ \ \textbackslash{}\ \ /}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
OP9\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\begin{quote}
8
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{+\ \ \ \ -}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{+\ \ -\ \ \textasciitilde{}\ \ \textbar{}}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
OP8\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\begin{quote}
7
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{\&}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{\&}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
OP7\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\begin{quote}
6
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{..}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{.}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
OP6\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\begin{quote}
5 4 3 2 1 0 (lowest)
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{==\ \ \textless{}=\ \textless{}\ \textgreater{}=\ \textgreater{}\ !=\ \ in\ notin\ is\ isnot\ not\ of\ as\ from}
\texttt{and} \texttt{or\ xor}

\emph{assignment operator} (like \texttt{+=}, \texttt{*=}) \emph{arrow
like operator} (like \texttt{-\textgreater{}},
\texttt{=\textgreater{}})\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
\texttt{=\ \ \textless{}\ \ \textgreater{}\ \ !}

\texttt{@\ \ :\ \ ?}\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
OP5 OP4 OP3 OP2 OP1 OP0\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Whether an operator is used a prefix operator is also affected by
preceding whitespace (this parsing change was introduced with version
0.13.0):

\begin{verbatim}
\end{verbatim}

Spacing also determines whether \texttt{(a,\ b)} is parsed as an the
argument list of a call or whether it is parsed as a tuple constructor:

\begin{verbatim}
\end{verbatim}

\begin{verbatim}
\end{verbatim}

\hypertarget{grammar}{%
\subsubsection{Grammar}\label{grammar}}

The grammar's start symbol is \texttt{module}.

\hypertarget{order-of-evaluation}{%
\subsection{Order of evaluation}\label{order-of-evaluation}}

Order of evaluation is strictly left-to-right, inside-out as it is
typical for most others imperative programming languages:

\begin{verbatim}
var s = ""

proc p(arg: int): int =
  s.add $arg
  result = arg

discard p(p(1) + p(2))

doAssert s == "123"
\end{verbatim}

Assignments are not special, the left-hand-side expression is evaluated
before the right-hand side:

\begin{verbatim}
var v = 0
proc getI(): int =
  result = v
  inc v

var a, b: array[0..2, int]

proc someCopy(a: var int; b: int) = a = b

a[getI()] = getI()

doAssert a == [1, 0, 0]

v = 0
someCopy(b[getI()], getI())

doAssert b == [1, 0, 0]
\end{verbatim}

Rationale: Consistency with overloaded assignment or assignment-like
operations, \texttt{a\ =\ b} can be read as
\texttt{performSomeCopy(a,\ b)}.

However, the concept of "order of evaluation" is only applicable after
the code was normalized: The normalization involves template expansions
and argument reorderings that have been passed to named parameters:

\begin{verbatim}
var s = ""

proc p(): int =
  s.add "p"
  result = 5

proc q(): int =
  s.add "q"
  result = 3

# Evaluation order is 'b' before 'a' due to template
# expansion's semantics.
template swapArgs(a, b): untyped =
  b + a

doAssert swapArgs(p() + q(), q() - p()) == 6
doAssert s == "qppq"

# Evaluation order is not influenced by named parameters:
proc construct(first, second: int) =
  discard

# 'p' is evaluated before 'q'!
construct(second = q(), first = p())

doAssert s == "qppqpq"
\end{verbatim}

Rationale: This is far easier to implement than hypothetical
alternatives.

\hypertarget{constants-and-constant-expressions}{%
\subsection{Constants and Constant
Expressions}\label{constants-and-constant-expressions}}

A \texttt{constant} is a symbol that is bound to the value of a constant
expression. Constant expressions are restricted to depend only on the
following categories of values and operations, because these are either
built into the language or declared and evaluated before semantic
analysis of the constant expression:

\begin{itemize}
\tightlist
\item
  literals
\item
  built-in operators
\item
  previously declared constants and compile-time variables
\item
  previously declared macros and templates
\item
  previously declared procedures that have no side effects beyond
  possibly modifying compile-time variables
\end{itemize}

A constant expression can contain code blocks that may internally use
all Nim features supported at compile time (as detailed in the next
section below). Within such a code block, it is possible to declare
variables and then later read and update them, or declare variables and
pass them to procedures that modify them. However, the code in such a
block must still adhere to the restrictions listed above for referencing
values and operations outside the block.

The ability to access and modify compile-time variables adds flexibility
to constant expressions that may be surprising to those coming from
other statically typed languages. For example, the following code echoes
the beginning of the Fibonacci series \textbf{at compile time}. (This is
a demonstration of flexibility in defining constants, not a recommended
style for solving this problem!)

\begin{verbatim}
\end{verbatim}

\begin{quote}
import strformat

var fib\_n \{.compileTime.\}: int var fib\_prev \{.compileTime.\}: int
var fib\_prev\_prev \{.compileTime.\}: int

\begin{description}
\item[proc next\_fib(): int =]
\begin{description}
\item[result = if fib\_n \textless{} 2:]
fib\_n
\item[else:]
fib\_prev\_prev + fib\_prev
\end{description}

inc(fib\_n) fib\_prev\_prev = fib\_prev fib\_prev = result
\end{description}

const f0 = next\_fib() const f1 = next\_fib()

\begin{description}
\item[const display\_fib = block:]
const f2 = next\_fib() var result = fmt"Fibonacci sequence: \{f0\},
\{f1\}, \{f2\}" for i in 3..12: add(result, fmt", \{next\_fib()\}")
result
\item[static:]
echo display\_fib
\end{description}
\end{quote}

\hypertarget{restrictions-on-compile-time-execution}{%
\subsection{Restrictions on Compile-Time
Execution}\label{restrictions-on-compile-time-execution}}

Nim code that will be executed at compile time cannot use the following
language features:

\begin{itemize}
\tightlist
\item
  methods
\item
  closure iterators
\item
  the \texttt{cast} operator
\item
  reference (pointer) types
\item
  FFI
\end{itemize}

The use of wrappers that use FFI and/or \texttt{cast} is also
disallowed. Note that these wrappers include the ones in the standard
libraries.

Some or all of these restrictions are likely to be lifted over time.

\hypertarget{types}{%
\subsection{Types}\label{types}}

All expressions have a type which is known during semantic analysis. Nim
is statically typed. One can declare new types, which is in essence
defining an identifier that can be used to denote this custom type.

These are the major type classes:

\begin{itemize}
\tightlist
\item
  ordinal types (consist of integer, bool, character, enumeration (and
  subranges thereof) types)
\item
  floating point types
\item
  string type
\item
  structured types
\item
  reference (pointer) type
\item
  procedural type
\item
  generic type
\end{itemize}

\hypertarget{ordinal-types}{%
\subsubsection{Ordinal types}\label{ordinal-types}}

Ordinal types have the following characteristics:

\begin{itemize}
\tightlist
\item
  Ordinal types are countable and ordered. This property allows the
  operation of functions as \texttt{inc}, \texttt{ord}, \texttt{dec} on
  ordinal types to be defined.
\item
  Ordinal values have a smallest possible value. Trying to count further
  down than the smallest value produces a panic or a static error.
\item
  Ordinal values have a largest possible value. Trying to count further
  than the largest value produces a panic or a static error.
\end{itemize}

Integers, bool, characters and enumeration types (and subranges of these
types) belong to ordinal types. For reasons of simplicity of
implementation the types \texttt{uint} and \texttt{uint64} are not
ordinal types. (This will be changed in later versions of the language.)

A distinct type is an ordinal type if its base type is an ordinal type.

\hypertarget{pre-defined-integer-types}{%
\subsubsection{Pre-defined integer
types}\label{pre-defined-integer-types}}

These integer types are pre-defined:

\begin{description}
\item[\texttt{int}]
the generic signed integer type; its size is platform dependent and has
the same size as a pointer. This type should be used in general. An
integer literal that has no type suffix is of this type if it is in the
range \texttt{low(int32)..high(int32)} otherwise the literal's type is
\texttt{int64}.
\item[intXX]
additional signed integer types of XX bits use this naming scheme
(example: int16 is a 16 bit wide integer). The current implementation
supports \texttt{int8}, \texttt{int16}, \texttt{int32}, \texttt{int64}.
Literals of these types have the suffix 'iXX.
\item[\texttt{uint}]
the generic \texttt{unsigned\ integer} type; its size is platform
dependent and has the same size as a pointer. An integer literal with
the type suffix \texttt{\textquotesingle{}u} is of this type.
\item[uintXX]
additional unsigned integer types of XX bits use this naming scheme
(example: uint16 is a 16 bit wide unsigned integer). The current
implementation supports \texttt{uint8}, \texttt{uint16},
\texttt{uint32}, \texttt{uint64}. Literals of these types have the
suffix 'uXX. Unsigned operations all wrap around; they cannot lead to
over- or underflow errors.
\end{description}

In addition to the usual arithmetic operators for signed and unsigned
integers (\texttt{+\ -\ *} etc.) there are also operators that formally
work on \emph{signed} integers but treat their arguments as
\emph{unsigned}: They are mostly provided for backwards compatibility
with older versions of the language that lacked unsigned integer types.
These unsigned operations for signed integers use the \texttt{\%} suffix
as convention:

\begin{longtable}[]{@{}ll@{}}
\toprule
operation & meaning\tabularnewline
\midrule
\endhead
\texttt{a\ +\%\ b} & unsigned integer addition\tabularnewline
\texttt{a\ -\%\ b} & unsigned integer subtraction\tabularnewline
\texttt{a\ *\%\ b} & unsigned integer multiplication\tabularnewline
\texttt{a\ /\%\ b} & unsigned integer division\tabularnewline
\texttt{a\ \%\%\ b} & unsigned integer modulo operation\tabularnewline
\texttt{a\ \textless{}\%\ b} & treat \texttt{a} and \texttt{b} as
unsigned and compare\tabularnewline
\texttt{a\ \textless{}=\%\ b} & treat \texttt{a} and \texttt{b} as
unsigned and compare\tabularnewline
\texttt{ze(a)} & extends the bits of \texttt{a} with zeros until it has
the width of the \texttt{int} type\tabularnewline
\texttt{toU8(a)} & treats \texttt{a} as unsigned and converts it to an
unsigned integer of 8 bits (but still the \texttt{int8}
type)\tabularnewline
\texttt{toU16(a)} & treats \texttt{a} as unsigned and converts it to an
unsigned integer of 16 bits (but still the \texttt{int16}
type)\tabularnewline
\texttt{toU32(a)} & treats \texttt{a} as unsigned and converts it to an
unsigned integer of 32 bits (but still the \texttt{int32}
type)\tabularnewline
\bottomrule
\end{longtable}

\texttt{Automatic\ type\ conversion} is performed in expressions where
different kinds of integer types are used: the smaller type is converted
to the larger.

A \texttt{narrowing\ type\ conversion} converts a larger to a smaller
type (for example \texttt{int32\ -\textgreater{}\ int16}. A
\texttt{widening\ type\ conversion} converts a smaller type to a larger
type (for example \texttt{int16\ -\textgreater{}\ int32}). In Nim only
widening type conversions are \emph{implicit}:

\begin{verbatim}
\end{verbatim}

However, \texttt{int} literals are implicitly convertible to a smaller
integer type if the literal's value fits this smaller type and such a
conversion is less expensive than other implicit conversions, so
\texttt{myInt16\ +\ 34} produces an \texttt{int16} result.

For further details, see
\protect\hyperlink{type-relations-convertible-relation}{Convertible
relation}.

\hypertarget{subrange-types}{%
\subsubsection{Subrange types}\label{subrange-types}}

A subrange type is a range of values from an ordinal or floating point
type (the base type). To define a subrange type, one must specify its
limiting values -\/- the lowest and highest value of the type. For
example:

\begin{verbatim}
\end{verbatim}

\texttt{Subrange} is a subrange of an integer which can only hold the
values 0 to 5. \texttt{PositiveFloat} defines a subrange of all positive
floating point values. NaN does not belong to any subrange of floating
point types. Assigning any other value to a variable of type
\texttt{Subrange} is a panic (or a static error if it can be determined
during semantic analysis). Assignments from the base type to one of its
subrange types (and vice versa) are allowed.

A subrange type has the same size as its base type (\texttt{int} in the
Subrange example).

\hypertarget{pre-defined-floating-point-types}{%
\subsubsection{Pre-defined floating point
types}\label{pre-defined-floating-point-types}}

The following floating point types are pre-defined:

\begin{description}
\item[\texttt{float}]
the generic floating point type; its size used to be platform dependent,
but now it is always mapped to \texttt{float64}. This type should be
used in general.
\item[floatXX]
an implementation may define additional floating point types of XX bits
using this naming scheme (example: float64 is a 64 bit wide float). The
current implementation supports \texttt{float32} and \texttt{float64}.
Literals of these types have the suffix 'fXX.
\end{description}

Automatic type conversion in expressions with different kinds of
floating point types is performed: See
\protect\hyperlink{convertible-relation}{Convertible relation} for
further details. Arithmetic performed on floating point types follows
the IEEE standard. Integer types are not converted to floating point
types automatically and vice versa.

The IEEE standard defines five types of floating-point exceptions:

\begin{itemize}
\tightlist
\item
  Invalid: operations with mathematically invalid operands, for example
  0.0/0.0, sqrt(-1.0), and log(-37.8).
\item
  Division by zero: divisor is zero and dividend is a finite nonzero
  number, for example 1.0/0.0.
\item
  Overflow: operation produces a result that exceeds the range of the
  exponent, for example MAXDOUBLE+0.0000000000001e308.
\item
  Underflow: operation produces a result that is too small to be
  represented as a normal number, for example, MINDOUBLE * MINDOUBLE.
\item
  Inexact: operation produces a result that cannot be represented with
  infinite precision, for example, 2.0 / 3.0, log(1.1) and 0.1 in input.
\end{itemize}

The IEEE exceptions are either ignored during execution or mapped to the
Nim exceptions: \texttt{FloatInvalidOpDefect},
\texttt{FloatDivByZeroDefect}, \texttt{FloatOverflowDefect},
\texttt{FloatUnderflowDefect}, and \texttt{FloatInexactDefect}. These
exceptions inherit from the \texttt{FloatingPointDefect} base class.

Nim provides the pragmas \texttt{nanChecks} and \texttt{infChecks} to
control whether the IEEE exceptions are ignored or trap a Nim exception:

\begin{verbatim}
\end{verbatim}

In the current implementation \texttt{FloatDivByZeroDefect} and
\texttt{FloatInexactDefect} are never raised.
\texttt{FloatOverflowDefect} is raised instead of
\texttt{FloatDivByZeroDefect}. There is also a \texttt{floatChecks}
pragma that is a short-cut for the combination of \texttt{nanChecks} and
\texttt{infChecks} pragmas. \texttt{floatChecks} are turned off as
default.

The only operations that are affected by the \texttt{floatChecks} pragma
are the \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/} operators for
floating point types.

An implementation should always use the maximum precision available to
evaluate floating pointer values during semantic analysis; this means
expressions like
\texttt{0.09\textquotesingle{}f32\ +\ 0.01\textquotesingle{}f32\ ==\ 0.09\textquotesingle{}f64\ +\ 0.01\textquotesingle{}f64}
that are evaluating during constant folding are true.

\hypertarget{boolean-type}{%
\subsubsection{Boolean type}\label{boolean-type}}

The boolean type is named \texttt{bool} in Nim and can be one of the two
pre-defined values \texttt{true} and \texttt{false}. Conditions in
\texttt{while}, \texttt{if}, \texttt{elif}, \texttt{when}-statements
need to be of type \texttt{bool}.

This condition holds:

\begin{verbatim}
ord(false) == 0 and ord(true) == 1
\end{verbatim}

The operators
\texttt{not,\ and,\ or,\ xor,\ \textless{},\ \textless{}=,\ \textgreater{},\ \textgreater{}=,\ !=,\ ==}
are defined for the bool type. The \texttt{and} and \texttt{or}
operators perform short-cut evaluation. Example:

\begin{verbatim}
while p != nil and p.name != "xyz":
  # p.name is not evaluated if p == nil
  p = p.next
\end{verbatim}

The size of the bool type is one byte.

\hypertarget{character-type}{%
\subsubsection{Character type}\label{character-type}}

The character type is named \texttt{char} in Nim. Its size is one byte.
Thus it cannot represent an UTF-8 character, but a part of it. The
reason for this is efficiency: for the overwhelming majority of
use-cases, the resulting programs will still handle UTF-8 properly as
UTF-8 was specially designed for this. Another reason is that Nim can
support \texttt{array{[}char,\ int{]}} or \texttt{set{[}char{]}}
efficiently as many algorithms rely on this feature. The {Rune} type is
used for Unicode characters, it can represent any Unicode character.
\texttt{Rune} is declared in the \href{unicode.html}{unicode module}.

\hypertarget{enumeration-types}{%
\subsubsection{Enumeration types}\label{enumeration-types}}

Enumeration types define a new type whose values consist of the ones
specified. The values are ordered. Example:

\begin{verbatim}
type
  Direction = enum
    north, east, south, west
\end{verbatim}

Now the following holds:

\begin{verbatim}
ord(north) == 0
ord(east) == 1
ord(south) == 2
ord(west) == 3

# Also allowed:
ord(Direction.west) == 3
\end{verbatim}

Thus, north \textless{} east \textless{} south \textless{} west. The
comparison operators can be used with enumeration types. Instead of
\texttt{north} etc, the enum value can also be qualified with the enum
type that it resides in, \texttt{Direction.north}.

For better interfacing to other programming languages, the fields of
enum types can be assigned an explicit ordinal value. However, the
ordinal values have to be in ascending order. A field whose ordinal
value is not explicitly given is assigned the value of the previous
field + 1.

An explicit ordered enum can have \emph{holes}:

\begin{verbatim}
\end{verbatim}

However, it is then not an ordinal anymore, so it is not possible to use
these enums as an index type for arrays. The procedures \texttt{inc},
\texttt{dec}, \texttt{succ} and \texttt{pred} are not available for them
either.

The compiler supports the built-in stringify operator \texttt{\$} for
enumerations. The stringify's result can be controlled by explicitly
giving the string values to use:

\begin{verbatim}
type
  MyEnum = enum
    valueA = (0, "my value A"),
    valueB = "value B",
    valueC = 2,
    valueD = (3, "abc")
\end{verbatim}

As can be seen from the example, it is possible to both specify a
field's ordinal value and its string value by using a tuple. It is also
possible to only specify one of them.

An enum can be marked with the \texttt{pure} pragma so that it's fields
are added to a special module specific hidden scope that is only queried
as the last attempt. Only non-ambiguous symbols are added to this scope.
But one can always access these via type qualification written as
\texttt{MyEnum.value}:

\begin{verbatim}
type
  MyEnum {.pure.} = enum
    valueA, valueB, valueC, valueD, amb

  OtherEnum {.pure.} = enum
    valueX, valueY, valueZ, amb


echo valueA # MyEnum.valueA
echo amb    # Error: Unclear whether it's MyEnum.amb or OtherEnum.amb
echo MyEnum.amb # OK.
\end{verbatim}

To implement bit fields with enums see
\protect\hyperlink{set-type-bit-fields}{Bit fields}

\hypertarget{string-type}{%
\subsubsection{String type}\label{string-type}}

All string literals are of the type \texttt{string}. A string in Nim is
very similar to a sequence of characters. However, strings in Nim are
both zero-terminated and have a length field. One can retrieve the
length with the builtin \texttt{len} procedure; the length never counts
the terminating zero.

The terminating zero cannot be accessed unless the string is converted
to the \texttt{cstring} type first. The terminating zero assures that
this conversion can be done in O(1) and without any allocations.

The assignment operator for strings always copies the string. The
\texttt{\&} operator concatenates strings.

Most native Nim types support conversion to strings with the special
\texttt{\$} proc. When calling the \texttt{echo} proc, for example, the
built-in stringify operation for the parameter is called:

\begin{verbatim}
echo 3 # calls `$` for `int`
\end{verbatim}

Whenever a user creates a specialized object, implementation of this
procedure provides for \texttt{string} representation.

\begin{verbatim}
proc `$`(p: Person): string = # `$` always returns a string
  result = p.name & " is " &
          $p.age & # we *need* the `$` in front of p.age which
                   # is natively an integer to convert it to
                   # a string
          " years old."
\end{verbatim}

While \texttt{\$p.name} can also be used, the \texttt{\$} operation on a
string does nothing. Note that we cannot rely on automatic conversion
from an \texttt{int} to a \texttt{string} like we can for the
\texttt{echo} proc.

Strings are compared by their lexicographical order. All comparison
operators are available. Strings can be indexed like arrays (lower bound
is 0). Unlike arrays, they can be used in case statements:

\begin{verbatim}
case paramStr(i)
of "-v": incl(options, optVerbose)
of "-h", "-?": incl(options, optHelp)
else: write(stdout, "invalid command line option!\n")
\end{verbatim}

Per convention, all strings are UTF-8 strings, but this is not enforced.
For example, when reading strings from binary files, they are merely a
sequence of bytes. The index operation \texttt{s{[}i{]}} means the i-th
\emph{char} of \texttt{s}, not the i-th \emph{unichar}. The iterator
\texttt{runes} from the \href{unicode.html}{unicode module} can be used
for iteration over all Unicode characters.

\hypertarget{cstring-type}{%
\subsubsection{cstring type}\label{cstring-type}}

The \texttt{cstring} type meaning {compatible string} is the native
representation of a string for the compilation backend. For the C
backend the \texttt{cstring} type represents a pointer to a
zero-terminated char array compatible to the type \texttt{char*} in Ansi
C. Its primary purpose lies in easy interfacing with C. The index
operation \texttt{s{[}i{]}} means the i-th \emph{char} of \texttt{s};
however no bounds checking for \texttt{cstring} is performed making the
index operation unsafe.

A Nim \texttt{string} is implicitly convertible to \texttt{cstring} for
convenience. If a Nim string is passed to a C-style variadic proc, it is
implicitly converted to \texttt{cstring} too:

\begin{verbatim}
printf("This works %s", "as expected")
\end{verbatim}

Even though the conversion is implicit, it is not \emph{safe}: The
garbage collector does not consider a \texttt{cstring} to be a root and
may collect the underlying memory. However in practice this almost never
happens as the GC considers stack roots conservatively. One can use the
builtin procs \texttt{GC\_ref} and \texttt{GC\_unref} to keep the string
data alive for the rare cases where it does not work.

A {\$} proc is defined for cstrings that returns a string. Thus to get a
nim string from a cstring:

\begin{verbatim}
\end{verbatim}

\hypertarget{structured-types}{%
\subsubsection{Structured types}\label{structured-types}}

A variable of a structured type can hold multiple values at the same
time. Structured types can be nested to unlimited levels. Arrays,
sequences, tuples, objects and sets belong to the structured types.

\hypertarget{array-and-sequence-types}{%
\subsubsection{Array and sequence
types}\label{array-and-sequence-types}}

Arrays are a homogeneous type, meaning that each element in the array
has the same type. Arrays always have a fixed length specified as a
constant expression (except for open arrays). They can be indexed by any
ordinal type. A parameter \texttt{A} may be an \emph{open array}, in
which case it is indexed by integers from 0 to \texttt{len(A)-1}. An
array expression may be constructed by the array constructor
\texttt{{[}{]}}. The element type of this array expression is inferred
from the type of the first element. All other elements need to be
implicitly convertible to this type.

An array type can be defined using the {array{[}size, T{]}} syntax, or
using {array{[}lo..hi, T{]}} for arrays that start at an index other
than zero.

Sequences are similar to arrays but of dynamic length which may change
during runtime (like strings). Sequences are implemented as growable
arrays, allocating pieces of memory as items are added. A sequence
\texttt{S} is always indexed by integers from 0 to \texttt{len(S)-1} and
its bounds are checked. Sequences can be constructed by the array
constructor \texttt{{[}{]}} in conjunction with the array to sequence
operator \texttt{@}. Another way to allocate space for a sequence is to
call the built-in \texttt{newSeq} procedure.

A sequence may be passed to a parameter that is of type \emph{open
array}.

Example:

\begin{verbatim}
type
  IntArray = array[0..5, int] # an array that is indexed with 0..5
  IntSeq = seq[int] # a sequence of integers
var
  x: IntArray
  y: IntSeq
x = [1, 2, 3, 4, 5, 6]  # [] is the array constructor
y = @[1, 2, 3, 4, 5, 6] # the @ turns the array into a sequence

let z = [1.0, 2, 3, 4] # the type of z is array[0..3, float]
\end{verbatim}

The lower bound of an array or sequence may be received by the built-in
proc \texttt{low()}, the higher bound by \texttt{high()}. The length may
be received by \texttt{len()}. \texttt{low()} for a sequence or an open
array always returns 0, as this is the first valid index. One can append
elements to a sequence with the \texttt{add()} proc or the \texttt{\&}
operator, and remove (and get) the last element of a sequence with the
\texttt{pop()} proc.

The notation \texttt{x{[}i{]}} can be used to access the i-th element of
\texttt{x}.

Arrays are always bounds checked (statically or at runtime). These
checks can be disabled via pragmas or invoking the compiler with the
\texttt{-\/-boundChecks:off} command line switch.

An array constructor can have explicit indexes for readability:

\begin{verbatim}
type
  Values = enum
    valA, valB, valC

const
  lookupTable = [
    valA: "A",
    valB: "B",
    valC: "C"
  ]
\end{verbatim}

If an index is left out, \texttt{succ(lastIndex)} is used as the index
value:

\begin{verbatim}
type
  Values = enum
    valA, valB, valC, valD, valE

const
  lookupTable = [
    valA: "A",
    "B",
    valC: "C",
    "D", "e"
  ]
\end{verbatim}

\hypertarget{open-arrays}{%
\subsubsection{Open arrays}\label{open-arrays}}

Often fixed size arrays turn out to be too inflexible; procedures should
be able to deal with arrays of different sizes. The \texttt{openarray}
type allows this; it can only be used for parameters. Openarrays are
always indexed with an \texttt{int} starting at position 0. The
\texttt{len}, \texttt{low} and \texttt{high} operations are available
for open arrays too. Any array with a compatible base type can be passed
to an openarray parameter, the index type does not matter. In addition
to arrays sequences can also be passed to an open array parameter.

The openarray type cannot be nested: multidimensional openarrays are not
supported because this is seldom needed and cannot be done efficiently.

\begin{verbatim}
testOpenArray([1,2,3])  # array[]
testOpenArray(@[1,2,3]) # seq[]
\end{verbatim}

\hypertarget{varargs}{%
\subsubsection{Varargs}\label{varargs}}

A \texttt{varargs} parameter is an openarray parameter that additionally
allows to pass a variable number of arguments to a procedure. The
compiler converts the list of arguments to an array implicitly:

\begin{verbatim}
myWriteln(stdout, "abc", "def", "xyz")
# is transformed to:
myWriteln(stdout, ["abc", "def", "xyz"])
\end{verbatim}

This transformation is only done if the varargs parameter is the last
parameter in the procedure header. It is also possible to perform type
conversions in this context:

\begin{verbatim}
myWriteln(stdout, 123, "abc", 4.0)
# is transformed to:
myWriteln(stdout, [$123, $"def", $4.0])
\end{verbatim}

In this example \texttt{\$} is applied to any argument that is passed to
the parameter \texttt{a}. (Note that \texttt{\$} applied to strings is a
nop.)

Note that an explicit array constructor passed to a \texttt{varargs}
parameter is not wrapped in another implicit array construction:

\begin{verbatim}
takeV([123, 2, 1]) # takeV's T is "int", not "array of int"
\end{verbatim}

\texttt{varargs{[}typed{]}} is treated specially: It matches a variable
list of arguments of arbitrary type but \emph{always} constructs an
implicit array. This is required so that the builtin \texttt{echo} proc
does what is expected:

\begin{verbatim}
echo @[1, 2, 3]
# prints "@[1, 2, 3]" and not "123"
\end{verbatim}

\hypertarget{unchecked-arrays}{%
\subsubsection{Unchecked arrays}\label{unchecked-arrays}}

The \texttt{UncheckedArray{[}T{]}} type is a special kind of
\texttt{array} where its bounds are not checked. This is often useful to
implement customized flexibly sized arrays. Additionally an unchecked
array is translated into a C array of undetermined size:

\begin{verbatim}
\end{verbatim}

Produces roughly this C code:

\begin{verbatim}
\end{verbatim}

The base type of the unchecked array may not contain any GC'ed memory
but this is currently not checked.

\textbf{Future directions}: GC'ed memory should be allowed in unchecked
arrays and there should be an explicit annotation of how the GC is to
determine the runtime size of the array.

\hypertarget{tuples-and-object-types}{%
\subsubsection{Tuples and object types}\label{tuples-and-object-types}}

A variable of a tuple or object type is a heterogeneous storage
container. A tuple or object defines various named \emph{fields} of a
type. A tuple also defines a lexicographic \emph{order} of the fields.
Tuples are meant to be heterogeneous storage types with few
abstractions. The \texttt{()} syntax can be used to construct tuples.
The order of the fields in the constructor must match the order of the
tuple's definition. Different tuple-types are \emph{equivalent} if they
specify the same fields of the same type in the same order. The
\emph{names} of the fields also have to be identical.

The assignment operator for tuples copies each component. The default
assignment operator for objects copies each component. Overloading of
the assignment operator is described
\href{manual_experimental.html\#type-bound-operations}{here}.

\begin{verbatim}
type
  Person = tuple[name: string, age: int] # type representing a person:
                                         # a person consists of a name
                                         # and an age
var
  person: Person
person = (name: "Peter", age: 30)
echo person.name
# the same, but less readable:
person = ("Peter", 30)
echo person[0]
\end{verbatim}

A tuple with one unnamed field can be constructed with the parentheses
and a trailing comma:

\begin{verbatim}
echoUnaryTuple (1,)
\end{verbatim}

In fact, a trailing comma is allowed for every tuple construction.

The implementation aligns the fields for best access performance. The
alignment is compatible with the way the C compiler does it.

For consistency with \texttt{object} declarations, tuples in a
\texttt{type} section can also be defined with indentation instead of
\texttt{{[}{]}}:

\begin{verbatim}
\end{verbatim}

Objects provide many features that tuples do not. Object provide
inheritance and the ability to hide fields from other modules. Objects
with inheritance enabled have information about their type at runtime,
so that the \texttt{of} operator can be used to determine the object's
type. The \texttt{of} operator is similar to the \texttt{instanceof}
operator in Java.

\begin{verbatim}
Student = ref object of Person # a student is a person
  id: int                      # with an id field

var
student: Student
person: Person
assert(student of Student) # is true
assert(student of Person) # also true
\end{verbatim}

Object fields that should be visible from outside the defining module,
have to be marked by \texttt{*}. In contrast to tuples, different object
types are never \emph{equivalent}, they are nominal types whereas tuples
are structural. Objects that have no ancestor are implicitly
\texttt{final} and thus have no hidden type information. One can use the
\texttt{inheritable} pragma to introduce new object roots apart from
\texttt{system.RootObj}.

\begin{verbatim}
Student = ref object of Person # Error: inheritance only works with non-final objects
  id: int
\end{verbatim}

\hypertarget{object-construction}{%
\subsubsection{Object construction}\label{object-construction}}

Objects can also be created with an
\texttt{object\ construction\ expression} that has the syntax
\texttt{T(fieldA:\ valueA,\ fieldB:\ valueB,\ ...)} where \texttt{T} is
an \texttt{object} type or a \texttt{ref\ object} type:

\begin{verbatim}
\end{verbatim}

Note that, unlike tuples, objects require the field names along with
their values. For a \texttt{ref\ object} type \texttt{system.new} is
invoked implicitly.

\hypertarget{object-variants}{%
\subsubsection{Object variants}\label{object-variants}}

Often an object hierarchy is overkill in certain situations where simple
variant types are needed. Object variants are tagged unions
discriminated via a enumerated type used for runtime type flexibility,
mirroring the concepts of \emph{sum types} and \emph{algebraic data
types (ADTs)} as found in other languages.

An example:

\begin{verbatim}
# This is an example how an abstract syntax tree could be modelled in Nim
type
  NodeKind = enum  # the different node types
    nkInt,          # a leaf with an integer value
    nkFloat,        # a leaf with a float value
    nkString,       # a leaf with a string value
    nkAdd,          # an addition
    nkSub,          # a subtraction
    nkIf            # an if statement
  Node = ref NodeObj
  NodeObj = object
    case kind: NodeKind  # the ``kind`` field is the discriminator
    of nkInt: intVal: int
    of nkFloat: floatVal: float
    of nkString: strVal: string
    of nkAdd, nkSub:
      leftOp, rightOp: Node
    of nkIf:
      condition, thenPart, elsePart: Node

# create a new case object:
var n = Node(kind: nkIf, condition: nil)
# accessing n.thenPart is valid because the ``nkIf`` branch is active:
n.thenPart = Node(kind: nkFloat, floatVal: 2.0)

# the following statement raises an `FieldDefect` exception, because
# n.kind's value does not fit and the ``nkString`` branch is not active:
n.strVal = ""

# invalid: would change the active object branch:
n.kind = nkInt

var x = Node(kind: nkAdd, leftOp: Node(kind: nkInt, intVal: 4),
                          rightOp: Node(kind: nkInt, intVal: 2))
# valid: does not change the active object branch:
x.kind = nkSub
\end{verbatim}

As can been seen from the example, an advantage to an object hierarchy
is that no casting between different object types is needed. Yet, access
to invalid object fields raises an exception.

The syntax of \texttt{case} in an object declaration follows closely the
syntax of the \texttt{case} statement: The branches in a \texttt{case}
section may be indented too.

In the example the \texttt{kind} field is called the
\texttt{discriminator}: For safety its address cannot be taken and
assignments to it are restricted: The new value must not lead to a
change of the active object branch. Also, when the fields of a
particular branch are specified during object construction, the
corresponding discriminator value must be specified as a constant
expression.

Instead of changing the active object branch, replace the old object in
memory with a new one completely:

\begin{verbatim}
var x = Node(kind: nkAdd, leftOp: Node(kind: nkInt, intVal: 4),
                          rightOp: Node(kind: nkInt, intVal: 2))
# change the node's contents:
x[] = NodeObj(kind: nkString, strVal: "abc")
\end{verbatim}

Starting with version 0.20 \texttt{system.reset} cannot be used anymore
to support object branch changes as this never was completely memory
safe.

As a special rule, the discriminator kind can also be bounded using a
\texttt{case} statement. If possible values of the discriminator
variable in a \texttt{case} statement branch are a subset of
discriminator values for the selected object branch, the initialization
is considered valid. This analysis only works for immutable
discriminators of an ordinal type and disregards \texttt{elif} branches.
For discriminator values with a \texttt{range} type, the compiler checks
if the entire range of possible values for the discriminator value is
valid for the chosen object branch.

A small example:

\begin{verbatim}
let unknownKind = nkSub

# invalid: unsafe initialization because the kind field is not statically known:
var y = Node(kind: unknownKind, strVal: "y")

var z = Node()
case unknownKind
of nkAdd, nkSub:
  # valid: possible values of this branch are a subset of nkAdd/nkSub object branch:
  z = Node(kind: unknownKind, leftOp: Node(), rightOp: Node())
else:
  echo "ignoring: ", unknownKind

# also valid, since unknownKindBounded can only contain the values nkAdd or nkSub
let unknownKindBounded = range[nkAdd..nkSub](unknownKind)
z = Node(kind: unknownKindBounded, leftOp: Node(), rightOp: Node())
\end{verbatim}

\hypertarget{set-type}{%
\subsubsection{Set type}\label{set-type}}

The set type models the mathematical notion of a set. The set's basetype
can only be an ordinal type of a certain size, namely:

\begin{itemize}
\tightlist
\item
  \texttt{int8}-\texttt{int16}
\item
  \texttt{uint8}/\texttt{byte}-\texttt{uint16}
\item
  \texttt{char}
\item
  \texttt{enum}
\end{itemize}

or equivalent. For signed integers the set's base type is defined to be
in the range \texttt{0\ ..\ MaxSetElements-1} where
\texttt{MaxSetElements} is currently always 2\^{}16.

The reason is that sets are implemented as high performance bit vectors.
Attempting to declare a set with a larger type will result in an error:

\begin{verbatim}
var s: set[int64] # Error: set is too large
\end{verbatim}

Sets can be constructed via the set constructor: \texttt{\{\}} is the
empty set. The empty set is type compatible with any concrete set type.
The constructor can also be used to include elements (and ranges of
elements):

\begin{verbatim}
\end{verbatim}

These operations are supported by sets:

\begin{longtable}[]{@{}ll@{}}
\toprule
operation & meaning\tabularnewline
\midrule
\endhead
\texttt{A\ +\ B} & union of two sets\tabularnewline
\texttt{A\ *\ B} & intersection of two sets\tabularnewline
\texttt{A\ -\ B} & difference of two sets (A without B's
elements)\tabularnewline
\texttt{A\ ==\ B} & set equality\tabularnewline
\texttt{A\ \textless{}=\ B} & subset relation (A is subset of B or equal
to B)\tabularnewline
\texttt{A\ \textless{}\ B} & strict subset relation (A is a proper
subset of B)\tabularnewline
\texttt{e\ in\ A} & set membership (A contains element e)\tabularnewline
\texttt{e\ notin\ A} & A does not contain element e\tabularnewline
\texttt{contains(A,\ e)} & A contains element e\tabularnewline
\texttt{card(A)} & the cardinality of A (number of elements in
A)\tabularnewline
\texttt{incl(A,\ elem)} & same as
\texttt{A\ =\ A\ +\ \{elem\}}\tabularnewline
\texttt{excl(A,\ elem)} & same as
\texttt{A\ =\ A\ -\ \{elem\}}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{bit-fields}{%
\paragraph{Bit fields}\label{bit-fields}}

Sets are often used to define a type for the \emph{flags} of a
procedure. This is a cleaner (and type safe) solution than defining
integer constants that have to be \texttt{or}'ed together.

Enum, sets and casting can be used together as in:

\begin{verbatim}
type
  MyFlag* {.size: sizeof(cint).} = enum
    A
    B
    C
    D
  MyFlags = set[MyFlag]

proc toNum(f: MyFlags): int = cast[cint](f)
proc toFlags(v: int): MyFlags = cast[MyFlags](v)

assert toNum({}) == 0
assert toNum({A}) == 1
assert toNum({D}) == 8
assert toNum({A, C}) == 5
assert toFlags(0) == {}
assert toFlags(7) == {A, B, C}
\end{verbatim}

Note how the set turns enum values into powers of 2.

If using enums and sets with C, use distinct cint.

For interoperability with C see also the
\href{manual.html\#implementation-specific-pragmas-bitsize-pragma}{bitsize
pragma}.

\hypertarget{reference-and-pointer-types}{%
\subsubsection{Reference and pointer
types}\label{reference-and-pointer-types}}

References (similar to pointers in other programming languages) are a
way to introduce many-to-one relationships. This means different
references can point to and modify the same location in memory (also
called \texttt{aliasing}).

Nim distinguishes between \texttt{traced} and \texttt{untraced}
references. Untraced references are also called \emph{pointers}. Traced
references point to objects of a garbage collected heap, untraced
references point to manually allocated objects or to objects somewhere
else in memory. Thus untraced references are \emph{unsafe}. However for
certain low-level operations (accessing the hardware) untraced
references are unavoidable.

Traced references are declared with the \textbf{ref} keyword, untraced
references are declared with the \textbf{ptr} keyword. In general, a
{ptr T} is implicitly convertible to the {pointer} type.

An empty subscript \texttt{{[}{]}} notation can be used to derefer a
reference, the \texttt{addr} procedure returns the address of an item.
An address is always an untraced reference. Thus the usage of
\texttt{addr} is an \emph{unsafe} feature.

The \texttt{.} (access a tuple/object field operator) and
\texttt{{[}{]}} (array/string/sequence index operator) operators perform
implicit dereferencing operations for reference types:

\begin{verbatim}
type
  Node = ref NodeObj
  NodeObj = object
    le, ri: Node
    data: int

var
  n: Node
new(n)
n.data = 9
# no need to write n[].data; in fact n[].data is highly discouraged!
\end{verbatim}

Automatic dereferencing can be performed for the first argument of a
routine call, but this is an experimental feature and is described
\href{manual_experimental.html\#type-bound-operations}{here}.

In order to simplify structural type checking, recursive tuples are not
valid:

\begin{verbatim}
\end{verbatim}

Likewise \texttt{T\ =\ ref\ T} is an invalid type.

As a syntactical extension \texttt{object} types can be anonymous if
declared in a type section via the \texttt{ref\ object} or
\texttt{ptr\ object} notations. This feature is useful if an object
should only gain reference semantics:

\begin{verbatim}
type
  Node = ref object
    le, ri: Node
    data: int
\end{verbatim}

To allocate a new traced object, the built-in procedure \texttt{new} has
to be used. To deal with untraced memory, the procedures \texttt{alloc},
\texttt{dealloc} and \texttt{realloc} can be used. The documentation of
the system module contains further information.

\hypertarget{nil}{%
\subsubsection{Nil}\label{nil}}

If a reference points to \emph{nothing}, it has the value \texttt{nil}.
\texttt{nil} is the default value for all \texttt{ref} and \texttt{ptr}
types. The \texttt{nil} value can also be used like any other literal
value. For example, it can be used in an assignment like
\texttt{myRef\ =\ nil}.

Dereferencing \texttt{nil} is an unrecoverable fatal runtime error (and
not a panic).

A successful dereferencing operation \texttt{p{[}{]}} implies that
\texttt{p} is not nil. This can be exploited by the implementation to
optimize code like:

\begin{verbatim}
p[].field = 3
if p != nil:
  # if p were nil, ``p[]`` would have caused a crash already,
  # so we know ``p`` is always not nil here.
  action()
\end{verbatim}

Into:

\begin{verbatim}
p[].field = 3
action()
\end{verbatim}

\emph{Note}: This is not comparable to C's "undefined behavior" for
dereferencing NULL pointers.

\hypertarget{mixing-gced-memory-with-ptr}{%
\subsubsection{\texorpdfstring{Mixing GC'ed memory with
\texttt{ptr}}{Mixing GC'ed memory with ptr}}\label{mixing-gced-memory-with-ptr}}

Special care has to be taken if an untraced object contains traced
objects like traced references, strings or sequences: in order to free
everything properly, the built-in procedure \texttt{reset} has to be
called before freeing the untraced memory manually:

\begin{verbatim}
# allocate memory for Data on the heap:
var d = cast[ptr Data](alloc0(sizeof(Data)))

# create a new string on the garbage collected heap:
d.s = "abc"

# tell the GC that the string is not needed anymore:
reset(d.s)

# free the memory:
dealloc(d)
\end{verbatim}

Without the \texttt{reset} call the memory allocated for the
\texttt{d.s} string would never be freed. The example also demonstrates
two important features for low level programming: the \texttt{sizeof}
proc returns the size of a type or value in bytes. The \texttt{cast}
operator can circumvent the type system: the compiler is forced to treat
the result of the \texttt{alloc0} call (which returns an untyped
pointer) as if it would have the type \texttt{ptr\ Data}. Casting should
only be done if it is unavoidable: it breaks type safety and bugs can
lead to mysterious crashes.

\textbf{Note}: The example only works because the memory is initialized
to zero (\texttt{alloc0} instead of \texttt{alloc} does this):
\texttt{d.s} is thus initialized to binary zero which the string
assignment can handle. One needs to know low level details like this
when mixing garbage collected data with unmanaged memory.

\hypertarget{procedural-type}{%
\subsubsection{Procedural type}\label{procedural-type}}

A procedural type is internally a pointer to a procedure. \texttt{nil}
is an allowed value for variables of a procedural type. Nim uses
procedural types to achieve \texttt{functional} programming techniques.

Examples:

\begin{verbatim}
proc printItem(x: int) = ...

proc forEach(c: proc (x: int) {.cdecl.}) =
  ...

forEach(printItem)  # this will NOT compile because calling conventions differ
\end{verbatim}

\begin{verbatim}
type
  OnMouseMove = proc (x, y: int) {.closure.}

proc onMouseMove(mouseX, mouseY: int) =
  # has default calling convention
  echo "x: ", mouseX, " y: ", mouseY

proc setOnMouseMove(mouseMoveEvent: OnMouseMove) = discard

# ok, 'onMouseMove' has the default calling convention, which is compatible
# to 'closure':
setOnMouseMove(onMouseMove)
\end{verbatim}

A subtle issue with procedural types is that the calling convention of
the procedure influences the type compatibility: procedural types are
only compatible if they have the same calling convention. As a special
extension, a procedure of the calling convention \texttt{nimcall} can be
passed to a parameter that expects a proc of the calling convention
\texttt{closure}.

Nim supports these \texttt{calling\ conventions}:

\begin{description}
\item[\texttt{nimcall}]
is the default convention used for a Nim \textbf{proc}. It is the same
as \texttt{fastcall}, but only for C compilers that support
\texttt{fastcall}.
\item[\texttt{closure}]
is the default calling convention for a \textbf{procedural type} that
lacks any pragma annotations. It indicates that the procedure has a
hidden implicit parameter (an \emph{environment}). Proc vars that have
the calling convention \texttt{closure} take up two machine words: One
for the proc pointer and another one for the pointer to implicitly
passed environment.
\item[\texttt{stdcall}]
This is the stdcall convention as specified by Microsoft. The generated
C procedure is declared with the \texttt{\_\_stdcall} keyword.
\item[\texttt{cdecl}]
The cdecl convention means that a procedure shall use the same
convention as the C compiler. Under Windows the generated C procedure is
declared with the \texttt{\_\_cdecl} keyword.
\item[\texttt{safecall}]
This is the safecall convention as specified by Microsoft. The generated
C procedure is declared with the \texttt{\_\_safecall} keyword. The word
\emph{safe} refers to the fact that all hardware registers shall be
pushed to the hardware stack.
\item[\texttt{inline}]
The inline convention means the the caller should not call the
procedure, but inline its code directly. Note that Nim does not inline,
but leaves this to the C compiler; it generates \texttt{\_\_inline}
procedures. This is only a hint for the compiler: it may completely
ignore it and it may inline procedures that are not marked as
\texttt{inline}.
\item[\texttt{fastcall}]
Fastcall means different things to different C compilers. One gets
whatever the C \texttt{\_\_fastcall} means.
\item[\texttt{thiscall}]
This is thiscall calling convention as specified by Microsoft, used on
C++ class member functions on the x86 architecture
\item[\texttt{syscall}]
The syscall convention is the same as \texttt{\_\_syscall} in C. It is
used for interrupts.
\item[\texttt{noconv}]
The generated C code will not have any explicit calling convention and
thus use the C compiler's default calling convention. This is needed
because Nim's default calling convention for procedures is
\texttt{fastcall} to improve speed.
\end{description}

Most calling conventions exist only for the Windows 32-bit platform.

The default calling convention is \texttt{nimcall}, unless it is an
inner proc (a proc inside of a proc). For an inner proc an analysis is
performed whether it accesses its environment. If it does so, it has the
calling convention \texttt{closure}, otherwise it has the calling
convention \texttt{nimcall}.

\hypertarget{distinct-type}{%
\subsubsection{Distinct type}\label{distinct-type}}

A \texttt{distinct} type is new type derived from a \texttt{base\ type}
that is incompatible with its base type. In particular, it is an
essential property of a distinct type that it \textbf{does not} imply a
subtype relation between it and its base type. Explicit type conversions
from a distinct type to its base type and vice versa are allowed. See
also \texttt{distinctBase} to get the reverse operation.

A distinct type is an ordinal type if its base type is an ordinal type.

\hypertarget{modelling-currencies}{%
\paragraph{Modelling currencies}\label{modelling-currencies}}

A distinct type can be used to model different physical \texttt{units}
with a numerical base type, for example. The following example models
currencies.

Different currencies should not be mixed in monetary calculations.
Distinct types are a perfect tool to model different currencies:

\begin{verbatim}
var
  d: Dollar
  e: Euro

echo d + 12
# Error: cannot add a number with no unit and a ``Dollar``
\end{verbatim}

Unfortunately, \texttt{d\ +\ 12.Dollar} is not allowed either, because
\texttt{+} is defined for \texttt{int} (among others), not for
\texttt{Dollar}. So a \texttt{+} for dollars needs to be defined:

\begin{verbatim}
\end{verbatim}

It does not make sense to multiply a dollar with a dollar, but with a
number without unit; and the same holds for division:

\begin{verbatim}
proc `*` (x: int, y: Dollar): Dollar =
  result = Dollar(x * int(y))

proc `div` ...
\end{verbatim}

This quickly gets tedious. The implementations are trivial and the
compiler should not generate all this code only to optimize it away
later - after all \texttt{+} for dollars should produce the same binary
code as \texttt{+} for ints. The pragma \texttt{borrow} has been
designed to solve this problem; in principle it generates the above
trivial implementations:

\begin{verbatim}
\end{verbatim}

The \texttt{borrow} pragma makes the compiler use the same
implementation as the proc that deals with the distinct type's base
type, so no code is generated.

But it seems all this boilerplate code needs to be repeated for the
\texttt{Euro} currency. This can be solved with
\protect\hyperlink{templates}{templates}.

\begin{verbatim}
template additive(typ: typedesc) =
  proc `+` *(x, y: typ): typ {.borrow.}
  proc `-` *(x, y: typ): typ {.borrow.}

  # unary operators:
  proc `+` *(x: typ): typ {.borrow.}
  proc `-` *(x: typ): typ {.borrow.}

template multiplicative(typ, base: typedesc) =
  proc `*` *(x: typ, y: base): typ {.borrow.}
  proc `*` *(x: base, y: typ): typ {.borrow.}
  proc `div` *(x: typ, y: base): typ {.borrow.}
  proc `mod` *(x: typ, y: base): typ {.borrow.}

template comparable(typ: typedesc) =
  proc `<` * (x, y: typ): bool {.borrow.}
  proc `<=` * (x, y: typ): bool {.borrow.}
  proc `==` * (x, y: typ): bool {.borrow.}

template defineCurrency(typ, base: untyped) =
  type
    typ* = distinct base
  additive(typ)
  multiplicative(typ, base)
  comparable(typ)

defineCurrency(Dollar, int)
defineCurrency(Euro, int)
\end{verbatim}

The borrow pragma can also be used to annotate the distinct type to
allow certain builtin operations to be lifted:

\begin{verbatim}
Bar {.borrow: `.`.} = distinct Foo

var bb: ref Bar
new bb
# field access now valid
bb.a = 90
bb.s = "abc"
\end{verbatim}

Currently only the dot accessor can be borrowed in this way.

\hypertarget{avoiding-sql-injection-attacks}{%
\paragraph{Avoiding SQL injection
attacks}\label{avoiding-sql-injection-attacks}}

An SQL statement that is passed from Nim to an SQL database might be
modelled as a string. However, using string templates and filling in the
values is vulnerable to the famous \texttt{SQL\ injection\ attack}:

\begin{verbatim}
proc query(db: DbHandle, statement: string) = ...

var
  username: string

db.query("SELECT FROM users WHERE name = '$1'" % username)
# Horrible security hole, but the compiler does not mind!
\end{verbatim}

This can be avoided by distinguishing strings that contain SQL from
strings that don't. Distinct types provide a means to introduce a new
string type \texttt{SQL} that is incompatible with \texttt{string}:

\begin{verbatim}
proc query(db: DbHandle, statement: SQL) = ...

var
  username: string

db.query("SELECT FROM users WHERE name = '$1'" % username)
# Static error: `query` expects an SQL string!
\end{verbatim}

It is an essential property of abstract types that they \textbf{do not}
imply a subtype relation between the abstract type and its base type.
Explicit type conversions from \texttt{string} to \texttt{SQL} are
allowed:

\begin{verbatim}
proc properQuote(s: string): SQL =
  # quotes a string properly for an SQL statement
  return SQL(s)

proc `%` (frmt: SQL, values: openarray[string]): SQL =
  # quote each argument:
  let v = values.mapIt(SQL, properQuote(it))
  # we need a temporary type for the type conversion :-(
  type StrSeq = seq[string]
  # call strutils.`%`:
  result = SQL(string(frmt) % StrSeq(v))

db.query("SELECT FROM users WHERE name = '$1'".SQL % [username])
\end{verbatim}

Now we have compile-time checking against SQL injection attacks. Since
\texttt{"".SQL} is transformed to \texttt{SQL("")} no new syntax is
needed for nice looking \texttt{SQL} string literals. The hypothetical
\texttt{SQL} type actually exists in the library as the
\href{db_common.html\#SqlQuery}{SqlQuery type} of modules like
\href{db_sqlite.html}{db\_sqlite}.

\hypertarget{auto-type}{%
\subsubsection{Auto type}\label{auto-type}}

The \texttt{auto} type can only be used for return types and parameters.
For return types it causes the compiler to infer the type from the
routine body:

\begin{verbatim}
\end{verbatim}

For parameters it currently creates implicitly generic routines:

\begin{verbatim}
\end{verbatim}

Is the same as:

\begin{verbatim}
\end{verbatim}

However later versions of the language might change this to mean "infer
the parameters' types from the body". Then the above \texttt{foo} would
be rejected as the parameters' types can not be inferred from an empty
\texttt{discard} statement.

\hypertarget{type-relations}{%
\subsection{Type relations}\label{type-relations}}

The following section defines several relations on types that are needed
to describe the type checking done by the compiler.

\hypertarget{type-equality}{%
\subsubsection{Type equality}\label{type-equality}}

Nim uses structural type equivalence for most types. Only for objects,
enumerations and distinct types name equivalence is used. The following
algorithm, \emph{in pseudo-code}, determines type equality:

\begin{verbatim}
proc typeEquals(a, b: PType): bool =
  var s: HashSet[(PType, PType)] = {}
  result = typeEqualsAux(a, b, s)
\end{verbatim}

Since types are graphs which can have cycles, the above algorithm needs
an auxiliary set \texttt{s} to detect this case.

\hypertarget{type-equality-modulo-type-distinction}{%
\subsubsection{Type equality modulo type
distinction}\label{type-equality-modulo-type-distinction}}

The following algorithm (in pseudo-code) determines whether two types
are equal with no respect to \texttt{distinct} types. For brevity the
cycle check with an auxiliary set \texttt{s} is omitted:

\begin{verbatim}
\end{verbatim}

\hypertarget{subtype-relation}{%
\subsubsection{Subtype relation}\label{subtype-relation}}

If object \texttt{a} inherits from \texttt{b}, \texttt{a} is a subtype
of \texttt{b}. This subtype relation is extended to the types
\texttt{var}, \texttt{ref}, \texttt{ptr}:

\begin{verbatim}
\end{verbatim}

\hypertarget{convertible-relation}{%
\subsubsection{Convertible relation}\label{convertible-relation}}

A type \texttt{a} is \textbf{implicitly} convertible to type \texttt{b}
iff the following algorithm returns true:

\begin{verbatim}
proc isImplicitlyConvertible(a, b: PType): bool =
  if isSubtype(a, b) or isCovariant(a, b):
    return true
  if isIntLiteral(a):
    return b in {int8, int16, int32, int64, int, uint, uint8, uint16,
                 uint32, uint64, float32, float64}
  case a.kind
  of int:     result = b in {int32, int64}
  of int8:    result = b in {int16, int32, int64, int}
  of int16:   result = b in {int32, int64, int}
  of int32:   result = b in {int64, int}
  of uint:    result = b in {uint32, uint64}
  of uint8:   result = b in {uint16, uint32, uint64}
  of uint16:  result = b in {uint32, uint64}
  of uint32:  result = b in {uint64}
  of float32: result = b in {float64}
  of float64: result = b in {float32}
  of seq:
    result = b == openArray and typeEquals(a.baseType, b.baseType)
  of array:
    result = b == openArray and typeEquals(a.baseType, b.baseType)
    if a.baseType == char and a.indexType.rangeA == 0:
      result = b == cstring
  of cstring, ptr:
    result = b == pointer
  of string:
    result = b == cstring
\end{verbatim}

Implicit conversions are also performed for Nim's \texttt{range} type
constructor.

Let \texttt{a0}, \texttt{b0} of type \texttt{T}.

Let \texttt{A\ =\ range{[}a0..b0{]}} be the argument's type, \texttt{F}
the formal parameter's type. Then an implicit conversion from \texttt{A}
to \texttt{F} exists if
\texttt{a0\ \textgreater{}=\ low(F)\ and\ b0\ \textless{}=\ high(F)} and
both \texttt{T} and \texttt{F} are signed integers or if both are
unsigned integers.

A type \texttt{a} is \textbf{explicitly} convertible to type \texttt{b}
iff the following algorithm returns true:

\begin{verbatim}
proc isExplicitlyConvertible(a, b: PType): bool =
  result = false
  if isImplicitlyConvertible(a, b): return true
  if typeEqualsOrDistinct(a, b): return true
  if isIntegralType(a) and isIntegralType(b): return true
  if isSubtype(a, b) or isSubtype(b, a): return true
\end{verbatim}

The convertible relation can be relaxed by a user-defined type
\texttt{converter}.

\begin{verbatim}
var
  x: int
  chr: char = 'a'

# implicit conversion magic happens here
x = chr
echo x # => 97
# one can use the explicit form too
x = chr.toInt
echo x # => 97
\end{verbatim}

The type conversion \texttt{T(a)} is an L-value if \texttt{a} is an
L-value and \texttt{typeEqualsOrDistinct(T,\ typeof(a))} holds.

\hypertarget{assignment-compatibility}{%
\subsubsection{Assignment
compatibility}\label{assignment-compatibility}}

An expression \texttt{b} can be assigned to an expression \texttt{a} iff
\texttt{a} is an {l-value} and
\texttt{isImplicitlyConvertible(b.typ,\ a.typ)} holds.

\hypertarget{overloading-resolution}{%
\subsection{Overloading resolution}\label{overloading-resolution}}

In a call \texttt{p(args)} the routine \texttt{p} that matches best is
selected. If multiple routines match equally well, the ambiguity is
reported during semantic analysis.

Every arg in args needs to match. There are multiple different
categories how an argument can match. Let \texttt{f} be the formal
parameter's type and \texttt{a} the type of the argument.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Exact match: \texttt{a} and \texttt{f} are of the same type.
\item
  Literal match: \texttt{a} is an integer literal of value \texttt{v}
  and \texttt{f} is a signed or unsigned integer type and \texttt{v} is
  in \texttt{f}'s range. Or: \texttt{a} is a floating point literal of
  value \texttt{v} and \texttt{f} is a floating point type and
  \texttt{v} is in \texttt{f}'s range.
\item
  Generic match: \texttt{f} is a generic type and \texttt{a} matches,
  for instance \texttt{a} is \texttt{int} and \texttt{f} is a generic
  (constrained) parameter type (like in \texttt{{[}T{]}} or
  \texttt{{[}T:\ int\textbar{}char{]}}.
\item
  Subrange or subtype match: \texttt{a} is a \texttt{range{[}T{]}} and
  \texttt{T} matches \texttt{f} exactly. Or: \texttt{a} is a subtype of
  \texttt{f}.
\item
  Integral conversion match: \texttt{a} is convertible to \texttt{f} and
  \texttt{f} and \texttt{a} is some integer or floating point type.
\item
  Conversion match: \texttt{a} is convertible to \texttt{f}, possibly
  via a user defined \texttt{converter}.
\end{enumerate}

These matching categories have a priority: An exact match is better than
a literal match and that is better than a generic match etc. In the
following \texttt{count(p,\ m)} counts the number of matches of the
matching category \texttt{m} for the routine \texttt{p}.

A routine \texttt{p} matches better than a routine \texttt{q} if the
following algorithm returns true:

\begin{verbatim}
for each matching category m in ["exact match", "literal match",
                                "generic match", "subtype match",
                                "integral match", "conversion match"]:
  if count(p, m) > count(q, m): return true
  elif count(p, m) == count(q, m):
    discard "continue with next category m"
  else:
    return false
return "ambiguous"
\end{verbatim}

Some examples:

\begin{verbatim}
takesInt(4) # "int"
var x: int32
takesInt(x) # "T"
var y: int16
takesInt(y) # "int16"
var z: range[0..4] = 0
takesInt(z) # "T"
\end{verbatim}

If this algorithm returns "ambiguous" further disambiguation is
performed: If the argument \texttt{a} matches both the parameter type
\texttt{f} of \texttt{p} and \texttt{g} of \texttt{q} via a subtyping
relation, the inheritance depth is taken into account:

\begin{verbatim}
proc p(obj: A) =
  echo "A"

proc p(obj: B) =
  echo "B"

var c = C()
# not ambiguous, calls 'B', not 'A' since B is a subtype of A
# but not vice versa:
p(c)

proc pp(obj: A, obj2: B) = echo "A B"
proc pp(obj: B, obj2: A) = echo "B A"

# but this is ambiguous:
pp(c, c)
\end{verbatim}

Likewise for generic matches the most specialized generic type (that
still matches) is preferred:

\begin{verbatim}
var ri: ref int
gen(ri) # "ref T"
\end{verbatim}

\hypertarget{overloading-based-on-var-t-out-t}{%
\subsubsection{Overloading based on 'var T' / 'out
T'}\label{overloading-based-on-var-t-out-t}}

If the formal parameter \texttt{f} is of type \texttt{var\ T} (or
\texttt{out\ T}) in addition to the ordinary type checking, the argument
is checked to be an \texttt{l-value}. \texttt{var\ T} (or
\texttt{out\ T}) matches better than just \texttt{T} then.

\begin{verbatim}
proc sayHello(x: int) =
  var m = x # a mutable version of x
  echo sayHi(x) # matches the non-var version of sayHi
  echo sayHi(m) # matches the var version of sayHi

sayHello(3) # 3
            # 13
\end{verbatim}

An l-value matches \texttt{var\ T} and \texttt{out\ T} equally well,
hence the following is ambiguous:

\begin{verbatim}
proc p(x: out string) = x = ""
proc p(x: var string) = x = ""
var v: string
p(v) # ambiguous
\end{verbatim}

\hypertarget{lazy-type-resolution-for-untyped}{%
\subsubsection{Lazy type resolution for
untyped}\label{lazy-type-resolution-for-untyped}}

\textbf{Note}: An \texttt{unresolved} expression is an expression for
which no symbol lookups and no type checking have been performed.

Since templates and macros that are not declared as \texttt{immediate}
participate in overloading resolution it's essential to have a way to
pass unresolved expressions to a template or macro. This is what the
meta-type \texttt{untyped} accomplishes:

\begin{verbatim}
rem unresolvedExpression(undeclaredIdentifier)
\end{verbatim}

A parameter of type \texttt{untyped} always matches any argument (as
long as there is any argument passed to it).

But one has to watch out because other overloads might trigger the
argument's resolution:

\begin{verbatim}
# undeclared identifier: 'unresolvedExpression'
rem unresolvedExpression(undeclaredIdentifier)
\end{verbatim}

\texttt{untyped} and \texttt{varargs{[}untyped{]}} are the only metatype
that are lazy in this sense, the other metatypes \texttt{typed} and
\texttt{typedesc} are not lazy.

\hypertarget{varargs-matching}{%
\subsubsection{Varargs matching}\label{varargs-matching}}

See \protect\hyperlink{types-varargs}{Varargs}.

\hypertarget{statements-and-expressions}{%
\subsection{Statements and
expressions}\label{statements-and-expressions}}

Nim uses the common statement/expression paradigm: Statements do not
produce a value in contrast to expressions. However, some expressions
are statements.

Statements are separated into \texttt{simple\ statements} and
\texttt{complex\ statements}. Simple statements are statements that
cannot contain other statements like assignments, calls or the
\texttt{return} statement; complex statements can contain other
statements. To avoid the \texttt{dangling\ else\ problem}, complex
statements always have to be indented. The details can be found in the
grammar.

\hypertarget{statement-list-expression}{%
\subsubsection{Statement list
expression}\label{statement-list-expression}}

Statements can also occur in an expression context that looks like
\texttt{(stmt1;\ stmt2;\ ...;\ ex)}. This is called an statement list
expression or \texttt{(;)}. The type of
\texttt{(stmt1;\ stmt2;\ ...;\ ex)} is the type of \texttt{ex}. All the
other statements must be of type \texttt{void}. (One can use
\texttt{discard} to produce a \texttt{void} type.) \texttt{(;)} does not
introduce a new scope.

\hypertarget{discard-statement}{%
\subsubsection{Discard statement}\label{discard-statement}}

Example:

\begin{verbatim}
discard p(3, 4) # discard the return value of `p`
\end{verbatim}

The \texttt{discard} statement evaluates its expression for side-effects
and throws the expression's resulting value away, and should only be
used when ignoring this value is known not to cause problems.

Ignoring the return value of a procedure without using a discard
statement is a static error.

The return value can be ignored implicitly if the called proc/iterator
has been declared with the \texttt{discardable} pragma:

\begin{verbatim}
p(3, 4) # now valid
\end{verbatim}

An empty \texttt{discard} statement is often used as a null statement:

\begin{verbatim}
\end{verbatim}

\hypertarget{void-context}{%
\subsubsection{Void context}\label{void-context}}

In a list of statements every expression except the last one needs to
have the type \texttt{void}. In addition to this rule an assignment to
the builtin \texttt{result} symbol also triggers a mandatory
\texttt{void} context for the subsequent expressions:

\begin{verbatim}
\end{verbatim}

\begin{verbatim}
\end{verbatim}

\hypertarget{var-statement}{%
\subsubsection{Var statement}\label{var-statement}}

Var statements declare new local and global variables and initialize
them. A comma separated list of variables can be used to specify
variables of the same type:

\begin{verbatim}
var
  a: int = 0
  x, y, z: int
\end{verbatim}

If an initializer is given the type can be omitted: the variable is then
of the same type as the initializing expression. Variables are always
initialized with a default value if there is no initializing expression.
The default value depends on the type and is always a zero in binary.

\begin{longtable}[]{@{}ll@{}}
\toprule
Type & default value\tabularnewline
\midrule
\endhead
any integer type & 0\tabularnewline
any float & 0.0\tabularnewline
char & '\textbackslash0'\tabularnewline
bool & false\tabularnewline
ref or pointer type & nil\tabularnewline
procedural type & nil\tabularnewline
sequence & \texttt{@{[}{]}}\tabularnewline
string & \texttt{""}\tabularnewline
tuple{[}x: A, y: B, ...{]} & (default(A), default(B), ...) (analogous
for objects)\tabularnewline
array{[}0..., T{]} & {[}default(T), ...{]}\tabularnewline
range{[}T{]} & default(T); this may be out of the valid
range\tabularnewline
T = enum & cast{[}T{]}(0); this may be an invalid value\tabularnewline
\bottomrule
\end{longtable}

The implicit initialization can be avoided for optimization reasons with
the \texttt{noinit} pragma:

\begin{verbatim}
\end{verbatim}

If a proc is annotated with the \texttt{noinit} pragma this refers to
its implicit \texttt{result} variable:

\begin{verbatim}
\end{verbatim}

The implicit initialization can be also prevented by the
\texttt{requiresInit} type pragma. The compiler requires an explicit
initialization for the object and all of its fields. However it does a
\texttt{control\ flow\ analysis} to prove the variable has been
initialized and does not rely on syntactic properties:

\begin{verbatim}
proc p() =
  # the following is valid:
  var x: MyObject
  if someCondition():
    x = a()
  else:
    x = a()
  # use x
\end{verbatim}

\hypertarget{let-statement}{%
\subsubsection{Let statement}\label{let-statement}}

A \texttt{let} statement declares new local and global
\texttt{single\ assignment} variables and binds a value to them. The
syntax is the same as that of the \texttt{var} statement, except that
the keyword \texttt{var} is replaced by the keyword \texttt{let}. Let
variables are not l-values and can thus not be passed to \texttt{var}
parameters nor can their address be taken. They cannot be assigned new
values.

For let variables the same pragmas are available as for ordinary
variables.

As \texttt{let} statements are immutable after creation they need to
define a value when they are declared. The only exception to this is if
the \texttt{\{.importc.\}} pragma (or any of the other \texttt{importX}
pragmas) is applied, in this case the value is expected to come from
native code, typically a C/C++ \texttt{const}.

\hypertarget{tuple-unpacking}{%
\subsubsection{Tuple unpacking}\label{tuple-unpacking}}

In a \texttt{var} or \texttt{let} statement tuple unpacking can be
performed. The special identifier \texttt{\_} can be used to ignore some
parts of the tuple:

\begin{verbatim}
let (x, _, z) = returnsTuple()
\end{verbatim}

\hypertarget{const-section}{%
\subsubsection{Const section}\label{const-section}}

A const section declares constants whose values are constant
expressions:

\begin{verbatim}
\end{verbatim}

Once declared, a constant's symbol can be used as a constant expression.

See \protect\hyperlink{constants-and-constant-expressions}{Constants and
Constant Expressions} for details.

\hypertarget{static-statementexpression}{%
\subsubsection{Static
statement/expression}\label{static-statementexpression}}

A static statement/expression explicitly requires compile-time
execution. Even some code that has side effects is permitted in a static
block:

\begin{verbatim}
static:
  echo "echo at compile time"
\end{verbatim}

There are limitations on what Nim code can be executed at compile time;
see
\protect\hyperlink{restrictions-on-compileminustime-execution}{Restrictions
on Compile-Time Execution} for details. It's a static error if the
compiler cannot execute the block at compile time.

\hypertarget{if-statement}{%
\subsubsection{If statement}\label{if-statement}}

Example:

\begin{verbatim}
var name = readLine(stdin)

if name == "Andreas":
  echo "What a nice name!"
elif name == "":
  echo "Don't you have a name?"
else:
  echo "Boring name..."
\end{verbatim}

The \texttt{if} statement is a simple way to make a branch in the
control flow: The expression after the keyword \texttt{if} is evaluated,
if it is true the corresponding statements after the \texttt{:} are
executed. Otherwise the expression after the \texttt{elif} is evaluated
(if there is an \texttt{elif} branch), if it is true the corresponding
statements after the \texttt{:} are executed. This goes on until the
last \texttt{elif}. If all conditions fail, the \texttt{else} part is
executed. If there is no \texttt{else} part, execution continues with
the next statement.

In \texttt{if} statements new scopes begin immediately after the
\texttt{if}/\texttt{elif}/\texttt{else} keywords and ends after the
corresponding \emph{then} block. For visualization purposes the scopes
have been enclosed in \texttt{\{\textbar{}\ \ \textbar{}\}} in the
following example:

\begin{verbatim}
\end{verbatim}

\hypertarget{case-statement}{%
\subsubsection{Case statement}\label{case-statement}}

Example:

\begin{verbatim}
case readline(stdin)
of "delete-everything", "restart-computer":
  echo "permission denied"
of "go-for-a-walk":     echo "please yourself"
else:                   echo "unknown command"

# indentation of the branches is also allowed; and so is an optional colon
# after the selecting expression:
case readline(stdin):
  of "delete-everything", "restart-computer":
    echo "permission denied"
  of "go-for-a-walk":     echo "please yourself"
  else:                   echo "unknown command"
\end{verbatim}

The \texttt{case} statement is similar to the if statement, but it
represents a multi-branch selection. The expression after the keyword
\texttt{case} is evaluated and if its value is in a \emph{slicelist} the
corresponding statements (after the \texttt{of} keyword) are executed.
If the value is not in any given \emph{slicelist} the \texttt{else} part
is executed. If there is no \texttt{else} part and not all possible
values that \texttt{expr} can hold occur in a \texttt{slicelist}, a
static error occurs. This holds only for expressions of ordinal types.
"All possible values" of \texttt{expr} are determined by \texttt{expr}'s
type. To suppress the static error an \texttt{else} part with an empty
\texttt{discard} statement should be used.

For non ordinal types it is not possible to list every possible value
and so these always require an \texttt{else} part.

Because case statements are checked for exhaustiveness during semantic
analysis, the value in every \texttt{of} branch must be a constant
expression. This restriction also allows the compiler to generate more
performant code.

As a special semantic extension, an expression in an \texttt{of} branch
of a case statement may evaluate to a set or array constructor; the set
or array is then expanded into a list of its elements:

\begin{verbatim}
proc classify(s: string) =
  case s[0]
  of SymChars, '_': echo "an identifier"
  of '0'..'9': echo "a number"
  else: echo "other"

# is equivalent to:
proc classify(s: string) =
  case s[0]
  of 'a'..'z', 'A'..'Z', '\x80'..'\xFF', '_': echo "an identifier"
  of '0'..'9': echo "a number"
  else: echo "other"
\end{verbatim}

The \texttt{case} statement doesn't produce an l-value, so the following
example won't work:

\begin{verbatim}
proc get_x(x: Foo): var seq[string] =
  # doesn't work
  case true
  of true:
    x.x
  else:
    x.x

var foo = Foo(x: @[])
foo.get_x().add("asd")
\end{verbatim}

This can be fixed by explicitly using \texttt{return}:

\begin{verbatim}
\end{verbatim}

\hypertarget{when-statement}{%
\subsubsection{When statement}\label{when-statement}}

Example:

\begin{verbatim}
when sizeof(int) == 2:
  echo "running on a 16 bit system!"
elif sizeof(int) == 4:
  echo "running on a 32 bit system!"
elif sizeof(int) == 8:
  echo "running on a 64 bit system!"
else:
  echo "cannot happen!"
\end{verbatim}

The \texttt{when} statement is almost identical to the \texttt{if}
statement with some exceptions:

\begin{itemize}
\tightlist
\item
  Each condition (\texttt{expr}) has to be a constant expression (of
  type \texttt{bool}).
\item
  The statements do not open a new scope.
\item
  The statements that belong to the expression that evaluated to true
  are translated by the compiler, the other statements are not checked
  for semantics! However, each condition is checked for semantics.
\end{itemize}

The \texttt{when} statement enables conditional compilation techniques.
As a special syntactic extension, the \texttt{when} construct is also
available within \texttt{object} definitions.

\hypertarget{when-nimvm-statement}{%
\subsubsection{When nimvm statement}\label{when-nimvm-statement}}

\texttt{nimvm} is a special symbol, that may be used as expression of
\texttt{when\ nimvm} statement to differentiate execution path between
compile time and the executable.

Example:

\begin{verbatim}
\end{verbatim}

\texttt{when\ nimvm} statement must meet the following requirements:

\begin{itemize}
\tightlist
\item
  Its expression must always be \texttt{nimvm}. More complex expressions
  are not allowed.
\item
  It must not contain \texttt{elif} branches.
\item
  It must contain \texttt{else} branch.
\item
  Code in branches must not affect semantics of the code that follows
  the \texttt{when\ nimvm} statement. E.g. it must not define symbols
  that are used in the following code.
\end{itemize}

\hypertarget{return-statement}{%
\subsubsection{Return statement}\label{return-statement}}

Example:

\begin{verbatim}
\end{verbatim}

The \texttt{return} statement ends the execution of the current
procedure. It is only allowed in procedures. If there is an
\texttt{expr}, this is syntactic sugar for:

\begin{verbatim}
\end{verbatim}

\texttt{return} without an expression is a short notation for
\texttt{return\ result} if the proc has a return type. The
\texttt{result} variable is always the return value of the procedure. It
is automatically declared by the compiler. As all variables,
\texttt{result} is initialized to (binary) zero:

\begin{verbatim}
\end{verbatim}

\hypertarget{yield-statement}{%
\subsubsection{Yield statement}\label{yield-statement}}

Example:

\begin{verbatim}
\end{verbatim}

The \texttt{yield} statement is used instead of the \texttt{return}
statement in iterators. It is only valid in iterators. Execution is
returned to the body of the for loop that called the iterator. Yield
does not end the iteration process, but execution is passed back to the
iterator if the next iteration starts. See the section about iterators
(\protect\hyperlink{iterators-and-the-for-statement}{Iterators and the
for statement}) for further information.

\hypertarget{block-statement}{%
\subsubsection{Block statement}\label{block-statement}}

Example:

\begin{verbatim}
\end{verbatim}

The block statement is a means to group statements to a (named)
\texttt{block}. Inside the block, the \texttt{break} statement is
allowed to leave the block immediately. A \texttt{break} statement can
contain a name of a surrounding block to specify which block is to
leave.

\hypertarget{break-statement}{%
\subsubsection{Break statement}\label{break-statement}}

Example:

\begin{verbatim}
\end{verbatim}

The \texttt{break} statement is used to leave a block immediately. If
\texttt{symbol} is given, it is the name of the enclosing block that is
to leave. If it is absent, the innermost block is left.

\hypertarget{while-statement}{%
\subsubsection{While statement}\label{while-statement}}

Example:

\begin{verbatim}
\end{verbatim}

The \texttt{while} statement is executed until the \texttt{expr}
evaluates to false. Endless loops are no error. \texttt{while}
statements open an {implicit block}, so that they can be left with a
\texttt{break} statement.

\hypertarget{continue-statement}{%
\subsubsection{Continue statement}\label{continue-statement}}

A \texttt{continue} statement leads to the immediate next iteration of
the surrounding loop construct. It is only allowed within a loop. A
continue statement is syntactic sugar for a nested block:

\begin{verbatim}
\end{verbatim}

Is equivalent to:

\begin{verbatim}
\end{verbatim}

\hypertarget{assembler-statement}{%
\subsubsection{Assembler statement}\label{assembler-statement}}

The direct embedding of assembler code into Nim code is supported by the
unsafe \texttt{asm} statement. Identifiers in the assembler code that
refer to Nim identifiers shall be enclosed in a special character which
can be specified in the statement's pragmas. The default special
character is
\texttt{\textquotesingle{}\textasciigrave{}\textquotesingle{}}:

\begin{verbatim}
\end{verbatim}

If the GNU assembler is used, quotes and newlines are inserted
automatically:

\begin{verbatim}
\end{verbatim}

Instead of:

\begin{verbatim}
\end{verbatim}

\hypertarget{using-statement}{%
\subsubsection{Using statement}\label{using-statement}}

The using statement provides syntactic convenience in modules where the
same parameter names and types are used over and over. Instead of:

\begin{verbatim}
\end{verbatim}

One can tell the compiler about the convention that a parameter of name
\texttt{c} should default to type \texttt{Context}, \texttt{n} should
default to \texttt{Node} etc.:

\begin{verbatim}
proc foo(c, n) = ...
proc bar(c, n, counter) = ...
proc baz(c, n) = ...

proc mixedMode(c, n; x, y: int) =
  # 'c' is inferred to be of the type 'Context'
  # 'n' is inferred to be of the type 'Node'
  # But 'x' and 'y' are of type 'int'.
\end{verbatim}

The \texttt{using} section uses the same indentation based grouping
syntax as a \texttt{var} or \texttt{let} section.

Note that \texttt{using} is not applied for \texttt{template} since
untyped template parameters default to the type \texttt{system.untyped}.

Mixing parameters that should use the \texttt{using} declaration with
parameters that are explicitly typed is possible and requires a
semicolon between them.

\hypertarget{if-expression}{%
\subsubsection{If expression}\label{if-expression}}

An {if expression} is almost like an if statement, but it is an
expression. This feature is similar to {ternary operators} in other
languages. Example:

\begin{verbatim}
\end{verbatim}

An if expression always results in a value, so the \texttt{else} part is
required. \texttt{Elif} parts are also allowed.

\hypertarget{when-expression}{%
\subsubsection{When expression}\label{when-expression}}

Just like an {if expression}, but corresponding to the when statement.

\hypertarget{case-expression}{%
\subsubsection{Case expression}\label{case-expression}}

The {case expression} is again very similar to the case statement:

\begin{verbatim}
\end{verbatim}

As seen in the above example, the case expression can also introduce
side effects. When multiple statements are given for a branch, Nim will
use the last expression as the result value.

\hypertarget{block-expression}{%
\subsubsection{Block expression}\label{block-expression}}

A {block expression} is almost like a block statement, but it is an
expression that uses last expression under the block as the value. It is
similar to the statement list expression, but the statement list
expression does not open new block scope.

\begin{verbatim}
\end{verbatim}

\hypertarget{table-constructor}{%
\subsubsection{Table constructor}\label{table-constructor}}

A table constructor is syntactic sugar for an array constructor:

\begin{verbatim}
# is the same as:
[("key1", "value1"), ("key2", "value2"), ("key3", "value2")]
\end{verbatim}

The empty table can be written \texttt{\{:\}} (in contrast to the empty
set which is \texttt{\{\}}) which is thus another way to write as the
empty array constructor \texttt{{[}{]}}. This slightly unusual way of
supporting tables has lots of advantages:

\begin{itemize}
\tightlist
\item
  The order of the (key,value)-pairs is preserved, thus it is easy to
  support ordered dicts with for example
  \texttt{\{key:\ val\}.newOrderedTable}.
\item
  A table literal can be put into a \texttt{const} section and the
  compiler can easily put it into the executable's data section just
  like it can for arrays and the generated data section requires a
  minimal amount of memory.
\item
  Every table implementation is treated equal syntactically.
\item
  Apart from the minimal syntactic sugar the language core does not need
  to know about tables.
\end{itemize}

\hypertarget{type-conversions}{%
\subsubsection{Type conversions}\label{type-conversions}}

Syntactically a \emph{type conversion} is like a procedure call, but a
type name replaces the procedure name. A type conversion is always safe
in the sense that a failure to convert a type to another results in an
exception (if it cannot be determined statically).

Ordinary procs are often preferred over type conversions in Nim: For
instance, \texttt{\$} is the \texttt{toString} operator by convention
and \texttt{toFloat} and \texttt{toInt} can be used to convert from
floating point to integer or vice versa.

A type conversion can also be used to disambiguate overloaded routines:

\begin{verbatim}
proc p(x: int) = echo "int"
proc p(x: string) = echo "string"

let procVar = (proc(x: string))(p)
procVar("a")
\end{verbatim}

Since operations on unsigned numbers wrap around and are unchecked so
are type conversion to unsigned integers and between unsigned integers.
The rationale for this is mostly better interoperability with the C
Programming language when algorithms are ported from C to Nim.

Exception: Values that are converted to an unsigned type at compile time
are checked so that code like \texttt{byte(-1)} does not compile.

\textbf{Note}: Historically the operations were unchecked and the
conversions were sometimes checked but starting with the revision 1.0.4
of this document and the language implementation the conversions too are
now \emph{always unchecked}.

\hypertarget{type-casts}{%
\subsubsection{Type casts}\label{type-casts}}

\emph{Type casts} are a crude mechanism to interpret the bit pattern of
an expression as if it would be of another type. Type casts are only
needed for low-level programming and are inherently unsafe.

\begin{verbatim}
\end{verbatim}

The target type of a cast must be a concrete type, for instance, a
target type that is a type class (which is non-concrete) would be
invalid:

\begin{verbatim}
\end{verbatim}

Type casts should not be confused with \emph{type conversions,} as
mentioned in the prior section. Unlike type conversions, a type cast
cannot change the underlying bit pattern of the data being casted (aside
from that the size of the target type may differ from the source type).
Casting resembles \emph{type punning} in other languages or C++'s
\texttt{reinterpret\_cast} and \texttt{bit\_cast} features.

\hypertarget{the-addr-operator}{%
\subsubsection{The addr operator}\label{the-addr-operator}}

The \texttt{addr} operator returns the address of an l-value. If the
type of the location is \texttt{T}, the {addr} operator result is of the
type \texttt{ptr\ T}. An address is always an untraced reference. Taking
the address of an object that resides on the stack is \textbf{unsafe},
as the pointer may live longer than the object on the stack and can thus
reference a non-existing object. One can get the address of variables,
but one can't use it on variables declared through \texttt{let}
statements:

\begin{verbatim}
let t1 = "Hello"
var
  t2 = t1
  t3 : pointer = addr(t2)
echo repr(addr(t2))
# --> ref 0x7fff6b71b670 --> 0x10bb81050"Hello"
echo cast[ptr string](t3)[]
# --> Hello
# The following line doesn't compile:
echo repr(addr(t1))
# Error: expression has no address
\end{verbatim}

\hypertarget{the-unsafeaddr-operator}{%
\subsubsection{The unsafeAddr operator}\label{the-unsafeaddr-operator}}

For easier interoperability with other compiled languages such as C,
retrieving the address of a \texttt{let} variable, a parameter or a
\texttt{for} loop variable, the \texttt{unsafeAddr} operation can be
used:

\begin{verbatim}
let myArray = [1, 2, 3]
foreignProcThatTakesAnAddr(unsafeAddr myArray)
\end{verbatim}

\hypertarget{procedures}{%
\subsection{Procedures}\label{procedures}}

What most programming languages call \texttt{methods} or
\texttt{functions} are called \texttt{procedures} in Nim. A procedure
declaration consists of an identifier, zero or more formal parameters, a
return value type and a block of code. Formal parameters are declared as
a list of identifiers separated by either comma or semicolon. A
parameter is given a type by \texttt{:\ typename}. The type applies to
all parameters immediately before it, until either the beginning of the
parameter list, a semicolon separator or an already typed parameter, is
reached. The semicolon can be used to make separation of types and
subsequent identifiers more distinct.

\begin{verbatim}
# Using semicolon for visual distinction
proc foo(a, b: int; c, d: bool): int

# Will fail: a is untyped since ';' stops type propagation.
proc foo(a; b: int; c, d: bool): int
\end{verbatim}

A parameter may be declared with a default value which is used if the
caller does not provide a value for the argument.

\begin{verbatim}
\end{verbatim}

Parameters can be declared mutable and so allow the proc to modify those
arguments, by using the type modifier {var}.

\begin{verbatim}
\end{verbatim}

If the proc declaration has no body, it is a \texttt{forward}
declaration. If the proc returns a value, the procedure body can access
an implicitly declared variable named \texttt{result} that represents
the return value. Procs can be overloaded. The overloading resolution
algorithm determines which proc is the best match for the arguments.
Example:

\begin{verbatim}
proc toLower(c: char): char = # toLower for characters
  if c in {'A'..'Z'}:
    result = chr(ord(c) + (ord('a') - ord('A')))
  else:
    result = c

proc toLower(s: string): string = # toLower for strings
  result = newString(len(s))
  for i in 0..len(s) - 1:
    result[i] = toLower(s[i]) # calls toLower for characters; no recursion!
\end{verbatim}

Calling a procedure can be done in many different ways:

\begin{verbatim}
# call with positional arguments      # parameter bindings:
callme(0, 1, "abc", '\t', true)       # (x=0, y=1, s="abc", c='\t', b=true)
# call with named and positional arguments:
callme(y=1, x=0, "abd", '\t')         # (x=0, y=1, s="abd", c='\t', b=false)
# call with named arguments (order is not relevant):
callme(c='\t', y=1, x=0)              # (x=0, y=1, s="", c='\t', b=false)
# call as a command statement: no () needed:
callme 0, 1, "abc", '\t'              # (x=0, y=1, s="abc", c='\t', b=false)
\end{verbatim}

A procedure may call itself recursively.

\texttt{Operators} are procedures with a special operator symbol as
identifier:

\begin{verbatim}
\end{verbatim}

Operators with one parameter are prefix operators, operators with two
parameters are infix operators. (However, the parser distinguishes these
from the operator's position within an expression.) There is no way to
declare postfix operators: all postfix operators are built-in and
handled by the grammar explicitly.

Any operator can be called like an ordinary proc with the '{opr}'
notation. (Thus an operator can have more than two parameters):

\begin{verbatim}
assert `*+`(3, 4, 6) == `+`(`*`(a, b), c)
\end{verbatim}

\hypertarget{export-marker}{%
\subsubsection{Export marker}\label{export-marker}}

If a declared symbol is marked with an \texttt{asterisk} it is exported
from the current module:

\begin{verbatim}
proc exportedEcho*(s: string) = echo s
proc `*`*(a: string; b: int): string =
  result = newStringOfCap(a.len * b)
  for i in 1..b: result.add a

var exportedVar*: int
const exportedConst* = 78
type
  ExportedType* = object
    exportedField*: int
\end{verbatim}

\hypertarget{method-call-syntax}{%
\subsubsection{Method call syntax}\label{method-call-syntax}}

For object oriented programming, the syntax \texttt{obj.method(args)}
can be used instead of \texttt{method(obj,\ args)}. The parentheses can
be omitted if there are no remaining arguments: \texttt{obj.len}
(instead of \texttt{len(obj)}).

This method call syntax is not restricted to objects, it can be used to
supply any type of first argument for procedures:

\begin{verbatim}
echo "abc".len # is the same as echo len "abc"
echo "abc".toUpper()
echo {'a', 'b', 'c'}.card
stdout.writeLine("Hallo") # the same as writeLine(stdout, "Hallo")
\end{verbatim}

Another way to look at the method call syntax is that it provides the
missing postfix notation.

The method call syntax conflicts with explicit generic instantiations:
\texttt{p{[}T{]}(x)} cannot be written as \texttt{x.p{[}T{]}} because
\texttt{x.p{[}T{]}} is always parsed as \texttt{(x.p){[}T{]}}.

See also:
\protect\hyperlink{templates-limitations-of-the-method-call-syntax}{Limitations
of the method call syntax}.

The \texttt{{[}:\ {]}} notation has been designed to mitigate this
issue: \texttt{x.p{[}:T{]}} is rewritten by the parser to
\texttt{p{[}T{]}(x)}, \texttt{x.p{[}:T{]}(y)} is rewritten to
\texttt{p{[}T{]}(x,\ y)}. Note that \texttt{{[}:\ {]}} has no AST
representation, the rewrite is performed directly in the parsing step.

\hypertarget{properties}{%
\subsubsection{Properties}\label{properties}}

Nim has no need for \emph{get-properties}: Ordinary get-procedures that
are called with the \emph{method call syntax} achieve the same. But
setting a value is different; for this a special setter syntax is
needed:

\begin{verbatim}
proc `host=`*(s: var Socket, value: int) {.inline.} =
  ## setter of hostAddr.
  ## This accesses the 'host' field and is not a recursive call to
  ## ``host=`` because the builtin dot access is preferred if it is
  ## available:
  s.host = value

proc host*(s: Socket): int {.inline.} =
  ## getter of hostAddr
  ## This accesses the 'host' field and is not a recursive call to
  ## ``host`` because the builtin dot access is preferred if it is
  ## available:
  s.host
\end{verbatim}

\begin{verbatim}
\end{verbatim}

A proc defined as \texttt{f=} (with the trailing \texttt{=}) is called a
\texttt{setter}. A setter can be called explicitly via the common
backticks notation:

\begin{verbatim}
proc `f=`(x: MyObject; value: string) =
  discard

`f=`(myObject, "value")
\end{verbatim}

\texttt{f=} can be called implicitly in the pattern
\texttt{x.f\ =\ value} if and only if the type of \texttt{x} does not
have a field named \texttt{f} or if \texttt{f} is not visible in the
current module. These rules ensure that object fields and accessors can
have the same name. Within the module \texttt{x.f} is then always
interpreted as field access and outside the module it is interpreted as
an accessor proc call.

\hypertarget{command-invocation-syntax}{%
\subsubsection{Command invocation
syntax}\label{command-invocation-syntax}}

Routines can be invoked without the \texttt{()} if the call is
syntactically a statement. This command invocation syntax also works for
expressions, but then only a single argument may follow. This
restriction means \texttt{echo\ f\ 1,\ f\ 2} is parsed as
\texttt{echo(f(1),\ f(2))} and not as \texttt{echo(f(1,\ f(2)))}. The
method call syntax may be used to provide one more argument in this
case:

\begin{verbatim}
echo optarg 1, " ", singlearg 2  # prints "1 40"

let fail = optarg 1, optarg 8   # Wrong. Too many arguments for a command call
let x = optarg(1, optarg 8)  # traditional procedure call with 2 arguments
let y = 1.optarg optarg 8    # same thing as above, w/o the parenthesis
assert x == y
\end{verbatim}

The command invocation syntax also can't have complex expressions as
arguments. For example:
(\protect\hyperlink{procedures-anonymous-procs}{anonymous procs}),
\texttt{if}, \texttt{case} or \texttt{try}. Function calls with no
arguments still needs () to distinguish between a call and the function
itself as a first class value.

\hypertarget{closures}{%
\subsubsection{Closures}\label{closures}}

Procedures can appear at the top level in a module as well as inside
other scopes, in which case they are called nested procs. A nested proc
can access local variables from its enclosing scope and if it does so it
becomes a closure. Any captured variables are stored in a hidden
additional argument to the closure (its environment) and they are
accessed by reference by both the closure and its enclosing scope (i.e.
any modifications made to them are visible in both places). The closure
environment may be allocated on the heap or on the stack if the compiler
determines that this would be safe.

\hypertarget{creating-closures-in-loops}{%
\paragraph{Creating closures in
loops}\label{creating-closures-in-loops}}

Since closures capture local variables by reference it is often not
wanted behavior inside loop bodies. See
\href{system.html\#closureScope.t,untyped}{closureScope} and
\href{sugar.html\#capture.m,openArray\%5Btyped\%5D,untyped}{capture} for
details on how to change this behavior.

\hypertarget{anonymous-procs}{%
\subsubsection{Anonymous Procs}\label{anonymous-procs}}

Unnamed procedures can be used as lambda expressions to pass into other
procedures:

\begin{verbatim}
cities.sort(proc (x,y: string): int =
    cmp(x.len, y.len))
\end{verbatim}

Procs as expressions can appear both as nested procs and inside top
level executable code. The \href{sugar.html}{sugar} module contains the
{=\textgreater{}} macro which enables a more succinct syntax for
anonymous procedures resembling lambdas as they are in languages like
JavaScript, C\#, etc.

\hypertarget{func}{%
\subsubsection{Func}\label{func}}

The \texttt{func} keyword introduces a shortcut for a
\texttt{noSideEffect} proc.

\begin{verbatim}
\end{verbatim}

Is short for:

\begin{verbatim}
\end{verbatim}

\hypertarget{nonoverloadable-builtins}{%
\subsubsection{Nonoverloadable
builtins}\label{nonoverloadable-builtins}}

The following builtin procs cannot be overloaded for reasons of
implementation simplicity (they require specialized semantic checking):

\begin{verbatim}
declared, defined, definedInScope, compiles, sizeof,
is, shallowCopy, getAst, astToStr, spawn, procCall
\end{verbatim}

Thus they act more like keywords than like ordinary identifiers; unlike
a keyword however, a redefinition may \texttt{shadow} the definition in
the \texttt{system} module. From this list the following should not be
written in dot notation \texttt{x.f} since \texttt{x} cannot be type
checked before it gets passed to \texttt{f}:

\begin{verbatim}
declared, defined, definedInScope, compiles, getAst, astToStr
\end{verbatim}

\hypertarget{var-parameters}{%
\subsubsection{Var parameters}\label{var-parameters}}

The type of a parameter may be prefixed with the \texttt{var} keyword:

\begin{verbatim}
var
  x, y: int

divmod(8, 5, x, y) # modifies x and y
assert x == 1
assert y == 3
\end{verbatim}

In the example, \texttt{res} and \texttt{remainder} are {var
parameters}. Var parameters can be modified by the procedure and the
changes are visible to the caller. The argument passed to a var
parameter has to be an l-value. Var parameters are implemented as hidden
pointers. The above example is equivalent to:

\begin{verbatim}
var
  x, y: int
divmod(8, 5, addr(x), addr(y))
assert x == 1
assert y == 3
\end{verbatim}

In the examples, var parameters or pointers are used to provide two
return values. This can be done in a cleaner way by returning a tuple:

\begin{verbatim}
var t = divmod(8, 5)

assert t.res == 1
assert t.remainder == 3
\end{verbatim}

One can use \texttt{tuple\ unpacking} to access the tuple's fields:

\begin{verbatim}
\end{verbatim}

\textbf{Note}: \texttt{var} parameters are never necessary for efficient
parameter passing. Since non-var parameters cannot be modified the
compiler is always free to pass arguments by reference if it considers
it can speed up execution.

\hypertarget{var-return-type}{%
\subsubsection{Var return type}\label{var-return-type}}

A proc, converter or iterator may return a \texttt{var} type which means
that the returned value is an l-value and can be modified by the caller:

\begin{verbatim}
proc writeAccessToG(): var int =
  result = g

writeAccessToG() = 6
assert g == 6
\end{verbatim}

It is a static error if the implicitly introduced pointer could be used
to access a location beyond its lifetime:

\begin{verbatim}
\end{verbatim}

For iterators, a component of a tuple return type can have a
\texttt{var} type too:

\begin{verbatim}
\end{verbatim}

In the standard library every name of a routine that returns a
\texttt{var} type starts with the prefix \texttt{m} per convention.

Memory safety for returning by \texttt{var\ T} is ensured by a simple
borrowing rule: If \texttt{result} does not refer to a location pointing
to the heap (that is in \texttt{result\ =\ X} the \texttt{X} involves a
\texttt{ptr} or \texttt{ref} access) then it has to be derived from the
routine's first parameter:

\begin{verbatim}
proc p(param: var int): var int =
  var x: int
  # we know 'forward' provides a view into the location derived from
  # its first argument 'x'.
  result = forward(x) # Error: location is derived from ``x``
                      # which is not p's first parameter and lives
                      # on the stack.
\end{verbatim}

In other words, the lifetime of what \texttt{result} points to is
attached to the lifetime of the first parameter and that is enough
knowledge to verify memory safety at the callsite.

\hypertarget{future-directions}{%
\paragraph{Future directions}\label{future-directions}}

Later versions of Nim can be more precise about the borrowing rule with
a syntax like:

\begin{verbatim}
\end{verbatim}

Here \texttt{var\ T\ from\ container} explicitly exposes that the
location is derived from the second parameter (called 'container' in
this case). The syntax \texttt{var\ T\ from\ p} specifies a type
\texttt{varTy{[}T,\ 2{]}} which is incompatible with
\texttt{varTy{[}T,\ 1{]}}.

\hypertarget{nrvo}{%
\subsubsection{NRVO}\label{nrvo}}

\textbf{Note}: This section describes the current implementation. This
part of the language specification will be changed. See
\url{https://github.com/nim-lang/RFCs/issues/230} for more information.

The return value is represented inside the body of a routine as the
special \texttt{result} variable. This allows for a mechanism much like
C++'s "named return value optimization" (\texttt{NRVO}). NRVO means that
the stores to \texttt{result} inside \texttt{p} directly affect the
destination \texttt{dest} in \texttt{let/var\ dest\ =\ p(args)}
(definition of \texttt{dest}) and also in \texttt{dest\ =\ p(args)}
(assignment to \texttt{dest}). This is achieved by rewriting
\texttt{dest\ =\ p(args)} to \texttt{p\textquotesingle{}(args,\ dest)}
where \texttt{p\textquotesingle{}} is a variation of \texttt{p} that
returns \texttt{void} and receives a hidden mutable parameter
representing \texttt{result}.

Informally:

\begin{verbatim}
var x = p()
x = p()

# is roughly turned into:

proc p(result: var BigT) = ...

var x; p(x)
p(x)
\end{verbatim}

Let \texttt{T}'s be \texttt{p}'s return type. NRVO applies for
\texttt{T} if \texttt{sizeof(T)\ \textgreater{}=\ N} (where \texttt{N}
is implementation dependent), in other words, it applies for "big"
structures.

If \texttt{p} can raise an exception, NRVO applies regardless. This can
produce observable differences in behavior:

\begin{verbatim}
type
  BigT = array[16, int]

proc p(raiseAt: int): BigT =
  for i in 0..high(result):
    if i == raiseAt: raise newException(ValueError, "interception")
    result[i] = i

proc main =
  var x: BigT
  try:
    x = p(8)
  except ValueError:
    doAssert x == [0, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0]

main()
\end{verbatim}

However, the current implementation produces a warning in these cases.
There are different ways to deal with this warning:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Disable the warning via
  \texttt{\{.push\ warning{[}ObservableStores{]}:\ off.\}} ...
  \texttt{\{.pop.\}}. Then one may need to ensure that \texttt{p} only
  raises \emph{before} any stores to \texttt{result} happen.
\item
  One can use a temporary helper variable, for example instead of
  \texttt{x\ =\ p(8)} use \texttt{let\ tmp\ =\ p(8);\ x\ =\ tmp}.
\end{enumerate}

\hypertarget{overloading-of-the-subscript-operator}{%
\subsubsection{Overloading of the subscript
operator}\label{overloading-of-the-subscript-operator}}

The \texttt{{[}{]}} subscript operator for arrays/openarrays/sequences
can be overloaded.

\hypertarget{multi-methods}{%
\subsection{Multi-methods}\label{multi-methods}}

\textbf{Note:} Starting from Nim 0.20, to use multi-methods one must
explicitly pass \texttt{-\/-multimethods:on} when compiling.

Procedures always use static dispatch. Multi-methods use dynamic
dispatch. For dynamic dispatch to work on an object it should be a
reference type.

\begin{verbatim}
method eval(e: Expression): int {.base.} =
  # override this base method
  raise newException(CatchableError, "Method without implementation override")

method eval(e: Literal): int = return e.x

method eval(e: PlusExpr): int =
  # watch out: relies on dynamic binding
  result = eval(e.a) + eval(e.b)

proc newLit(x: int): Literal =
  new(result)
  result.x = x

proc newPlus(a, b: Expression): PlusExpr =
  new(result)
  result.a = a
  result.b = b

echo eval(newPlus(newPlus(newLit(1), newLit(2)), newLit(4)))
\end{verbatim}

In the example the constructors \texttt{newLit} and \texttt{newPlus} are
procs because they should use static binding, but \texttt{eval} is a
method because it requires dynamic binding.

As can be seen in the example, base methods have to be annotated with
the \texttt{base} pragma. The \texttt{base} pragma also acts as a
reminder for the programmer that a base method \texttt{m} is used as the
foundation to determine all the effects that a call to \texttt{m} might
cause.

\textbf{Note}: Compile-time execution is not (yet) supported for
methods.

\textbf{Note}: Starting from Nim 0.20, generic methods are deprecated.

\hypertarget{inhibit-dynamic-method-resolution-via-proccall}{%
\subsubsection{Inhibit dynamic method resolution via
procCall}\label{inhibit-dynamic-method-resolution-via-proccall}}

Dynamic method resolution can be inhibited via the builtin
\texttt{system.procCall}. This is somewhat comparable to the
\texttt{super} keyword that traditional OOP languages offer.

\begin{verbatim}
type
  Thing = ref object of RootObj
  Unit = ref object of Thing
    x: int

method m(a: Thing) {.base.} =
  echo "base"

method m(a: Unit) =
  # Call the base method:
  procCall m(Thing(a))
  echo "1"
\end{verbatim}

\hypertarget{iterators-and-the-for-statement}{%
\subsection{Iterators and the for
statement}\label{iterators-and-the-for-statement}}

The \texttt{for} statement is an abstract mechanism to iterate over the
elements of a container. It relies on an \texttt{iterator} to do so.
Like \texttt{while} statements, \texttt{for} statements open an
\texttt{implicit\ block}, so that they can be left with a \texttt{break}
statement.

The \texttt{for} loop declares iteration variables - their scope reaches
until the end of the loop body. The iteration variables' types are
inferred by the return type of the iterator.

An iterator is similar to a procedure, except that it can be called in
the context of a \texttt{for} loop. Iterators provide a way to specify
the iteration over an abstract type. A key role in the execution of a
\texttt{for} loop plays the \texttt{yield} statement in the called
iterator. Whenever a \texttt{yield} statement is reached the data is
bound to the \texttt{for} loop variables and control continues in the
body of the \texttt{for} loop. The iterator's local variables and
execution state are automatically saved between calls. Example:

\begin{verbatim}
for ch in items("hello world"): # `ch` is an iteration variable
  echo ch
\end{verbatim}

The compiler generates code as if the programmer would have written
this:

\begin{verbatim}
\end{verbatim}

If the iterator yields a tuple, there can be as many iteration variables
as there are components in the tuple. The i'th iteration variable's type
is the type of the i'th component. In other words, implicit tuple
unpacking in a for loop context is supported.

Implicit items/pairs invocations
-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

If the for loop expression \texttt{e} does not denote an iterator and
the for loop has exactly 1 variable, the for loop expression is
rewritten to \texttt{items(e)}; ie. an \texttt{items} iterator is
implicitly invoked:

\begin{verbatim}
\end{verbatim}

If the for loop has exactly 2 variables, a \texttt{pairs} iterator is
implicitly invoked.

Symbol lookup of the identifiers \texttt{items}/\texttt{pairs} is
performed after the rewriting step, so that all overloads of
\texttt{items}/\texttt{pairs} are taken into account.

\hypertarget{first-class-iterators}{%
\subsubsection{First class iterators}\label{first-class-iterators}}

There are 2 kinds of iterators in Nim: \emph{inline} and \emph{closure}
iterators. An \texttt{inline\ iterator} is an iterator that's always
inlined by the compiler leading to zero overhead for the abstraction,
but may result in a heavy increase in code size.

Caution: the body of a for loop over an inline iterator is inlined into
each \texttt{yield} statement appearing in the iterator code, so ideally
the code should be refactored to contain a single yield when possible to
avoid code bloat.

Inline iterators are second class citizens; They can be passed as
parameters only to other inlining code facilities like templates, macros
and other inline iterators.

In contrast to that, a \texttt{closure\ iterator} can be passed around
more freely:

\begin{verbatim}
iterator count2(): int {.closure.} =
  var x = 1
  yield x
  inc x
  yield x

proc invoke(iter: iterator(): int {.closure.}) =
  for x in iter(): echo x

invoke(count0)
invoke(count2)
\end{verbatim}

Closure iterators and inline iterators have some restrictions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  For now, a closure iterator cannot be executed at compile time.
\item
  \texttt{return} is allowed in a closure iterator but not in an inline
  iterator (but rarely useful) and ends the iteration.
\item
  Neither inline nor closure iterators can be recursive.
\item
  Neither inline nor closure iterators have the special \texttt{result}
  variable.
\item
  Closure iterators are not supported by the js backend.
\end{enumerate}

Iterators that are neither marked \texttt{\{.closure.\}} nor
\texttt{\{.inline.\}} explicitly default to being inline, but this may
change in future versions of the implementation.

The \texttt{iterator} type is always of the calling convention
\texttt{closure} implicitly; the following example shows how to use
iterators to implement a \texttt{collaborative\ tasking} system:

\begin{verbatim}
iterator a1(ticker: int) {.closure.} =
  echo "a1: A"
  yield
  echo "a1: B"
  yield
  echo "a1: C"
  yield
  echo "a1: D"

iterator a2(ticker: int) {.closure.} =
  echo "a2: A"
  yield
  echo "a2: B"
  yield
  echo "a2: C"

proc runTasks(t: varargs[Task]) =
  var ticker = 0
  while true:
    let x = t[ticker mod t.len]
    if finished(x): break
    x(ticker)
    inc ticker

runTasks(a1, a2)
\end{verbatim}

The builtin \texttt{system.finished} can be used to determine if an
iterator has finished its operation; no exception is raised on an
attempt to invoke an iterator that has already finished its work.

Note that \texttt{system.finished} is error prone to use because it only
returns \texttt{true} one iteration after the iterator has finished:

\begin{verbatim}
var c = mycount # instantiate the iterator
while not finished(c):
  echo c(1, 3)

# Produces
1
2
3
0
\end{verbatim}

Instead this code has to be used:

\begin{verbatim}
\end{verbatim}

It helps to think that the iterator actually returns a pair
\texttt{(value,\ done)} and \texttt{finished} is used to access the
hidden \texttt{done} field.

Closure iterators are \emph{resumable functions} and so one has to
provide the arguments to every call. To get around this limitation one
can capture parameters of an outer factory proc:

\begin{verbatim}
let foo = mycount(1, 4)

for f in foo():
  echo f
\end{verbatim}

\hypertarget{converters}{%
\subsection{Converters}\label{converters}}

A converter is like an ordinary proc except that it enhances the
"implicitly convertible" type relation (see
\protect\hyperlink{convertible-relation}{Convertible relation}):

\begin{verbatim}
if 4:
  echo "compiles"
\end{verbatim}

A converter can also be explicitly invoked for improved readability.
Note that implicit converter chaining is not supported: If there is a
converter from type A to type B and from type B to type C the implicit
conversion from A to C is not provided.

\hypertarget{type-sections}{%
\subsection{Type sections}\label{type-sections}}

Example:

\begin{verbatim}
Sym = object       # a symbol
  name: string     # the symbol's name
  line: int        # the line the symbol was declared in
  code: Node       # the symbol's abstract syntax tree
\end{verbatim}

A type section begins with the \texttt{type} keyword. It contains
multiple type definitions. A type definition binds a type to a name.
Type definitions can be recursive or even mutually recursive. Mutually
recursive types are only possible within a single \texttt{type} section.
Nominal types like \texttt{objects} or \texttt{enums} can only be
defined in a \texttt{type} section.

\hypertarget{exception-handling}{%
\subsection{Exception handling}\label{exception-handling}}

\hypertarget{try-statement}{%
\subsubsection{Try statement}\label{try-statement}}

Example:

\begin{verbatim}
\end{verbatim}

The statements after the \texttt{try} are executed in sequential order
unless an exception \texttt{e} is raised. If the exception type of
\texttt{e} matches any listed in an \texttt{except} clause the
corresponding statements are executed. The statements following the
\texttt{except} clauses are called \texttt{exception\ handlers}.

The empty \texttt{except} clause is executed if there is an exception
that is not listed otherwise. It is similar to an \texttt{else} clause
in \texttt{if} statements.

If there is a \texttt{finally} clause, it is always executed after the
exception handlers.

The exception is \emph{consumed} in an exception handler. However, an
exception handler may raise another exception. If the exception is not
handled, it is propagated through the call stack. This means that often
the rest of the procedure - that is not within a \texttt{finally} clause
-is not executed (if an exception occurs).

\hypertarget{try-expression}{%
\subsubsection{Try expression}\label{try-expression}}

Try can also be used as an expression; the type of the \texttt{try}
branch then needs to fit the types of \texttt{except} branches, but the
type of the \texttt{finally} branch always has to be \texttt{void}:

\begin{verbatim}
let x = try: parseInt("133a")
        except: -1
        finally: echo "hi"
\end{verbatim}

To prevent confusing code there is a parsing limitation; if the
\texttt{try} follows a \texttt{(} it has to be written as a one liner:

\begin{verbatim}
\end{verbatim}

\hypertarget{except-clauses}{%
\subsubsection{Except clauses}\label{except-clauses}}

Within an \texttt{except} clause it is possible to access the current
exception using the following syntax:

\begin{verbatim}
\end{verbatim}

Alternatively, it is possible to use \texttt{getCurrentException} to
retrieve the exception that has been raised:

\begin{verbatim}
\end{verbatim}

Note that \texttt{getCurrentException} always returns a
\texttt{ref\ Exception} type. If a variable of the proper type is needed
(in the example above, \texttt{IOError}), one must convert it
explicitly:

\begin{verbatim}
\end{verbatim}

However, this is seldom needed. The most common case is to extract an
error message from \texttt{e}, and for such situations it is enough to
use \texttt{getCurrentExceptionMsg}:

\begin{verbatim}
\end{verbatim}

\hypertarget{custom-exceptions}{%
\subsubsection{Custom exceptions}\label{custom-exceptions}}

Is it possible to create custom exceptions. A custom exception is a
custom type:

\begin{verbatim}
\end{verbatim}

Ending the custom exception's name with \texttt{Error} is recommended.

Custom exceptions can be raised like any others, e.g.:

\begin{verbatim}
\end{verbatim}

\hypertarget{defer-statement}{%
\subsubsection{Defer statement}\label{defer-statement}}

Instead of a \texttt{try\ finally} statement a \texttt{defer} statement
can be used.

Any statements following the \texttt{defer} in the current block will be
considered to be in an implicit try block:

\begin{verbatim}
proc main =
  var f = open("numbers.txt")
  defer: close(f)
  f.write "abc"
  f.write "def"
\end{verbatim}

Is rewritten to:

\begin{verbatim}
proc main =
  var f = open("numbers.txt")
  try:
    f.write "abc"
    f.write "def"
  finally:
    close(f)
\end{verbatim}

Top level \texttt{defer} statements are not supported since it's unclear
what such a statement should refer to.

\hypertarget{raise-statement}{%
\subsubsection{Raise statement}\label{raise-statement}}

Example:

\begin{verbatim}
\end{verbatim}

Apart from built-in operations like array indexing, memory allocation,
etc. the \texttt{raise} statement is the only way to raise an exception.

If no exception name is given, the current exception is
\texttt{re-raised}. The \texttt{ReraiseDefect} exception is raised if
there is no exception to re-raise. It follows that the \texttt{raise}
statement \emph{always} raises an exception.

\hypertarget{exception-hierarchy}{%
\subsubsection{Exception hierarchy}\label{exception-hierarchy}}

The exception tree is defined in the \href{system.html}{system} module.
Every exception inherits from \texttt{system.Exception}. Exceptions that
indicate programming bugs inherit from \texttt{system.Defect} (which is
a subtype of \texttt{Exception}) and are strictly speaking not catchable
as they can also be mapped to an operation that terminates the whole
process. If panics are turned into exceptions, these exceptions inherit
from {Defect}.

Exceptions that indicate any other runtime error that can be caught
inherit from \texttt{system.CatchableError} (which is a subtype of
\texttt{Exception}).

\hypertarget{imported-exceptions}{%
\subsubsection{Imported exceptions}\label{imported-exceptions}}

It is possible to raise/catch imported C++ exceptions. Types imported
using {importcpp} can be raised or caught. Exceptions are raised by
value and caught by reference. Example:

\begin{verbatim}
type
  CStdException {.importcpp: "std::exception", header: "<exception>", inheritable.} = object
    ## does not inherit from `RootObj`, so we use `inheritable` instead
  CRuntimeError {.requiresInit, importcpp: "std::runtime_error", header: "<stdexcept>".} = object of CStdException
    ## `CRuntimeError` has no default constructor => `requiresInit`
proc what(s: CStdException): cstring {.importcpp: "((char *)#.what())".}
proc initRuntimeError(a: cstring): CRuntimeError {.importcpp: "std::runtime_error(@)", constructor.}
proc initStdException(): CStdException {.importcpp: "std::exception()", constructor.}

proc fn() =
  let a = initRuntimeError("foo")
  doAssert $a.what == "foo"
  var b: cstring
  try: raise initRuntimeError("foo2")
  except CStdException as e:
    doAssert e is CStdException
    b = e.what()
  doAssert $b == "foo2"

  try: raise initStdException()
  except CStdException: discard

  try: raise initRuntimeError("foo3")
  except CRuntimeError as e:
    b = e.what()
  except CStdException:
    doAssert false
  doAssert $b == "foo3"

fn()
\end{verbatim}

\textbf{Note:} {getCurrentException()} and {getCurrentExceptionMsg()}
are not available for imported exceptions from C++. One needs to use the
{except ImportedException as x:} syntax and rely on functionality of the
{x} object to get exception details.

\hypertarget{effect-system}{%
\subsection{Effect system}\label{effect-system}}

\hypertarget{exception-tracking}{%
\subsubsection{Exception tracking}\label{exception-tracking}}

Nim supports exception tracking. The \texttt{raises} pragma can be used
to explicitly define which exceptions a proc/iterator/method/converter
is allowed to raise. The compiler verifies this:

\begin{verbatim}
proc p(what: bool) {.raises: [IOError, OSError].} =
  if what: raise newException(IOError, "IO")
  else: raise newException(OSError, "OS")
\end{verbatim}

An empty \texttt{raises} list (\texttt{raises:\ {[}{]}}) means that no
exception may be raised:

\begin{verbatim}
\end{verbatim}

A \texttt{raises} list can also be attached to a proc type. This affects
type compatibility:

\begin{verbatim}
type
  Callback = proc (s: string) {.raises: [IOError].}
var
  c: Callback

proc p(x: string) =
  raise newException(OSError, "OS")

c = p # type error
\end{verbatim}

For a routine \texttt{p} the compiler uses inference rules to determine
the set of possibly raised exceptions; the algorithm operates on
\texttt{p}'s call graph:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Every indirect call via some proc type \texttt{T} is assumed to raise
  \texttt{system.Exception} (the base type of the exception hierarchy)
  and thus any exception unless \texttt{T} has an explicit
  \texttt{raises} list. However if the call is of the form
  \texttt{f(...)} where \texttt{f} is a parameter of the currently
  analysed routine it is ignored. The call is optimistically assumed to
  have no effect. Rule 2 compensates for this case.
\item
  Every expression of some proc type within a call that is not a call
  itself (and not nil) is assumed to be called indirectly somehow and
  thus its raises list is added to \texttt{p}'s raises list.
\item
  Every call to a proc \texttt{q} which has an unknown body (due to a
  forward declaration or an \texttt{importc} pragma) is assumed to raise
  \texttt{system.Exception} unless \texttt{q} has an explicit
  \texttt{raises} list.
\item
  Every call to a method \texttt{m} is assumed to raise
  \texttt{system.Exception} unless \texttt{m} has an explicit
  \texttt{raises} list.
\item
  For every other call the analysis can determine an exact
  \texttt{raises} list.
\item
  For determining a \texttt{raises} list, the \texttt{raise} and
  \texttt{try} statements of \texttt{p} are taken into consideration.
\end{enumerate}

Rules 1-2 ensure the following works:

\begin{verbatim}
proc doRaise() {.raises: [IOError].} =
  raise newException(IOError, "IO")

proc use() {.raises: [].} =
  # doesn't compile! Can raise IOError!
  noRaise(doRaise)
\end{verbatim}

So in many cases a callback does not cause the compiler to be overly
conservative in its effect analysis.

Exceptions inheriting from \texttt{system.Defect} are not tracked with
the \texttt{.raises:\ {[}{]}} exception tracking mechanism. This is more
consistent with the built-in operations. The following code is valid:

\begin{verbatim}
.. code-block:: nim
\end{verbatim}

\begin{quote}
\begin{description}
\item[proc mydiv(a, b): int \{.raises: {[}{]}.\} =]
a div b \# can raise an DivByZeroDefect
\end{description}
\end{quote}

And so is:

\begin{verbatim}
.. code-block:: nim
\end{verbatim}

\begin{quote}
\begin{description}
\item[proc mydiv(a, b): int \{.raises: {[}{]}.\} =]
if b == 0: raise newException(DivByZeroDefect, "division by zero") else:
result = a div b
\end{description}
\end{quote}

The reason for this is that \texttt{DivByZeroDefect} inherits from
\texttt{Defect} and with \texttt{-\/-panics:on} Defects become
unrecoverable errors. (Since version 1.4 of the language.)

\hypertarget{tag-tracking}{%
\subsubsection{Tag tracking}\label{tag-tracking}}

The exception tracking is part of Nim's \texttt{effect\ system}. Raising
an exception is an \emph{effect}. Other effects can also be defined. A
user defined effect is a means to \emph{tag} a routine and to perform
checks against this tag:

\begin{verbatim}
type IO = object ## input/output effect
proc readLine(): string {.tags: [IO].} = discard

proc no_IO_please() {.tags: [].} =
  # the compiler prevents this:
  let x = readLine()
\end{verbatim}

A tag has to be a type name. A \texttt{tags} list - like a
\texttt{raises} list - can also be attached to a proc type. This affects
type compatibility.

The inference for tag tracking is analogous to the inference for
exception tracking.

\hypertarget{effects-pragma}{%
\subsubsection{Effects pragma}\label{effects-pragma}}

The \texttt{effects} pragma has been designed to assist the programmer
with the effects analysis. It is a statement that makes the compiler
output all inferred effects up to the \texttt{effects}'s position:

\begin{verbatim}
\end{verbatim}

The compiler produces a hint message that \texttt{IOError} can be
raised. \texttt{OSError} is not listed as it cannot be raised in the
branch the \texttt{effects} pragma appears in.

\hypertarget{generics}{%
\subsection{Generics}\label{generics}}

Generics are Nim's means to parametrize procs, iterators or types with
\texttt{type\ parameters}. Depending on context, the brackets are used
either to introduce type parameters or to instantiate a generic proc,
iterator or type.

The following example shows a generic binary tree can be modelled:

\begin{verbatim}
type
  BinaryTree*[T] = ref object # BinaryTree is a generic type with
                              # generic param ``T``
    le, ri: BinaryTree[T]     # left and right subtrees; may be nil
    data: T                   # the data stored in a node

proc newNode*[T](data: T): BinaryTree[T] =
  # constructor for a node
  result = BinaryTree[T](le: nil, ri: nil, data: data)

proc add*[T](root: var BinaryTree[T], n: BinaryTree[T]) =
  # insert a node into the tree
  if root == nil:
    root = n
  else:
    var it = root
    while it != nil:
      # compare the data items; uses the generic ``cmp`` proc
      # that works for any type that has a ``==`` and ``<`` operator
      var c = cmp(it.data, n.data)
      if c < 0:
        if it.le == nil:
          it.le = n
          return
        it = it.le
      else:
        if it.ri == nil:
          it.ri = n
          return
        it = it.ri

proc add*[T](root: var BinaryTree[T], data: T) =
  # convenience proc:
  add(root, newNode(data))

iterator preorder*[T](root: BinaryTree[T]): T =
  # Preorder traversal of a binary tree.
  # Since recursive iterators are not yet implemented,
  # this uses an explicit stack (which is more efficient anyway):
  var stack: seq[BinaryTree[T]] = @[root]
  while stack.len > 0:
    var n = stack.pop()
    while n != nil:
      yield n.data
      add(stack, n.ri)  # push right subtree onto the stack
      n = n.le          # and follow the left pointer

var
  root: BinaryTree[string] # instantiate a BinaryTree with ``string``
add(root, newNode("hello")) # instantiates ``newNode`` and ``add``
add(root, "world")          # instantiates the second ``add`` proc
for str in preorder(root):
  stdout.writeLine(str)
\end{verbatim}

The \texttt{T} is called a \texttt{generic\ type\ parameter} or a
\texttt{type\ variable}.

\hypertarget{is-operator}{%
\subsubsection{Is operator}\label{is-operator}}

The \texttt{is} operator is evaluated during semantic analysis to check
for type equivalence. It is therefore very useful for type
specialization within generic code:

\begin{verbatim}
\end{verbatim}

\hypertarget{type-classes}{%
\subsubsection{Type Classes}\label{type-classes}}

A type class is a special pseudo-type that can be used to match against
types in the context of overload resolution or the \texttt{is} operator.
Nim supports the following built-in type classes:

\begin{longtable}[]{@{}ll@{}}
\toprule
type class & matches\tabularnewline
\midrule
\endhead
\texttt{object} & any object type\tabularnewline
\texttt{tuple} & any tuple type\tabularnewline
\texttt{enum} & any enumeration\tabularnewline
\texttt{proc} & any proc type\tabularnewline
\texttt{ref} & any \texttt{ref} type\tabularnewline
\texttt{ptr} & any \texttt{ptr} type\tabularnewline
\texttt{var} & any \texttt{var} type\tabularnewline
\texttt{distinct} & any distinct type\tabularnewline
\texttt{array} & any array type\tabularnewline
\texttt{set} & any set type\tabularnewline
\texttt{seq} & any seq type\tabularnewline
\texttt{auto} & any type\tabularnewline
\texttt{any} & distinct auto (see below)\tabularnewline
\bottomrule
\end{longtable}

Furthermore, every generic type automatically creates a type class of
the same name that will match any instantiation of the generic type.

Type classes can be combined using the standard boolean operators to
form more complex type classes:

\begin{verbatim}
proc printFields[T: RecordType](rec: T) =
  for key, value in fieldPairs(rec):
    echo key, " = ", value
\end{verbatim}

Whilst the syntax of type classes appears to resemble that of
ADTs/algebraic data types in ML-like languages, it should be understood
that type classes are static constraints to be enforced at type
instantiations. Type classes are not really types in themselves, but are
instead a system of providing generic "checks" that ultimately
\emph{resolve} to some singular type. Type classes do not allow for
runtime type dynamism, unlike object variants or methods.

As an example, the following would not compile:

\begin{verbatim}
\end{verbatim}

Nim allows for type classes and regular types to be specified as
\texttt{type\ constraints} of the generic type parameter:

\begin{verbatim}
onlyIntOrString(450, 616) # valid
onlyIntOrString(5.0, 0.0) # type mismatch
onlyIntOrString("xy", 50) # invalid as 'T' cannot be both at the same time
\end{verbatim}

\hypertarget{implicit-generics}{%
\subsubsection{Implicit generics}\label{implicit-generics}}

A type class can be used directly as the parameter's type.

\begin{verbatim}
# create a type class that will match all tuple and object types
type RecordType = tuple or object

proc printFields(rec: RecordType) =
  for key, value in fieldPairs(rec):
    echo key, " = ", value
\end{verbatim}

Procedures utilizing type classes in such manner are considered to be
\texttt{implicitly\ generic}. They will be instantiated once for each
unique combination of param types used within the program.

By default, during overload resolution each named type class will bind
to exactly one concrete type. We call such type classes
\texttt{bind\ once} types. Here is an example taken directly from the
system module to illustrate this:

\begin{verbatim}
\end{verbatim}

Alternatively, the \texttt{distinct} type modifier can be applied to the
type class to allow each param matching the type class to bind to a
different type. Such type classes are called \texttt{bind\ many} types.

Procs written with the implicitly generic style will often need to refer
to the type parameters of the matched generic type. They can be easily
accessed using the dot syntax:

\begin{verbatim}
proc `[]`(m: Matrix, row, col: int): Matrix.T =
  m.data[col * high(Matrix.Columns) + row]
\end{verbatim}

Here are more examples that illustrate implicit generics:

\begin{verbatim}
proc p(t: Table; k: Table.Key): Table.Value

# is roughly the same as:

proc p[Key, Value](t: Table[Key, Value]; k: Key): Value
\end{verbatim}

\begin{verbatim}
proc p(a: Table, b: Table)

# is roughly the same as:

proc p[Key, Value](a, b: Table[Key, Value])
\end{verbatim}

\begin{verbatim}
proc p(a: Table, b: distinct Table)

# is roughly the same as:

proc p[Key, Value, KeyB, ValueB](a: Table[Key, Value], b: Table[KeyB, ValueB])
\end{verbatim}

{typedesc} used as a parameter type also introduces an implicit generic.
{typedesc} has its own set of rules:

\begin{verbatim}
proc p(a: typedesc)

# is roughly the same as:

proc p[T](a: typedesc[T])
\end{verbatim}

{typedesc} is a "bind many" type class:

\begin{verbatim}
proc p(a, b: typedesc)

# is roughly the same as:

proc p[T, T2](a: typedesc[T], b: typedesc[T2])
\end{verbatim}

A parameter of type {typedesc} is itself usable as a type. If it is used
as a type, it's the underlying type. (In other words, one level of
"typedesc"-ness is stripped off:

\begin{verbatim}
proc p(a: typedesc; b: a) = discard

# is roughly the same as:
proc p[T](a: typedesc[T]; b: T) = discard

# hence this is a valid call:
p(int, 4)
# as parameter 'a' requires a type, but 'b' requires a value.
\end{verbatim}

\hypertarget{generic-inference-restrictions}{%
\subsubsection{Generic inference
restrictions}\label{generic-inference-restrictions}}

The types \texttt{var\ T}, \texttt{out\ T} and \texttt{typedesc{[}T{]}}
cannot be inferred in a generic instantiation. The following is not
allowed:

\begin{verbatim}
proc g[T](f: proc(x: T); x: T) =
  f(x)

proc c(y: int) = echo y
proc v(y: var int) =
  y += 100
var i: int

# allowed: infers 'T' to be of type 'int'
g(c, 42)

# not valid: 'T' is not inferred to be of type 'var int'
g(v, i)

# also not allowed: explicit instantiation via 'var int'
g[var int](v, i)
\end{verbatim}

\hypertarget{symbol-lookup-in-generics}{%
\subsubsection{Symbol lookup in
generics}\label{symbol-lookup-in-generics}}

\hypertarget{open-and-closed-symbols}{%
\paragraph{Open and Closed symbols}\label{open-and-closed-symbols}}

The symbol binding rules in generics are slightly subtle: There are
"open" and "closed" symbols. A "closed" symbol cannot be re-bound in the
instantiation context, an "open" symbol can. Per default overloaded
symbols are open and every other symbol is closed.

Open symbols are looked up in two different contexts: Both the context
at definition and the context at instantiation are considered:

\begin{verbatim}
type
  Index = distinct int

proc `==` (a, b: Index): bool {.borrow.}

var a = (0, 0.Index)
var b = (0, 0.Index)

echo a == b # works!
\end{verbatim}

In the example the generic \texttt{==} for tuples (as defined in the
system module) uses the \texttt{==} operators of the tuple's components.
However, the \texttt{==} for the \texttt{Index} type is defined
\emph{after} the \texttt{==} for tuples; yet the example compiles as the
instantiation takes the currently defined symbols into account too.

\hypertarget{mixin-statement}{%
\subsubsection{Mixin statement}\label{mixin-statement}}

A symbol can be forced to be open by a \texttt{mixin} declaration:

\begin{verbatim}
proc create*[T](): ref T =
  # there is no overloaded 'init' here, so we need to state that it's an
  # open symbol explicitly:
  mixin init
  new result
  init result
\end{verbatim}

\texttt{mixin} statements only make sense in templates and generics.

\hypertarget{bind-statement}{%
\subsubsection{Bind statement}\label{bind-statement}}

The \texttt{bind} statement is the counterpart to the \texttt{mixin}
statement. It can be used to explicitly declare identifiers that should
be bound early (i.e. the identifiers should be looked up in the scope of
the template/generic definition):

\begin{verbatim}
template genId*: untyped =
  bind lastId
  inc(lastId)
  lastId
\end{verbatim}

\begin{verbatim}
echo genId()
\end{verbatim}

But a \texttt{bind} is rarely useful because symbol binding from the
definition scope is the default.

\texttt{bind} statements only make sense in templates and generics.

\hypertarget{templates}{%
\subsection{Templates}\label{templates}}

A template is a simple form of a macro: It is a simple substitution
mechanism that operates on Nim's abstract syntax trees. It is processed
in the semantic pass of the compiler.

The syntax to \emph{invoke} a template is the same as calling a
procedure.

Example:

\begin{verbatim}
assert(5 != 6) # the compiler rewrites that to: assert(not (5 == 6))
\end{verbatim}

The \texttt{!=}, \texttt{\textgreater{}}, \texttt{\textgreater{}=},
\texttt{in}, \texttt{notin}, \texttt{isnot} operators are in fact
templates:

\texttt{a\ \textgreater{}\ b} is transformed into
\texttt{b\ \textless{}\ a}.\\
\texttt{a\ in\ b} is transformed into \texttt{contains(b,\ a)}.\\
\texttt{notin} and \texttt{isnot} have the obvious meanings.

The "types" of templates can be the symbols \texttt{untyped},
\texttt{typed} or \texttt{typedesc}. These are "meta types", they can
only be used in certain contexts. Regular types can be used too; this
implies that \texttt{typed} expressions are expected.

\hypertarget{typed-vs-untyped-parameters}{%
\subsubsection{Typed vs untyped
parameters}\label{typed-vs-untyped-parameters}}

An \texttt{untyped} parameter means that symbol lookups and type
resolution is not performed before the expression is passed to the
template. This means that for example \emph{undeclared} identifiers can
be passed to the template:

\begin{verbatim}
template declareInt(x: untyped) =
  var x: int

declareInt(x) # valid
x = 3
\end{verbatim}

\begin{verbatim}
template declareInt(x: typed) =
  var x: int

declareInt(x) # invalid, because x has not been declared and so has no type
\end{verbatim}

A template where every parameter is \texttt{untyped} is called an
\texttt{immediate} template. For historical reasons templates can be
explicitly annotated with an \texttt{immediate} pragma and then these
templates do not take part in overloading resolution and the parameters'
types are \emph{ignored} by the compiler. Explicit immediate templates
are now deprecated.

\textbf{Note}: For historical reasons \texttt{stmt} was an alias for
\texttt{typed} and \texttt{expr} was an alias for \texttt{untyped}, but
they are removed.

\hypertarget{passing-a-code-block-to-a-template}{%
\subsubsection{Passing a code block to a
template}\label{passing-a-code-block-to-a-template}}

One can pass a block of statements as the last argument to a template
following the special \texttt{:} syntax:

\begin{verbatim}
template withFile(f, fn, mode, actions: untyped): untyped =
  var f: File
  if open(f, fn, mode):
    try:
      actions
    finally:
      close(f)
  else:
    quit("cannot open: " & fn)

withFile(txt, "ttempl3.txt", fmWrite):  # special colon
  txt.writeLine("line 1")
  txt.writeLine("line 2")
\end{verbatim}

In the example, the two \texttt{writeLine} statements are bound to the
\texttt{actions} parameter.

Usually to pass a block of code to a template the parameter that accepts
the block needs to be of type \texttt{untyped}. Because symbol lookups
are then delayed until template instantiation time:

\begin{verbatim}
template t(body: typed) =
  block:
    body

t:
  var i = 1
  echo i

t:
  var i = 2  # fails with 'attempt to redeclare i'
  echo i
\end{verbatim}

The above code fails with the mysterious error message that \texttt{i}
has already been declared. The reason for this is that the
\texttt{var\ i\ =\ ...} bodies need to be type-checked before they are
passed to the \texttt{body} parameter and type checking in Nim implies
symbol lookups. For the symbol lookups to succeed \texttt{i} needs to be
added to the current (i.e. outer) scope. After type checking these
additions to the symbol table are not rolled back (for better or worse).
The same code works with \texttt{untyped} as the passed body is not
required to be type-checked:

\begin{verbatim}
template t(body: untyped) =
  block:
    body

t:
  var i = 1
  echo i

t:
  var i = 2  # compiles
  echo i
\end{verbatim}

\hypertarget{varargs-of-untyped}{%
\subsubsection{Varargs of untyped}\label{varargs-of-untyped}}

In addition to the \texttt{untyped} meta-type that prevents type
checking there is also \texttt{varargs{[}untyped{]}} so that not even
the number of parameters is fixed:

\begin{verbatim}
template hideIdentifiers(x: varargs[untyped]) = discard

hideIdentifiers(undeclared1, undeclared2)
\end{verbatim}

However, since a template cannot iterate over varargs, this feature is
generally much more useful for macros.

\hypertarget{symbol-binding-in-templates}{%
\subsubsection{Symbol binding in
templates}\label{symbol-binding-in-templates}}

A template is a \texttt{hygienic} macro and so opens a new scope. Most
symbols are bound from the definition scope of the template:

\begin{verbatim}
template genId*: untyped =
  inc(lastId)
  lastId
\end{verbatim}

\begin{verbatim}
echo genId() # Works as 'lastId' has been bound in 'genId's defining scope
\end{verbatim}

As in generics symbol binding can be influenced via \texttt{mixin} or
\texttt{bind} statements.

\hypertarget{identifier-construction}{%
\subsubsection{Identifier construction}\label{identifier-construction}}

In templates identifiers can be constructed with the backticks notation:

\begin{verbatim}
template typedef(name: untyped, typ: typedesc) =
  type
    `T name`* {.inject.} = typ
    `P name`* {.inject.} = ref `T name`

typedef(myint, int)
var x: PMyInt
\end{verbatim}

In the example \texttt{name} is instantiated with \texttt{myint}, so `T
name` becomes \texttt{Tmyint}.

\hypertarget{lookup-rules-for-template-parameters}{%
\subsubsection{Lookup rules for template
parameters}\label{lookup-rules-for-template-parameters}}

A parameter \texttt{p} in a template is even substituted in the
expression \texttt{x.p}. Thus template arguments can be used as field
names and a global symbol can be shadowed by the same argument name even
when fully qualified:

\begin{verbatim}
type
  Lev = enum
    levA, levB

var abclev = levB

template tstLev(abclev: Lev) =
  echo abclev, " ", m.abclev

tstLev(levA)
# produces: 'levA levA'
\end{verbatim}

But the global symbol can properly be captured by a \texttt{bind}
statement:

\begin{verbatim}
type
  Lev = enum
    levA, levB

var abclev = levB

template tstLev(abclev: Lev) =
  bind m.abclev
  echo abclev, " ", m.abclev

tstLev(levA)
# produces: 'levA levB'
\end{verbatim}

\hypertarget{hygiene-in-templates}{%
\subsubsection{Hygiene in templates}\label{hygiene-in-templates}}

Per default templates are \texttt{hygienic}: Local identifiers declared
in a template cannot be accessed in the instantiation context:

\begin{verbatim}
template newException*(exceptn: typedesc, message: string): untyped =
  var
    e: ref exceptn  # e is implicitly gensym'ed here
  new(e)
  e.msg = message
  e

# so this works:
let e = "message"
raise newException(IoError, e)
\end{verbatim}

Whether a symbol that is declared in a template is exposed to the
instantiation scope is controlled by the \texttt{inject} and
\texttt{gensym} pragmas: gensym'ed symbols are not exposed but inject'ed
are.

The default for symbols of entity \texttt{type}, \texttt{var},
\texttt{let} and \texttt{const} is \texttt{gensym} and for
\texttt{proc}, \texttt{iterator}, \texttt{converter}, \texttt{template},
\texttt{macro} is \texttt{inject}. However, if the name of the entity is
passed as a template parameter, it is an inject'ed symbol:

\begin{verbatim}
withFile(txt, "ttempl3.txt", fmWrite):
  txt.writeLine("line 1")
  txt.writeLine("line 2")
\end{verbatim}

The \texttt{inject} and \texttt{gensym} pragmas are second class
annotations; they have no semantics outside of a template definition and
cannot be abstracted over:

\begin{verbatim}
template t() =
  var x {.myInject.}: int # does NOT work
\end{verbatim}

To get rid of hygiene in templates, one can use the \texttt{dirty}
pragma for a template. \texttt{inject} and \texttt{gensym} have no
effect in \texttt{dirty} templates.

\texttt{gensym}'ed symbols cannot be used as \texttt{field} in the
\texttt{x.field} syntax. Nor can they be used in the
\texttt{ObjectConstruction(field:\ value)} and
\texttt{namedParameterCall(field\ =\ value)} syntactic constructs.

The reason for this is that code like

\begin{verbatim}
type
  T = object
    f: int

template tmp(x: T) =
  let f = 34
  echo x.f, T(f: 4)
\end{verbatim}

should work as expected.

However, this means that the method call syntax is not available for
\texttt{gensym}'ed symbols:

\begin{verbatim}
template tmp(x) =
  type
    T {.gensym.} = int

  echo x.T # invalid: instead use:  'echo T(x)'.

tmp(12)
\end{verbatim}

\textbf{Note}: The Nim compiler prior to version 1 was more lenient
about this requirement. Use the \texttt{-\/-useVersion:0.19} switch for
a transition period.

\hypertarget{limitations-of-the-method-call-syntax}{%
\subsubsection{Limitations of the method call
syntax}\label{limitations-of-the-method-call-syntax}}

The expression \texttt{x} in \texttt{x.f} needs to be semantically
checked (that means symbol lookup and type checking) before it can be
decided that it needs to be rewritten to \texttt{f(x)}. Therefore the
dot syntax has some limitations when it is used to invoke
templates/macros:

\begin{verbatim}
template declareVar(name: untyped) =
  const name {.inject.} = 45

# Doesn't compile:
unknownIdentifier.declareVar
\end{verbatim}

Another common example is this:

\begin{verbatim}
from sequtils import toSeq

iterator something: string =
  yield "Hello"
  yield "World"

var info = something().toSeq
\end{verbatim}

The problem here is that the compiler already decided that
\texttt{something()} as an iterator is not callable in this context
before \texttt{toSeq} gets its chance to convert it into a sequence.

It is also not possible to use fully qualified identifiers with module
symbol in method call syntax. The order in which the dot operator binds
to symbols prohibits this.

\begin{verbatim}
import sequtils

var myItems = @[1,3,3,7]
let N1 = count(myItems, 3) # OK
let N2 = sequtils.count(myItems, 3) # fully qualified, OK
let N3 = myItems.count(3) # OK
let N4 = myItems.sequtils.count(3) # illegal, `myItems.sequtils` can't be resolved
\end{verbatim}

This means that when for some reason a procedure needs a disambiguation
through the module name, the call needs to be written in function call
syntax.

\hypertarget{macros}{%
\subsection{Macros}\label{macros}}

A macro is a special function that is executed at compile time. Normally
the input for a macro is an abstract syntax tree (AST) of the code that
is passed to it. The macro can then do transformations on it and return
the transformed AST. This can be used to add custom language features
and implement \texttt{domain\ specific\ languages}.

Macro invocation is a case where semantic analysis does \textbf{not}
entirely proceed top to bottom and left to right. Instead, semantic
analysis happens at least twice:

\begin{itemize}
\tightlist
\item
  Semantic analysis recognizes and resolves the macro invocation.
\item
  The compiler executes the macro body (which may invoke other procs).
\item
  It replaces the AST of the macro invocation with the AST returned by
  the macro.
\item
  It repeats semantic analysis of that region of the code.
\item
  If the AST returned by the macro contains other macro invocations,
  this process iterates.
\end{itemize}

While macros enable advanced compile-time code transformations, they
cannot change Nim's syntax.

\hypertarget{debug-example}{%
\subsubsection{Debug Example}\label{debug-example}}

The following example implements a powerful \texttt{debug} command that
accepts a variable number of arguments:

\begin{verbatim}
# to work with Nim syntax trees, we need an API that is defined in the
# ``macros`` module:
import macros

macro debug(args: varargs[untyped]): untyped =
  # `args` is a collection of `NimNode` values that each contain the
  # AST for an argument of the macro. A macro always has to
  # return a `NimNode`. A node of kind `nnkStmtList` is suitable for
  # this use case.
  result = nnkStmtList.newTree()
  # iterate over any argument that is passed to this macro:
  for n in args:
    # add a call to the statement list that writes the expression;
    # `toStrLit` converts an AST to its string representation:
    result.add newCall("write", newIdentNode("stdout"), newLit(n.repr))
    # add a call to the statement list that writes ": "
    result.add newCall("write", newIdentNode("stdout"), newLit(": "))
    # add a call to the statement list that writes the expressions value:
    result.add newCall("writeLine", newIdentNode("stdout"), n)

var
  a: array[0..10, int]
  x = "some string"
a[0] = 42
a[1] = 45

debug(a[0], a[1], x)
\end{verbatim}

The macro call expands to:

\begin{verbatim}
write(stdout, "a[1]")
write(stdout, ": ")
writeLine(stdout, a[1])

write(stdout, "x")
write(stdout, ": ")
writeLine(stdout, x)
\end{verbatim}

Arguments that are passed to a \texttt{varargs} parameter are wrapped in
an array constructor expression. This is why \texttt{debug} iterates
over all of \texttt{n}'s children.

\hypertarget{bindsym}{%
\subsubsection{BindSym}\label{bindsym}}

The above \texttt{debug} macro relies on the fact that \texttt{write},
\texttt{writeLine} and \texttt{stdout} are declared in the system module
and thus visible in the instantiating context. There is a way to use
bound identifiers (aka \texttt{symbols}) instead of using unbound
identifiers. The \texttt{bindSym} builtin can be used for that:

\begin{verbatim}
import macros

macro debug(n: varargs[typed]): untyped =
  result = newNimNode(nnkStmtList, n)
  for x in n:
    # we can bind symbols in scope via 'bindSym':
    add(result, newCall(bindSym"write", bindSym"stdout", toStrLit(x)))
    add(result, newCall(bindSym"write", bindSym"stdout", newStrLitNode(": ")))
    add(result, newCall(bindSym"writeLine", bindSym"stdout", x))

var
  a: array[0..10, int]
  x = "some string"
a[0] = 42
a[1] = 45

debug(a[0], a[1], x)
\end{verbatim}

The macro call expands to:

\begin{verbatim}
write(stdout, "a[1]")
write(stdout, ": ")
writeLine(stdout, a[1])

write(stdout, "x")
write(stdout, ": ")
writeLine(stdout, x)
\end{verbatim}

However, the symbols \texttt{write}, \texttt{writeLine} and
\texttt{stdout} are already bound and are not looked up again. As the
example shows, \texttt{bindSym} does work with overloaded symbols
implicitly.

\hypertarget{case-of-macro}{%
\subsubsection{Case-Of Macro}\label{case-of-macro}}

In Nim it is possible to have a macro with the syntax of a
\emph{case-of} expression just with the difference that all of branches
are passed to and processed by the macro implementation. It is then up
the macro implementation to transform the \emph{of-branches} into a
valid Nim statement. The following example should show how this feature
could be used for a lexical analyzer.

\begin{verbatim}
macro case_token(args: varargs[untyped]): untyped =
  echo args.treeRepr
  # creates a lexical analyzer from regular expressions
  # ... (implementation is an exercise for the reader ;-)
  discard

case_token: # this colon tells the parser it is a macro statement
of r"[A-Za-z_]+[A-Za-z_0-9]*":
  return tkIdentifier
of r"0-9+":
  return tkInteger
of r"[\+\-\*\?]+":
  return tkOperator
else:
  return tkUnknown
\end{verbatim}

\textbf{Style note}: For code readability, it is the best idea to use
the least powerful programming construct that still suffices. So the
"check list" is:

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\tightlist
\item
  Use an ordinary proc/iterator, if possible.
\item
  Else: Use a generic proc/iterator, if possible.
\item
  Else: Use a template, if possible.
\item
  Else: Use a macro.
\end{enumerate}

\hypertarget{special-types}{%
\subsection{Special Types}\label{special-types}}

\hypertarget{statict}{%
\subsubsection{static{[}T{]}}\label{statict}}

As their name suggests, static parameters must be constant expressions:

\begin{verbatim}
proc precompiledRegex(pattern: static string): RegEx =
  var res {.global.} = re(pattern)
  return res

precompiledRegex("/d+") # Replaces the call with a precompiled
                        # regex, stored in a global variable

precompiledRegex(paramStr(1)) # Error, command-line options
                              # are not constant expressions
\end{verbatim}

For the purposes of code generation, all static params are treated as
generic params - the proc will be compiled separately for each unique
supplied value (or combination of values).

Static params can also appear in the signatures of generic types:

\begin{verbatim}
type
  Matrix[M,N: static int; T: Number] = array[0..(M*N - 1), T]
    # Note how `Number` is just a type constraint here, while
    # `static int` requires us to supply an int value

  AffineTransform2D[T] = Matrix[3, 3, T]
  AffineTransform3D[T] = Matrix[4, 4, T]

var m1: AffineTransform3D[float]  # OK
var m2: AffineTransform2D[string] # Error, `string` is not a `Number`
\end{verbatim}

Please note that \texttt{static\ T} is just a syntactic convenience for
the underlying generic type \texttt{static{[}T{]}}. The type param can
be omitted to obtain the type class of all constant expressions. A more
specific type class can be created by instantiating \texttt{static} with
another type class.

One can force an expression to be evaluated at compile time as a
constant expression by coercing it to a corresponding \texttt{static}
type:

\begin{verbatim}
echo static(fac(5)), " ", static[bool](16.isPowerOfTwo)
\end{verbatim}

The compiler will report any failure to evaluate the expression or a
possible type mismatch error.

\hypertarget{typedesct}{%
\subsubsection{typedesc{[}T{]}}\label{typedesct}}

In many contexts, Nim allows to treat the names of types as regular
values. These values exists only during the compilation phase, but since
all values must have a type, \texttt{typedesc} is considered their
special type.

\texttt{typedesc} acts like a generic type. For instance, the type of
the symbol \texttt{int} is \texttt{typedesc{[}int{]}}. Just like with
regular generic types, when the generic param is omitted,
\texttt{typedesc} denotes the type class of all types. As a syntactic
convenience, one can also use \texttt{typedesc} as a modifier.

Procs featuring \texttt{typedesc} params are considered implicitly
generic. They will be instantiated for each unique combination of
supplied types and within the body of the proc, the name of each param
will refer to the bound concrete type:

\begin{verbatim}
proc new(T: typedesc): ref T =
  echo "allocating ", T.name
  new(result)

var n = Node.new
var tree = new(BinaryTree[int])
\end{verbatim}

When multiple type params are present, they will bind freely to
different types. To force a bind-once behavior one can use an explicit
generic param:

\begin{verbatim}
\end{verbatim}

Once bound, type params can appear in the rest of the proc signature:

\begin{verbatim}
template declareVariableWithType(T: typedesc, value: T) =
  var x: T = value

declareVariableWithType int, 42
\end{verbatim}

Overload resolution can be further influenced by constraining the set of
types that will match the type param. This works in practice to
attaching attributes to types via templates. The constraint can be a
concrete type or a type class.

\begin{verbatim}
template maxval(T: typedesc[int]): int = high(int)
template maxval(T: typedesc[float]): float = Inf

var i = int.maxval
var f = float.maxval
when false:
  var s = string.maxval # error, maxval is not implemented for string

template isNumber(t: typedesc[object]): string = "Don't think so."
template isNumber(t: typedesc[SomeInteger]): string = "Yes!"
template isNumber(t: typedesc[SomeFloat]): string = "Maybe, could be NaN."

echo "is int a number? ", isNumber(int)
echo "is float a number? ", isNumber(float)
echo "is RootObj a number? ", isNumber(RootObj)
\end{verbatim}

Passing \texttt{typedesc} almost identical, just with the differences
that the macro is not instantiated generically. The type expression is
simply passed as a \texttt{NimNode} to the macro, like everything else.

\begin{verbatim}
import macros

macro forwardType(arg: typedesc): typedesc =
  # ``arg`` is of type ``NimNode``
  let tmp: NimNode = arg
  result = tmp

var tmp: forwardType(int)
\end{verbatim}

\hypertarget{typeof-operator}{%
\subsubsection{typeof operator}\label{typeof-operator}}

\textbf{Note}: \texttt{typeof(x)} can for historical reasons also be
written as \texttt{type(x)} but \texttt{type(x)} is discouraged.

One can obtain the type of a given expression by constructing a
\texttt{typeof} value from it (in many other languages this is known as
the \texttt{typeof} operator):

\begin{verbatim}
var x = 0
var y: typeof(x) # y has type int
\end{verbatim}

If \texttt{typeof} is used to determine the result type of a
proc/iterator/converter call \texttt{c(X)} (where \texttt{X} stands for
a possibly empty list of arguments), the interpretation where \texttt{c}
is an iterator is preferred over the other interpretations, but this
behavior can be changed by passing \texttt{typeOfProc} as the second
argument to \texttt{typeof}:

\begin{verbatim}
iterator split(s: string): string = discard
proc split(s: string): seq[string] = discard

# since an iterator is the preferred interpretation, `y` has the type ``string``:
assert typeof("a b c".split) is string

assert typeof("a b c".split, typeOfProc) is seq[string]
\end{verbatim}

\hypertarget{modules}{%
\subsection{Modules}\label{modules}}

Nim supports splitting a program into pieces by a module concept. Each
module needs to be in its own file and has its own \texttt{namespace}.
Modules enable \texttt{information\ hiding} and
\texttt{separate\ compilation}. A module may gain access to symbols of
another module by the \texttt{import} statement.
\texttt{Recursive\ module\ dependencies} are allowed, but slightly
subtle. Only top-level symbols that are marked with an asterisk
(\texttt{*}) are exported. A valid module name can only be a valid Nim
identifier (and thus its filename is \texttt{identifier.nim}).

The algorithm for compiling modules is:

\begin{itemize}
\tightlist
\item
  compile the whole module as usual, following import statements
  recursively
\item
  if there is a cycle only import the already parsed symbols (that are
  exported); if an unknown identifier occurs then abort
\end{itemize}

This is best illustrated by an example:

\begin{verbatim}
proc main() =
  var i = p(3) # works because B has been parsed completely here

main()
\end{verbatim}

\begin{verbatim}
proc p*(x: A.T1): A.T1 =
  # this works because the compiler has already
  # added T1 to A's interface symbol table
  result = x + 1
\end{verbatim}

\hypertarget{import-statement}{%
\paragraph{Import statement}\label{import-statement}}

After the \texttt{import} statement a list of module names can follow or
a single module name followed by an \texttt{except} list to prevent some
symbols to be imported:

\begin{verbatim}
import strutils except `%`, toUpperAscii

# doesn't work then:
echo "$1" % "abc".toUpperAscii
\end{verbatim}

It is not checked that the \texttt{except} list is really exported from
the module. This feature allows to compile against an older version of
the module that does not export these identifiers.

The \texttt{import} statement is only allowed at the top level.

\hypertarget{include-statement}{%
\paragraph{Include statement}\label{include-statement}}

The \texttt{include} statement does something fundamentally different
than importing a module: it merely includes the contents of a file. The
\texttt{include} statement is useful to split up a large module into
several files:

\begin{verbatim}
\end{verbatim}

The \texttt{include} statement can be used outside of the top level, as
such:

\begin{verbatim}
\end{verbatim}

\begin{verbatim}
main() # => Hello World!
\end{verbatim}

\hypertarget{module-names-in-imports}{%
\paragraph{Module names in imports}\label{module-names-in-imports}}

A module alias can be introduced via the \texttt{as} keyword:

\begin{verbatim}
echo su.format("$1", "lalelu")
\end{verbatim}

The original module name is then not accessible. The notations
\texttt{path/to/module} or \texttt{"path/to/module"} can be used to
refer to a module in subdirectories:

\begin{verbatim}
\end{verbatim}

Note that the module name is still \texttt{strutils} and not
\texttt{lib/pure/strutils} and so one \textbf{cannot} do:

\begin{verbatim}
\end{verbatim}

Likewise the following does not make sense as the name is
\texttt{strutils} already:

\begin{verbatim}
\end{verbatim}

\hypertarget{collective-imports-from-a-directory}{%
\paragraph{Collective imports from a
directory}\label{collective-imports-from-a-directory}}

The syntax \texttt{import\ dir\ /\ {[}moduleA,\ moduleB{]}} can be used
to import multiple modules from the same directory.

Path names are syntactically either Nim identifiers or string literals.
If the path name is not a valid Nim identifier it needs to be a string
literal:

\begin{verbatim}
\end{verbatim}

\hypertarget{pseudo-importinclude-paths}{%
\paragraph{Pseudo import/include
paths}\label{pseudo-importinclude-paths}}

A directory can also be a so called "pseudo directory". They can be used
to avoid ambiguity when there are multiple modules with the same path.

There are two pseudo directories:

1. \texttt{std}: The \texttt{std} pseudo directory is the abstract
location of Nim's standard library. For example, the syntax
\texttt{import\ std\ /\ strutils} is used to unambiguously refer to the
standard library's \texttt{strutils} module. 2. \texttt{pkg}: The
\texttt{pkg} pseudo directory is used to unambiguously refer to a Nimble
package. However, for technical details that lie outside of the scope of
this document its semantics are: \emph{Use the search path to look for
module name but ignore the standard library locations}. In other words,
it is the opposite of \texttt{std}.

\hypertarget{from-import-statement}{%
\paragraph{From import statement}\label{from-import-statement}}

After the \texttt{from} statement a module name follows followed by an
\texttt{import} to list the symbols one likes to use without explicit
full qualification:

\begin{verbatim}
from strutils import `%`

echo "$1" % "abc"
# always possible: full qualification:
echo strutils.replace("abc", "a", "z")
\end{verbatim}

It's also possible to use \texttt{from\ module\ import\ nil} if one
wants to import the module but wants to enforce fully qualified access
to every symbol in \texttt{module}.

\hypertarget{export-statement}{%
\paragraph{Export statement}\label{export-statement}}

An \texttt{export} statement can be used for symbol forwarding so that
client modules don't need to import a module's dependencies:

\begin{verbatim}
\end{verbatim}

\begin{verbatim}
proc `$`*(x: MyObject): string = "my object"
\end{verbatim}

\begin{verbatim}
# B.MyObject has been imported implicitly here:
var x: MyObject
echo $x
\end{verbatim}

When the exported symbol is another module, all of its definitions will
be forwarded. One can use an \texttt{except} list to exclude some of the
symbols.

Notice that when exporting, one needs to specify only the module name:

\begin{verbatim}
\end{verbatim}

\hypertarget{scope-rules}{%
\subsubsection{Scope rules}\label{scope-rules}}

Identifiers are valid from the point of their declaration until the end
of the block in which the declaration occurred. The range where the
identifier is known is the scope of the identifier. The exact scope of
an identifier depends on the way it was declared.

\hypertarget{block-scope}{%
\paragraph{Block scope}\label{block-scope}}

The \emph{scope} of a variable declared in the declaration part of a
block is valid from the point of declaration until the end of the block.
If a block contains a second block, in which the identifier is
redeclared, then inside this block, the second declaration will be
valid. Upon leaving the inner block, the first declaration is valid
again. An identifier cannot be redefined in the same block, except if
valid for procedure or iterator overloading purposes.

\hypertarget{tuple-or-object-scope}{%
\paragraph{Tuple or object scope}\label{tuple-or-object-scope}}

The field identifiers inside a tuple or object definition are valid in
the following places:

\begin{itemize}
\tightlist
\item
  To the end of the tuple/object definition.
\item
  Field designators of a variable of the given tuple/object type.
\item
  In all descendant types of the object type.
\end{itemize}

\hypertarget{module-scope}{%
\paragraph{Module scope}\label{module-scope}}

All identifiers of a module are valid from the point of declaration
until the end of the module. Identifiers from indirectly dependent
modules are \emph{not} available. The \texttt{system} module is
automatically imported in every module.

If a module imports an identifier by two different modules, each
occurrence of the identifier has to be qualified, unless it is an
overloaded procedure or iterator in which case the overloading
resolution takes place:

\begin{verbatim}
\end{verbatim}

\begin{verbatim}
\end{verbatim}

\begin{verbatim}
var x = 4
write(stdout, x) # not ambiguous: uses the module C's x
\end{verbatim}

\hypertarget{compiler-messages}{%
\subsection{Compiler Messages}\label{compiler-messages}}

The Nim compiler emits different kinds of messages: \texttt{hint},
\texttt{warning}, and \texttt{error} messages. An \emph{error} message
is emitted if the compiler encounters any static error.

\hypertarget{pragmas}{%
\subsection{Pragmas}\label{pragmas}}

Pragmas are Nim's method to give the compiler additional information /
commands without introducing a massive number of new keywords. Pragmas
are processed on the fly during semantic checking. Pragmas are enclosed
in the special \texttt{\{.} and \texttt{.\}} curly brackets. Pragmas are
also often used as a first implementation to play with a language
feature before a nicer syntax to access the feature becomes available.

\hypertarget{deprecated-pragma}{%
\subsubsection{deprecated pragma}\label{deprecated-pragma}}

The deprecated pragma is used to mark a symbol as deprecated:

\begin{verbatim}
\end{verbatim}

This pragma can also take in an optional warning string to relay to
developers.

\begin{verbatim}
\end{verbatim}

\hypertarget{nosideeffect-pragma}{%
\subsubsection{noSideEffect pragma}\label{nosideeffect-pragma}}

The \texttt{noSideEffect} pragma is used to mark a proc/iterator to have
no side effects. This means that the proc/iterator only changes
locations that are reachable from its parameters and the return value
only depends on the arguments. If none of its parameters have the type
\texttt{var\ T} or \texttt{out\ T} or \texttt{ref\ T} or \texttt{ptr\ T}
this means no locations are modified. It is a static error to mark a
proc/iterator to have no side effect if the compiler cannot verify this.

As a special semantic rule, the built-in
\href{system.html\#debugEcho,varargs\%5Btyped,\%5D}{debugEcho} pretends
to be free of side effects, so that it can be used for debugging
routines marked as \texttt{noSideEffect}.

\texttt{func} is syntactic sugar for a proc with no side effects:

\begin{verbatim}
\end{verbatim}

To override the compiler's side effect analysis a
\texttt{\{.noSideEffect.\}} pragma block can be used:

\begin{verbatim}
func f() =
  {.noSideEffect.}:
    echo "test"
\end{verbatim}

\hypertarget{compiletime-pragma}{%
\subsubsection{compileTime pragma}\label{compiletime-pragma}}

The \texttt{compileTime} pragma is used to mark a proc or variable to be
used only during compile-time execution. No code will be generated for
it. Compile-time procs are useful as helpers for macros. Since version
0.12.0 of the language, a proc that uses \texttt{system.NimNode} within
its parameter types is implicitly declared \texttt{compileTime}:

\begin{verbatim}
\end{verbatim}

Is the same as:

\begin{verbatim}
\end{verbatim}

\texttt{compileTime} variables are available at runtime too. This
simplifies certain idioms where variables are filled at compile-time
(for example, lookup tables) but accessed at runtime:

\begin{verbatim}
import macros

var nameToProc {.compileTime.}: seq[(string, proc (): string {.nimcall.})]

macro registerProc(p: untyped): untyped =
  result = newTree(nnkStmtList, p)

  let procName = p[0]
  let procNameAsStr = $p[0]
  result.add quote do:
    nameToProc.add((`procNameAsStr`, `procName`))

proc foo: string {.registerProc.} = "foo"
proc bar: string {.registerProc.} = "bar"
proc baz: string {.registerProc.} = "baz"

doAssert nameToProc[2][1]() == "baz"
\end{verbatim}

\hypertarget{noreturn-pragma}{%
\subsubsection{noReturn pragma}\label{noreturn-pragma}}

The \texttt{noreturn} pragma is used to mark a proc that never returns.

\hypertarget{acyclic-pragma}{%
\subsubsection{acyclic pragma}\label{acyclic-pragma}}

The \texttt{acyclic} pragma can be used for object types to mark them as
acyclic even though they seem to be cyclic. This is an
\textbf{optimization} for the garbage collector to not consider objects
of this type as part of a cycle:

\begin{verbatim}
\end{verbatim}

Or if we directly use a ref object:

\begin{verbatim}
\end{verbatim}

In the example a tree structure is declared with the \texttt{Node} type.
Note that the type definition is recursive and the GC has to assume that
objects of this type may form a cyclic graph. The \texttt{acyclic}
pragma passes the information that this cannot happen to the GC. If the
programmer uses the \texttt{acyclic} pragma for data types that are in
reality cyclic, the memory leaks can be the result, but memory safety is
preserved.

\hypertarget{final-pragma}{%
\subsubsection{final pragma}\label{final-pragma}}

The \texttt{final} pragma can be used for an object type to specify that
it cannot be inherited from. Note that inheritance is only available for
objects that inherit from an existing object (via the
\texttt{object\ of\ SuperType} syntax) or that have been marked as
\texttt{inheritable}.

\hypertarget{shallow-pragma}{%
\subsubsection{shallow pragma}\label{shallow-pragma}}

The \texttt{shallow} pragma affects the semantics of a type: The
compiler is allowed to make a shallow copy. This can cause serious
semantic issues and break memory safety! However, it can speed up
assignments considerably, because the semantics of Nim require deep
copying of sequences and strings. This can be expensive, especially if
sequences are used to build a tree structure:

\begin{verbatim}
\end{verbatim}

\hypertarget{pure-pragma}{%
\subsubsection{pure pragma}\label{pure-pragma}}

An object type can be marked with the \texttt{pure} pragma so that its
type field which is used for runtime type identification is omitted.
This used to be necessary for binary compatibility with other compiled
languages.

An enum type can be marked as \texttt{pure}. Then access of its fields
always requires full qualification.

\hypertarget{asmnostackframe-pragma}{%
\subsubsection{asmNoStackFrame pragma}\label{asmnostackframe-pragma}}

A proc can be marked with the \texttt{asmNoStackFrame} pragma to tell
the compiler it should not generate a stack frame for the proc. There
are also no exit statements like \texttt{return\ result;} generated and
the generated C function is declared as \texttt{\_\_declspec(naked)} or
\texttt{\_\_attribute\_\_((naked))} (depending on the used C compiler).

\textbf{Note}: This pragma should only be used by procs which consist
solely of assembler statements.

\hypertarget{error-pragma}{%
\subsubsection{error pragma}\label{error-pragma}}

The \texttt{error} pragma is used to make the compiler output an error
message with the given content. Compilation does not necessarily abort
after an error though.

The \texttt{error} pragma can also be used to annotate a symbol (like an
iterator or proc). The \emph{usage} of the symbol then triggers a static
error. This is especially useful to rule out that some operation is
valid due to overloading and type conversions:

\begin{verbatim}
\end{verbatim}

\hypertarget{fatal-pragma}{%
\subsubsection{fatal pragma}\label{fatal-pragma}}

The \texttt{fatal} pragma is used to make the compiler output an error
message with the given content. In contrast to the \texttt{error}
pragma, compilation is guaranteed to be aborted by this pragma. Example:

\begin{verbatim}
\end{verbatim}

\hypertarget{warning-pragma}{%
\subsubsection{warning pragma}\label{warning-pragma}}

The \texttt{warning} pragma is used to make the compiler output a
warning message with the given content. Compilation continues after the
warning.

\hypertarget{hint-pragma}{%
\subsubsection{hint pragma}\label{hint-pragma}}

The \texttt{hint} pragma is used to make the compiler output a hint
message with the given content. Compilation continues after the hint.

\hypertarget{line-pragma}{%
\subsubsection{line pragma}\label{line-pragma}}

The \texttt{line} pragma can be used to affect line information of the
annotated statement as seen in stack backtraces:

\begin{verbatim}
template myassert*(cond: untyped, msg = "") =
  if not cond:
    # change run-time line information of the 'raise' statement:
    {.line: instantiationInfo().}:
      raise newException(EAssertionFailed, msg)
\end{verbatim}

If the \texttt{line} pragma is used with a parameter, the parameter
needs be a \texttt{tuple{[}filename:\ string,\ line:\ int{]}}. If it is
used without a parameter, \texttt{system.InstantiationInfo()} is used.

\hypertarget{linearscanend-pragma}{%
\subsubsection{linearScanEnd pragma}\label{linearscanend-pragma}}

The \texttt{linearScanEnd} pragma can be used to tell the compiler how
to compile a Nim \texttt{case} statement. Syntactically it has to be
used as a statement:

\begin{verbatim}
\end{verbatim}

In the example, the case branches \texttt{0} and \texttt{1} are much
more common than the other cases. Therefore the generated assembler code
should test for these values first, so that the CPU's branch predictor
has a good chance to succeed (avoiding an expensive CPU pipeline stall).
The other cases might be put into a jump table for O(1) overhead, but at
the cost of a (very likely) pipeline stall.

The \texttt{linearScanEnd} pragma should be put into the last branch
that should be tested against via linear scanning. If put into the last
branch of the whole \texttt{case} statement, the whole \texttt{case}
statement uses linear scanning.

\hypertarget{computedgoto-pragma}{%
\subsubsection{computedGoto pragma}\label{computedgoto-pragma}}

The \texttt{computedGoto} pragma can be used to tell the compiler how to
compile a Nim \texttt{case} in a \texttt{while\ true} statement.
Syntactically it has to be used as a statement inside the loop:

\begin{verbatim}
type
  MyEnum = enum
    enumA, enumB, enumC, enumD, enumE

proc vm() =
  var instructions: array[0..100, MyEnum]
  instructions[2] = enumC
  instructions[3] = enumD
  instructions[4] = enumA
  instructions[5] = enumD
  instructions[6] = enumC
  instructions[7] = enumA
  instructions[8] = enumB

  instructions[12] = enumE
  var pc = 0
  while true:
    {.computedGoto.}
    let instr = instructions[pc]
    case instr
    of enumA:
      echo "yeah A"
    of enumC, enumD:
      echo "yeah CD"
    of enumB:
      echo "yeah B"
    of enumE:
      break
    inc(pc)

vm()
\end{verbatim}

As the example shows \texttt{computedGoto} is mostly useful for
interpreters. If the underlying backend (C compiler) does not support
the computed goto extension the pragma is simply ignored.

\hypertarget{immediate-pragma}{%
\subsubsection{immediate pragma}\label{immediate-pragma}}

The immediate pragma is obsolete. See
\protect\hyperlink{templates-typed-vs-untyped-parameters}{Typed vs
untyped parameters}.

\hypertarget{compilation-option-pragmas}{%
\subsubsection{compilation option
pragmas}\label{compilation-option-pragmas}}

The listed pragmas here can be used to override the code generation
options for a proc/method/converter.

The implementation currently provides the following possible options
(various others may be added later).

\begin{longtable}[]{@{}lll@{}}
\toprule
pragma & allowed values & description\tabularnewline
\midrule
\endhead
checks & on\textbar off & Turns the code generation for all runtime
checks on or off.\tabularnewline
boundChecks & on\textbar off & Turns the code generation for array bound
checks on or off.\tabularnewline
overflowChecks & on\textbar off & Turns the code generation for over- or
underflow checks on or off.\tabularnewline
nilChecks & on\textbar off & Turns the code generation for nil pointer
checks on or off.\tabularnewline
assertions & on\textbar off & Turns the code generation for assertions
on or off.\tabularnewline
warnings & on\textbar off & Turns the warning messages of the compiler
on or off.\tabularnewline
hints & on\textbar off & Turns the hint messages of the compiler on or
off.\tabularnewline
optimization & none2size Optimi & ze the code for speed or size, or
disable optimization.\tabularnewline
patterns & on\textbar off & Turns the term rewriting templates/macros on
or off.\tabularnewline
callconv & cdecl\textbar... & Specifies the default calling convention
for all procedures (and procedure types) that follow.\tabularnewline
\bottomrule
\end{longtable}

Example:

\begin{verbatim}
\end{verbatim}

\hypertarget{push-and-pop-pragmas}{%
\subsubsection{push and pop pragmas}\label{push-and-pop-pragmas}}

The \texttt{push/pop} pragmas are very similar to the option directive,
but are used to override the settings temporarily. Example:

\begin{verbatim}
\end{verbatim}

\texttt{push/pop} can switch on/off some standard library pragmas,
example:

\begin{verbatim}
{.push discardable, boundChecks: off, compileTime, noSideEffect, experimental.}
template example(): string = "https://nim-lang.org"
{.pop.}

{.push deprecated, hint[LineTooLong]: off, used, stackTrace: off.}
proc sample(): bool = true
{.pop.}
\end{verbatim}

For third party pragmas it depends on its implementation, but uses the
same syntax.

\hypertarget{register-pragma}{%
\subsubsection{register pragma}\label{register-pragma}}

The \texttt{register} pragma is for variables only. It declares the
variable as \texttt{register}, giving the compiler a hint that the
variable should be placed in a hardware register for faster access. C
compilers usually ignore this though and for good reasons: Often they do
a better job without it anyway.

In highly specific cases (a dispatch loop of a bytecode interpreter for
example) it may provide benefits, though.

\hypertarget{global-pragma}{%
\subsubsection{global pragma}\label{global-pragma}}

The \texttt{global} pragma can be applied to a variable within a proc to
instruct the compiler to store it in a global location and initialize it
once at program startup.

\begin{verbatim}
\end{verbatim}

When used within a generic proc, a separate unique global variable will
be created for each instantiation of the proc. The order of
initialization of the created global variables within a module is not
defined, but all of them will be initialized after any top-level
variables in their originating module and before any variable in a
module that imports it.

\hypertarget{disabling-certain-messages}{%
\subsubsection{Disabling certain
messages}\label{disabling-certain-messages}}

Nim generates some warnings and hints ("line too long") that may annoy
the user. A mechanism for disabling certain messages is provided: Each
hint and warning message contains a symbol in brackets. This is the
message's identifier that can be used to enable or disable it:

\begin{verbatim}
\end{verbatim}

This is often better than disabling all warnings at once.

\hypertarget{used-pragma}{%
\subsubsection{used pragma}\label{used-pragma}}

Nim produces a warning for symbols that are not exported and not used
either. The \texttt{used} pragma can be attached to a symbol to suppress
this warning. This is particularly useful when the symbol was generated
by a macro:

\begin{verbatim}
# no warning produced for the unused 'echoSub'
implementArithOps(int)
echoAdd 3, 5
\end{verbatim}

\texttt{used} can also be used as a top level statement to mark a module
as "used". This prevents the "Unused import" warning:

\begin{verbatim}
# module: debughelper.nim
when defined(nimHasUsed):
  # 'import debughelper' is so useful for debugging
  # that Nim shouldn't produce a warning for that import,
  # even if currently unused:
  {.used.}
\end{verbatim}

\hypertarget{experimental-pragma}{%
\subsubsection{experimental pragma}\label{experimental-pragma}}

The \texttt{experimental} pragma enables experimental language features.
Depending on the concrete feature this means that the feature is either
considered too unstable for an otherwise stable release or that the
future of the feature is uncertain (it may be removed any time).

Example:

\begin{verbatim}
proc threadedEcho(s: string, i: int) =
  echo(s, " ", $i)

proc useParallel() =
  parallel:
    for i in 0..4:
      spawn threadedEcho("echo in parallel", i)

useParallel()
\end{verbatim}

As a top level statement, the experimental pragma enables a feature for
the rest of the module it's enabled in. This is problematic for macro
and generic instantiations that cross a module scope. Currently these
usages have to be put into a \texttt{.push/pop} environment:

\begin{verbatim}
# client.nim
proc useParallel*[T](unused: T) =
  # use a generic T here to show the problem.
  {.push experimental: "parallel".}
  parallel:
    for i in 0..4:
      echo "echo in parallel"

  {.pop.}
\end{verbatim}

\begin{verbatim}
import client
useParallel(1)
\end{verbatim}

\hypertarget{implementation-specific-pragmas}{%
\subsection{Implementation Specific
Pragmas}\label{implementation-specific-pragmas}}

This section describes additional pragmas that the current Nim
implementation supports but which should not be seen as part of the
language specification.

\hypertarget{bitsize-pragma}{%
\subsubsection{Bitsize pragma}\label{bitsize-pragma}}

The \texttt{bitsize} pragma is for object field members. It declares the
field as a bitfield in C/C++.

\begin{verbatim}
\end{verbatim}

generates:

\begin{verbatim}
\end{verbatim}

\hypertarget{align-pragma}{%
\subsubsection{Align pragma}\label{align-pragma}}

The \texttt{align} pragma is for variables and object field members. It
modifies the alignment requirement of the entity being declared. The
argument must be a constant power of 2. Valid non-zero alignments that
are weaker than other align pragmas on the same declaration are ignored.
Alignments that are weaker that the alignment requirement of the type
are ignored.

\begin{verbatim}
type
  sseType = object
    sseData {.align(16).}: array[4, float32]

  # every object will be aligned to 128-byte boundary
  Data = object
    x: char
    cacheline {.align(128).}: array[128, char] # over-aligned array of char,

proc main() =
  echo "sizeof(Data) = ", sizeof(Data), " (1 byte + 127 bytes padding + 128-byte array)"
  # output: sizeof(Data) = 256 (1 byte + 127 bytes padding + 128-byte array)
  echo "alignment of sseType is ", alignof(sseType)
  # output: alignment of sseType is 16
  var d {.align(2048).}: Data # this instance of data is aligned even stricter

main()
\end{verbatim}

This pragma has no effect for the JS backend.

\hypertarget{volatile-pragma}{%
\subsubsection{Volatile pragma}\label{volatile-pragma}}

The \texttt{volatile} pragma is for variables only. It declares the
variable as \texttt{volatile}, whatever that means in C/C++ (its
semantics are not well defined in C/C++).

\textbf{Note}: This pragma will not exist for the LLVM backend.

\hypertarget{nodecl-pragma}{%
\subsubsection{NoDecl pragma}\label{nodecl-pragma}}

The \texttt{noDecl} pragma can be applied to almost any symbol
(variable, proc, type, etc.) and is sometimes useful for
interoperability with C: It tells Nim that it should not generate a
declaration for the symbol in the C code. For example:

\begin{verbatim}
\end{verbatim}

However, the \texttt{header} pragma is often the better alternative.

\textbf{Note}: This will not work for the LLVM backend.

\hypertarget{header-pragma}{%
\subsubsection{Header pragma}\label{header-pragma}}

The \texttt{header} pragma is very similar to the \texttt{noDecl}
pragma: It can be applied to almost any symbol and specifies that it
should not be declared and instead the generated code should contain an
\texttt{\#include}:

\begin{verbatim}
\end{verbatim}

The \texttt{header} pragma always expects a string constant. The string
constant contains the header file: As usual for C, a system header file
is enclosed in angle brackets: \texttt{\textless{}\textgreater{}}. If no
angle brackets are given, Nim encloses the header file in \texttt{""} in
the generated C code.

\textbf{Note}: This will not work for the LLVM backend.

\hypertarget{incompletestruct-pragma}{%
\subsubsection{IncompleteStruct pragma}\label{incompletestruct-pragma}}

The \texttt{incompleteStruct} pragma tells the compiler to not use the
underlying C \texttt{struct} in a \texttt{sizeof} expression:

\begin{verbatim}
\end{verbatim}

\hypertarget{compile-pragma}{%
\subsubsection{Compile pragma}\label{compile-pragma}}

The \texttt{compile} pragma can be used to compile and link a C/C++
source file with the project:

\begin{verbatim}
\end{verbatim}

\textbf{Note}: Nim computes a SHA1 checksum and only recompiles the file
if it has changed. One can use the \texttt{-f} command line option to
force recompilation of the file.

\hypertarget{link-pragma}{%
\subsubsection{Link pragma}\label{link-pragma}}

The \texttt{link} pragma can be used to link an additional file with the
project:

\begin{verbatim}
\end{verbatim}

\hypertarget{passc-pragma}{%
\subsubsection{PassC pragma}\label{passc-pragma}}

The \texttt{passc} pragma can be used to pass additional parameters to
the C compiler like one would using the commandline switch
\texttt{-\/-passc}:

\begin{verbatim}
\end{verbatim}

Note that one can use \texttt{gorge} from the \href{system.html}{system
module} to embed parameters from an external command that will be
executed during semantic analysis:

\begin{verbatim}
\end{verbatim}

\hypertarget{localpassc-pragma}{%
\subsubsection{LocalPassc pragma}\label{localpassc-pragma}}

The \texttt{localPassc} pragma can be used to pass additional parameters
to the C compiler, but only for the C/C++ file that is produced from the
Nim module the pragma resides in:

\begin{Shaded}
\begin{Highlighting}[]

\end{Highlighting}
\end{Shaded}

\hypertarget{passl-pragma}{%
\subsubsection{PassL pragma}\label{passl-pragma}}

The \texttt{passL} pragma can be used to pass additional parameters to
the linker like one would using the commandline switch
\texttt{-\/-passL}:

\begin{verbatim}
\end{verbatim}

Note that one can use \texttt{gorge} from the \href{system.html}{system
module} to embed parameters from an external command that will be
executed during semantic analysis:

\begin{verbatim}
\end{verbatim}

\hypertarget{emit-pragma}{%
\subsubsection{Emit pragma}\label{emit-pragma}}

The \texttt{emit} pragma can be used to directly affect the output of
the compiler's code generator. The code is then unportable to other code
generators/backends. Its usage is highly discouraged! However, it can be
extremely useful for interfacing with \texttt{C++} or
\texttt{Objective\ C} code.

Example:

\begin{verbatim}
{.push stackTrace:off.}
proc embedsC() =
  var nimVar = 89
  # access Nim symbols within an emit section outside of string literals:
  {.emit: ["""fprintf(stdout, "%d\n", cvariable + (int)""", nimVar, ");"].}
{.pop.}

embedsC()
\end{verbatim}

\texttt{nimbase.h} defines \texttt{NIM\_EXTERNC} C macro that can be
used for \texttt{extern\ "C"} code to work with both \texttt{nim\ c} and
\texttt{nim\ cpp}, eg:

\begin{verbatim}
\end{verbatim}

For backwards compatibility, if the argument to the \texttt{emit}
statement is a single string literal, Nim symbols can be referred to via
backticks. This usage is however deprecated.

For a toplevel emit statement the section where in the generated C/C++
file the code should be emitted can be influenced via the prefixes
\texttt{/*TYPESECTION*/} or \texttt{/*VARSECTION*/} or
\texttt{/*INCLUDESECTION*/}:

\begin{verbatim}
type Vector3 {.importcpp: "Vector3", nodecl} = object
  x: cfloat

proc constructVector3(a: cfloat): Vector3 {.importcpp: "Vector3(@)", nodecl}
\end{verbatim}

\hypertarget{importcpp-pragma}{%
\subsubsection{ImportCpp pragma}\label{importcpp-pragma}}

\textbf{Note}:
\href{https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst}{c2nim}
can parse a large subset of C++ and knows about the \texttt{importcpp}
pragma pattern language. It is not necessary to know all the details
described here.

Similar to the
\protect\hyperlink{foreign-function-interface-importc-pragma}{importc
pragma for C}, the \texttt{importcpp} pragma can be used to import
\texttt{C++} methods or C++ symbols in general. The generated code then
uses the C++ method calling syntax:
\texttt{obj-\textgreater{}method(arg)}. In combination with the
\texttt{header} and \texttt{emit} pragmas this allows \emph{sloppy}
interfacing with libraries written in C++:

\begin{verbatim}
{.link: "/usr/lib/libIrrlicht.so".}

{.emit: """
using namespace irr;
using namespace core;
using namespace scene;
using namespace video;
using namespace io;
using namespace gui;
""".}

const
  irr = "<irrlicht/irrlicht.h>"

type
  IrrlichtDeviceObj {.header: irr,
                      importcpp: "IrrlichtDevice".} = object
  IrrlichtDevice = ptr IrrlichtDeviceObj

proc createDevice(): IrrlichtDevice {.
  header: irr, importcpp: "createDevice(@)".}
proc run(device: IrrlichtDevice): bool {.
  header: irr, importcpp: "#.run(@)".}
\end{verbatim}

The compiler needs to be told to generate C++ (command \texttt{cpp}) for
this to work. The conditional symbol \texttt{cpp} is defined when the
compiler emits C++ code.

\hypertarget{namespaces}{%
\paragraph{Namespaces}\label{namespaces}}

The \emph{sloppy interfacing} example uses \texttt{.emit} to produce
\texttt{using\ namespace} declarations. It is usually much better to
instead refer to the imported name via the
\texttt{namespace::identifier} notation:

\begin{verbatim}
\end{verbatim}

\hypertarget{importcpp-for-enums}{%
\paragraph{Importcpp for enums}\label{importcpp-for-enums}}

When \texttt{importcpp} is applied to an enum type the numerical enum
values are annotated with the C++ enum type, like in this example:
\texttt{((TheCppEnum)(3))}. (This turned out to be the simplest way to
implement it.)

\hypertarget{importcpp-for-procs}{%
\paragraph{Importcpp for procs}\label{importcpp-for-procs}}

Note that the \texttt{importcpp} variant for procs uses a somewhat
cryptic pattern language for maximum flexibility:

\begin{itemize}
\tightlist
\item
  A hash \texttt{\#} symbol is replaced by the first or next argument.
\item
  A dot following the hash \texttt{\#.} indicates that the call should
  use C++'s dot or arrow notation.
\item
  An at symbol \texttt{@} is replaced by the remaining arguments,
  separated by commas.
\end{itemize}

For example:

\begin{verbatim}
\end{verbatim}

Produces:

\begin{verbatim}
\end{verbatim}

As a special rule to keep backwards compatibility with older versions of
the \texttt{importcpp} pragma, if there is no special pattern character
(any of \texttt{\#\ \textquotesingle{}\ @}) at all, C++'s dot or arrow
notation is assumed, so the above example can also be written as:

\begin{verbatim}
\end{verbatim}

Note that the pattern language naturally also covers C++'s operator
overloading capabilities:

\begin{verbatim}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  An apostrophe \texttt{\textquotesingle{}} followed by an integer
  \texttt{i} in the range 0..9 is replaced by the i'th parameter
  \emph{type}. The 0th position is the result type. This can be used to
  pass types to C++ function templates. Between the
  \texttt{\textquotesingle{}} and the digit an asterisk can be used to
  get to the base type of the type. (So it "takes away a star" from the
  type; \texttt{T*} becomes \texttt{T}.) Two stars can be used to get to
  the element type of the element type etc.
\end{itemize}

For example:

\begin{verbatim}
type Input {.importcpp: "System::Input".} = object
proc getSubsystem*[T](): ptr T {.importcpp: "SystemManager::getSubsystem<'*0>()", nodecl.}

let x: ptr Input = getSubsystem[Input]()
\end{verbatim}

Produces:

\begin{verbatim}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{\#@} is a special case to support a \texttt{cnew} operation.
  It is required so that the call expression is inlined directly,
  without going through a temporary location. This is only required to
  circumvent a limitation of the current code generator.
\end{itemize}

For example C++'s \texttt{new} operator can be "imported" like this:

\begin{verbatim}
# constructor of 'Foo':
proc constructFoo(a, b: cint): Foo {.importcpp: "Foo(@)".}

let x = cnew constructFoo(3, 4)
\end{verbatim}

Produces:

\begin{verbatim}
\end{verbatim}

However, depending on the use case \texttt{new\ Foo} can also be wrapped
like this instead:

\begin{verbatim}
let x = newFoo(3, 4)
\end{verbatim}

\hypertarget{wrapping-constructors}{%
\paragraph{Wrapping constructors}\label{wrapping-constructors}}

Sometimes a C++ class has a private copy constructor and so code like
\texttt{Class\ c\ =\ Class(1,2);} must not be generated but instead
\texttt{Class\ c(1,2);}. For this purpose the Nim proc that wraps a C++
constructor needs to be annotated with the \texttt{constructor} pragma.
This pragma also helps to generate faster C++ code since construction
then doesn't invoke the copy constructor:

\begin{verbatim}
\end{verbatim}

\hypertarget{wrapping-destructors}{%
\paragraph{Wrapping destructors}\label{wrapping-destructors}}

Since Nim generates C++ directly, any destructor is called implicitly by
the C++ compiler at the scope exits. This means that often one can get
away with not wrapping the destructor at all! However when it needs to
be invoked explicitly, it needs to be wrapped. The pattern language
provides everything that is required:

\begin{verbatim}
\end{verbatim}

\hypertarget{importcpp-for-objects}{%
\paragraph{Importcpp for objects}\label{importcpp-for-objects}}

Generic \texttt{importcpp}'ed objects are mapped to C++ templates. This
means that one can import C++'s templates rather easily without the need
for a pattern language for object types:

\begin{verbatim}
var x: StdMap[cint, cdouble]
x[6] = 91.4
\end{verbatim}

Produces:

\begin{verbatim}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  If more precise control is needed, the apostrophe
  \texttt{\textquotesingle{}} can be used in the supplied pattern to
  denote the concrete type parameters of the generic type. See the usage
  of the apostrophe operator in proc patterns for more details.
\end{itemize}

\begin{verbatim}
type
  VectorIterator {.importcpp: "std::vector<'0>::iterator".} [T] = object

var x: VectorIterator[cint]
\end{verbatim}

Produces:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{std::vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{}::iterator x;}
\end{Highlighting}
\end{Shaded}

\hypertarget{importjs-pragma}{%
\subsubsection{ImportJs pragma}\label{importjs-pragma}}

Similar to the
\protect\hyperlink{implementation-specific-pragmas-importcpp-pragma}{importcpp
pragma for C++}, the \texttt{importjs} pragma can be used to import
Javascript methods or symbols in general. The generated code then uses
the Javascript method calling syntax: \texttt{obj.method(arg)}.

\hypertarget{importobjc-pragma}{%
\subsubsection{ImportObjC pragma}\label{importobjc-pragma}}

Similar to the
\protect\hyperlink{foreign-function-interface-importc-pragma}{importc
pragma for C}, the \texttt{importobjc} pragma can be used to import
\texttt{Objective\ C} methods. The generated code then uses the
Objective C method calling syntax:
\texttt{{[}obj\ method\ param1:\ arg{]}}. In addition with the
\texttt{header} and \texttt{emit} pragmas this allows \emph{sloppy}
interfacing with libraries written in Objective C:

\begin{verbatim}
{.passL: "-lobjc".}
{.emit: """
#include <objc/Object.h>
@interface Greeter:Object
{
}

- (void)greet:(long)x y:(long)dummy;
@end

#include <stdio.h>
@implementation Greeter

- (void)greet:(long)x y:(long)dummy
{
  printf("Hello, World!\n");
}
@end

#include <stdlib.h>
""".}

type
  Id {.importc: "id", header: "<objc/Object.h>", final.} = distinct int

proc newGreeter: Id {.importobjc: "Greeter new", nodecl.}
proc greet(self: Id, x, y: int) {.importobjc: "greet", nodecl.}
proc free(self: Id) {.importobjc: "free", nodecl.}

var g = newGreeter()
g.greet(12, 34)
g.free()
\end{verbatim}

The compiler needs to be told to generate Objective C (command
\texttt{objc}) for this to work. The conditional symbol \texttt{objc} is
defined when the compiler emits Objective C code.

\hypertarget{codegendecl-pragma}{%
\subsubsection{CodegenDecl pragma}\label{codegendecl-pragma}}

The \texttt{codegenDecl} pragma can be used to directly influence Nim's
code generator. It receives a format string that determines how the
variable or proc is declared in the generated code.

For variables \$1 in the format string represents the type of the
variable and \$2 is the name of the variable.

The following Nim code:

\begin{verbatim}
\end{verbatim}

will generate this C code:

\begin{verbatim}
\end{verbatim}

For procedures \$1 is the return type of the procedure, \$2 is the name
of the procedure and \$3 is the parameter list.

The following nim code:

\begin{verbatim}
\end{verbatim}

will generate this code:

\begin{verbatim}
\end{verbatim}

\hypertarget{injectstmt-pragma}{%
\subsubsection{InjectStmt pragma}\label{injectstmt-pragma}}

The \texttt{injectStmt} pragma can be used to inject a statement before
every other statement in the current module. It is only supposed to be
used for debugging:

\begin{verbatim}
# ... complex code here that produces crashes ...
\end{verbatim}

\hypertarget{compile-time-define-pragmas}{%
\subsubsection{compile time define
pragmas}\label{compile-time-define-pragmas}}

The pragmas listed here can be used to optionally accept values from the
-d/-\/-define option at compile time.

The implementation currently provides the following possible options
(various others may be added later).

\begin{longtable}[]{@{}ll@{}}
\toprule
pragma & description\tabularnewline
\midrule
\endhead
\texttt{intdefine} & Reads in a build-time define as an
integer\tabularnewline
\texttt{strdefine} & Reads in a build-time define as a
string\tabularnewline
\texttt{booldefine} & Reads in a build-time define as a
bool\tabularnewline
\bottomrule
\end{longtable}

\begin{verbatim}
\end{verbatim}

\begin{description}
\item[::]
nim c -d:FooBar=42 foobar.nim
\end{description}

In the above example, providing the -d flag causes the symbol
\texttt{FooBar} to be overwritten at compile time, printing out 42. If
the \texttt{-d:FooBar=42} were to be omitted, the default value of 5
would be used. To see if a value was provided, {defined(FooBar)} can be
used.

The syntax {-d:flag} is actually just a shortcut for {-d:flag=true}.

\hypertarget{user-defined-pragmas}{%
\subsection{User-defined pragmas}\label{user-defined-pragmas}}

\hypertarget{pragma-pragma}{%
\subsubsection{pragma pragma}\label{pragma-pragma}}

The \texttt{pragma} pragma can be used to declare user defined pragmas.
This is useful because Nim's templates and macros do not affect pragmas.
User defined pragmas are in a different module-wide scope than all other
symbols. They cannot be imported from a module.

Example:

\begin{verbatim}
proc p*(a, b: int): int {.rtl.} =
  result = a+b
\end{verbatim}

In the example a new pragma named \texttt{rtl} is introduced that either
imports a symbol from a dynamic library or exports the symbol for
dynamic library generation.

\hypertarget{custom-annotations}{%
\subsubsection{Custom annotations}\label{custom-annotations}}

It is possible to define custom typed pragmas. Custom pragmas do not
effect code generation directly, but their presence can be detected by
macros. Custom pragmas are defined using templates annotated with pragma
\texttt{pragma}:

\begin{verbatim}
\end{verbatim}

Consider stylized example of possible Object Relation Mapping (ORM)
implementation:

\begin{verbatim}
type
  User {.dbTable("users", tblspace).} = object
    id {.dbKey(primary_key = true).}: int
    name {.dbKey"full_name".}: string
    is_cached {.dbIgnore.}: bool
    age: int

  UserProfile {.dbTable("profiles", tblspace).} = object
    id {.dbKey(primary_key = true).}: int
    user_id {.dbForeignKey: User.}: int
    read_access: bool
    write_access: bool
    admin_acess: bool
\end{verbatim}

In this example custom pragmas are used to describe how Nim objects are
mapped to the schema of the relational database. Custom pragmas can have
zero or more arguments. In order to pass multiple arguments use one of
template call syntaxes. All arguments are typed and follow standard
overload resolution rules for templates. Therefore, it is possible to
have default values for arguments, pass by name, varargs, etc.

Custom pragmas can be used in all locations where ordinary pragmas can
be specified. It is possible to annotate procs, templates, type and
variable definitions, statements, etc.

Macros module includes helpers which can be used to simplify custom
pragma access {hasCustomPragma}, {getCustomPragmaVal}. Please consult
the macros module documentation for details. These macros are not magic,
everything they do can also be achieved by walking the AST of the object
representation.

More examples with custom pragmas:

\begin{itemize}
\tightlist
\item
  Better serialization/deserialization control:
\end{itemize}

\begin{verbatim}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Adopting type for gui inspector in a game engine:
\end{itemize}

\begin{verbatim}
\end{verbatim}

\hypertarget{macro-pragmas}{%
\subsubsection{Macro pragmas}\label{macro-pragmas}}

All macros and templates can also be used as pragmas. They can be
attached to routines (procs, iterators, etc), type names or type
expressions. The compiler will perform the following simple syntactic
transformations:

\begin{verbatim}
proc p() {.command("print").} = discard
\end{verbatim}

This is translated to:

\begin{verbatim}
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{verbatim}
\end{verbatim}

This is translated to:

\begin{verbatim}
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{verbatim}
\end{verbatim}

This is translated to a call to the \texttt{schema} macro with a
{nnkTypeDef} AST node capturing both the left-hand side and right-hand
side of the definition. The macro can return a potentially modified
{nnkTypeDef} tree which will replace the original row in the type
section.

When multiple macro pragmas are applied to the same definition, the
compiler will apply them consequently from left to right. Each macro
will receive as input the output of the previous one.

\hypertarget{foreign-function-interface}{%
\subsection{Foreign function
interface}\label{foreign-function-interface}}

Nim's \texttt{FFI} (foreign function interface) is extensive and only
the parts that scale to other future backends (like the LLVM/JavaScript
backends) are documented here.

\hypertarget{importc-pragma}{%
\subsubsection{Importc pragma}\label{importc-pragma}}

The \texttt{importc} pragma provides a means to import a proc or a
variable from C. The optional argument is a string containing the C
identifier. If the argument is missing, the C name is the Nim identifier
\emph{exactly as spelled}:

\begin{verbatim}
\end{verbatim}

When \texttt{importc} is applied to a \texttt{let} statement it can omit
its value which will then be expected to come from C. This can be used
to import a C \texttt{const}:

\begin{verbatim}
let cconst {.importc, nodecl.}: cint

assert cconst == 42
\end{verbatim}

Note that this pragma has been abused in the past to also work in the js
backend for js objects and functions. : Other backends do provide the
same feature under the same name. Also, when the target language is not
set to C, other pragmas are available:

\begin{quote}
\begin{itemize}
\tightlist
\item
  \href{manual.html\#implementation-specific-pragmas-importcpp-pragma}{importcpp}
\item
  \href{manual.html\#implementation-specific-pragmas-importobjc-pragma}{importobjc}
\item
  \href{manual.html\#implementation-specific-pragmas-importjs-pragma}{importjs}
\end{itemize}
\end{quote}

\begin{verbatim}
\end{verbatim}

In the example the external name of \texttt{p} is set to
\texttt{prefixp}. Only \texttt{\$1} is available and a literal dollar
sign must be written as \texttt{\$\$}.

\hypertarget{exportc-pragma}{%
\subsubsection{Exportc pragma}\label{exportc-pragma}}

The \texttt{exportc} pragma provides a means to export a type, a
variable, or a procedure to C. Enums and constants can't be exported.
The optional argument is a string containing the C identifier. If the
argument is missing, the C name is the Nim identifier \emph{exactly as
spelled}:

\begin{verbatim}
\end{verbatim}

Note that this pragma is somewhat of a misnomer: Other backends do
provide the same feature under the same name.

The string literal passed to \texttt{exportc} can be a format string:

\begin{verbatim}
\end{verbatim}

In the example the external name of \texttt{p} is set to
\texttt{prefixp}. Only \texttt{\$1} is available and a literal dollar
sign must be written as \texttt{\$\$}.

If the symbol should also be exported to a dynamic library, the
\texttt{dynlib} pragma should be used in addition to the
\texttt{exportc} pragma. See
\protect\hyperlink{foreign-function-interface-dynlib-pragma-for-export}{Dynlib
pragma for export}.

\hypertarget{extern-pragma}{%
\subsubsection{Extern pragma}\label{extern-pragma}}

Like \texttt{exportc} or \texttt{importc}, the \texttt{extern} pragma
affects name mangling. The string literal passed to \texttt{extern} can
be a format string:

\begin{verbatim}
\end{verbatim}

In the example the external name of \texttt{p} is set to
\texttt{prefixp}. Only \texttt{\$1} is available and a literal dollar
sign must be written as \texttt{\$\$}.

\hypertarget{bycopy-pragma}{%
\subsubsection{Bycopy pragma}\label{bycopy-pragma}}

The \texttt{bycopy} pragma can be applied to an object or tuple type and
instructs the compiler to pass the type by value to procs:

\begin{verbatim}
\end{verbatim}

\hypertarget{byref-pragma}{%
\subsubsection{Byref pragma}\label{byref-pragma}}

The \texttt{byref} pragma can be applied to an object or tuple type and
instructs the compiler to pass the type by reference (hidden pointer) to
procs.

\hypertarget{varargs-pragma}{%
\subsubsection{Varargs pragma}\label{varargs-pragma}}

The \texttt{varargs} pragma can be applied to procedures only (and
procedure types). It tells Nim that the proc can take a variable number
of parameters after the last specified parameter. Nim string values will
be converted to C strings automatically:

\begin{verbatim}
printf("hallo %s", "world") # "world" will be passed as C string
\end{verbatim}

\hypertarget{union-pragma}{%
\subsubsection{Union pragma}\label{union-pragma}}

The \texttt{union} pragma can be applied to any \texttt{object} type. It
means all of the object's fields are overlaid in memory. This produces a
\texttt{union} instead of a \texttt{struct} in the generated C/C++ code.
The object declaration then must not use inheritance or any GC'ed memory
but this is currently not checked.

\textbf{Future directions}: GC'ed memory should be allowed in unions and
the GC should scan unions conservatively.

\hypertarget{packed-pragma}{%
\subsubsection{Packed pragma}\label{packed-pragma}}

The \texttt{packed} pragma can be applied to any \texttt{object} type.
It ensures that the fields of an object are packed back-to-back in
memory. It is useful to store packets or messages from/to network or
hardware drivers, and for interoperability with C. Combining packed
pragma with inheritance is not defined, and it should not be used with
GC'ed memory (ref's).

\textbf{Future directions}: Using GC'ed memory in packed pragma will
result in a static error. Usage with inheritance should be defined and
documented.

\hypertarget{dynlib-pragma-for-import}{%
\subsubsection{Dynlib pragma for
import}\label{dynlib-pragma-for-import}}

With the \texttt{dynlib} pragma a procedure or a variable can be
imported from a dynamic library (\texttt{.dll} files for Windows,
\texttt{lib*.so} files for UNIX). The non-optional argument has to be
the name of the dynamic library:

\begin{verbatim}
\end{verbatim}

In general, importing a dynamic library does not require any special
linker options or linking with import libraries. This also implies that
no \emph{devel} packages need to be installed.

The \texttt{dynlib} import mechanism supports a versioning scheme:

\begin{verbatim}
\end{verbatim}

At runtime the dynamic library is searched for (in this order):

\begin{verbatim}
libtcl.so.1
libtcl.so.0
libtcl8.5.so.1
libtcl8.5.so.0
libtcl8.4.so.1
libtcl8.4.so.0
libtcl8.3.so.1
libtcl8.3.so.0
\end{verbatim}

The \texttt{dynlib} pragma supports not only constant strings as
argument but also string expressions in general:

\begin{verbatim}
proc getDllName: string =
  result = "mylib.dll"
  if fileExists(result): return
  result = "mylib2.dll"
  if fileExists(result): return
  quit("could not load dynamic library")

proc myImport(s: cstring) {.cdecl, importc, dynlib: getDllName().}
\end{verbatim}

\textbf{Note}: Patterns like
\texttt{libtcl(\textbar{}8.5\textbar{}8.4).so} are only supported in
constant strings, because they are precompiled.

\textbf{Note}: Passing variables to the \texttt{dynlib} pragma will fail
at runtime because of order of initialization problems.

\textbf{Note}: A \texttt{dynlib} import can be overridden with the
\texttt{-\/-dynlibOverride:name} command line option. The Compiler User
Guide contains further information.

\hypertarget{dynlib-pragma-for-export}{%
\subsubsection{Dynlib pragma for
export}\label{dynlib-pragma-for-export}}

With the \texttt{dynlib} pragma a procedure can also be exported to a
dynamic library. The pragma then has no argument and has to be used in
conjunction with the \texttt{exportc} pragma:

\begin{verbatim}
\end{verbatim}

This is only useful if the program is compiled as a dynamic library via
the \texttt{-\/-app:lib} command line option.

\hypertarget{threads}{%
\subsection{Threads}\label{threads}}

To enable thread support the \texttt{-\/-threads:on} command line switch
needs to be used. The \texttt{system} module then contains several
threading primitives. See the \href{threads.html}{threads} and
\href{channels.html}{channels} modules for the low level thread API.
There are also high level parallelism constructs available. See
\href{manual_experimental.html\#parallel-amp-spawn}{spawn} for further
details.

Nim's memory model for threads is quite different than that of other
common programming languages (C, Pascal, Java): Each thread has its own
(garbage collected) heap and sharing of memory is restricted to global
variables. This helps to prevent race conditions. GC efficiency is
improved quite a lot, because the GC never has to stop other threads and
see what they reference.

\hypertarget{thread-pragma}{%
\subsubsection{Thread pragma}\label{thread-pragma}}

A proc that is executed as a new thread of execution should be marked by
the \texttt{thread} pragma for reasons of readability. The compiler
checks for violations of the \texttt{no\ heap\ sharing\ restriction}:
This restriction implies that it is invalid to construct a data
structure that consists of memory allocated from different (thread
local) heaps.

A thread proc is passed to \texttt{createThread} or \texttt{spawn} and
invoked indirectly; so the \texttt{thread} pragma implies
\texttt{procvar}.

\hypertarget{gc-safety}{%
\subsubsection{GC safety}\label{gc-safety}}

We call a proc \texttt{p} \texttt{GC\ safe} when it doesn't access any
global variable that contains GC'ed memory (\texttt{string},
\texttt{seq}, \texttt{ref} or a closure) either directly or indirectly
through a call to a GC unsafe proc.

The \texttt{gcsafe} annotation can be used to mark a proc to be gcsafe,
otherwise this property is inferred by the compiler. Note that
\texttt{noSideEffect} implies \texttt{gcsafe}. The only way to create a
thread is via \texttt{spawn} or \texttt{createThread}. The invoked proc
must not use \texttt{var} parameters nor must any of its parameters
contain a \texttt{ref} or \texttt{closure} type. This enforces the
\emph{no heap sharing restriction}.

Routines that are imported from C are always assumed to be
\texttt{gcsafe}. To disable the GC-safety checking the
\texttt{-\/-threadAnalysis:off} command line switch can be used. This is
a temporary workaround to ease the porting effort from old code to the
new threading model.

To override the compiler's gcsafety analysis a \texttt{\{.gcsafe.\}}
pragma block can be used:

\begin{verbatim}
var
  someGlobal: string = "some string here"
  perThread {.threadvar.}: string

proc setPerThread() =
  {.gcsafe.}:
    deepCopy(perThread, someGlobal)
\end{verbatim}

See also:

\begin{itemize}
\tightlist
\item
  \href{gc.html}{Shared heap memory management.}.
\end{itemize}

\hypertarget{threadvar-pragma}{%
\subsubsection{Threadvar pragma}\label{threadvar-pragma}}

A variable can be marked with the \texttt{threadvar} pragma, which makes
it a \texttt{thread-local} variable; Additionally, this implies all the
effects of the \texttt{global} pragma.

\begin{verbatim}
\end{verbatim}

Due to implementation restrictions thread local variables cannot be
initialized within the \texttt{var} section. (Every thread local
variable needs to be replicated at thread creation.)

\hypertarget{threads-and-exceptions}{%
\subsubsection{Threads and exceptions}\label{threads-and-exceptions}}

The interaction between threads and exceptions is simple: A
\emph{handled} exception in one thread cannot affect any other thread.
However, an \emph{unhandled} exception in one thread terminates the
whole \emph{process}!
