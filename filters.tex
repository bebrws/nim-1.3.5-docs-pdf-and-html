% This file was generated by Nim.
% Generated: 2020-08-22 06:37:23 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{Source Code Filters }
\author{}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

\tableofcontents \newpage
A \texttt{Source Code Filter (SCF)}  transforms the input character stream to an in-memory output stream before parsing. A filter can be used to provide templating systems or preprocessors.

To use a filter for a source file the \texttt{\#?} notation is used:\begin{rstpre}

\#? stdtmpl(subsChar = '\$', metaChar = '\#')
\#proc generateXML(name, age: string): string =
\#  result = ""
<xml>
  <name>\$name</name>
  <age>\$age</age>
</xml>
\end{rstpre}


As the example shows, passing arguments to a filter can be done just like an ordinary procedure call with named or positional arguments. The available parameters depend on the invoked filter. Before version 0.12.0 of the language \texttt{\#!} was used instead of \texttt{\#?}.

\textbf{Hint:} With \texttt{--hint\symbol{91}codeBegin\symbol{93}:on} or \texttt{--verbosity:2} (or higher) while compiling or \texttt{nim check}, Nim lists the processed code after each filter application.

\rsthA{Usage}\label{usage}
First, put your SCF code in a separate file with filters specified in the first line. \textbf{Note:} You can name your SCF file with any file extension you want, but the conventional extension is \texttt{.nimf} (it used to be \texttt{.tmpl} but that was too generic, for example preventing github to recognize it as Nim source file).

If we use \texttt{generateXML} code shown above and call the SCF file \texttt{xmlGen.nimf} In your \texttt{main.nim}:

\begin{rstpre}
\spanKeyword{include} \spanStringLit{"xmlGen.nimf"}

\spanIdentifier{echo} \spanIdentifier{generateXML}\spanPunctuation{(}\spanStringLit{"John Smith"}\spanPunctuation{,}\spanStringLit{"42"}\spanPunctuation{)}
\end{rstpre}
\rsthA{Pipe operator}\label{pipe-operator}
Filters can be combined with the \texttt{|} pipe operator:\begin{rstpre}

\#? strip(startswith="<") | stdtmpl
\#proc generateXML(name, age: string): string =
\#  result = ""
<xml>
  <name>\$name</name>
  <age>\$age</age>
</xml>
\end{rstpre}


\rsthA{Available filters}\label{available-filters}
\rsthB{Replace filter}\label{available-filters-replace-filter}
The replace filter replaces substrings in each line.

Parameters and their defaults:

\begin{quote}\begin{description}\item[\texttt{sub: string = ""}] the substring that is searched for
\item[\texttt{by: string = ""}] the string the substring is replaced with
\end{description}
\end{quote}
\rsthB{Strip filter}\label{available-filters-strip-filter}
The strip filter simply removes leading and trailing whitespace from each line.

Parameters and their defaults:

\begin{quote}\begin{description}\item[\texttt{startswith: string = ""}] strip only the lines that start with \emph{startswith} (ignoring leading whitespace). If empty every line is stripped.
\item[\texttt{leading: bool = true}] strip leading whitespace
\item[\texttt{trailing: bool = true}] strip trailing whitespace
\end{description}
\end{quote}
\rsthB{StdTmpl filter}\label{available-filters-stdtmpl-filter}
The stdtmpl filter provides a simple templating engine for Nim. The filter uses a line based parser: Lines prefixed with a \emph{meta character} (default: \texttt{\#}) contain Nim code, other lines are verbatim. Because indentation-based parsing is not suited for a templating engine, control flow statements need \texttt{end X} delimiters.

Parameters and their defaults:

\begin{quote}\begin{description}\item[\texttt{metaChar: char = '\#'}] prefix for a line that contains Nim code
\item[\texttt{subsChar: char = '\$'}] prefix for a Nim expression within a template line
\item[\texttt{conc: string = " \& "}] the operation for concatenation
\item[\texttt{emit: string = "result.add"}] the operation to emit a string literal
\item[\texttt{toString: string = "\$"}] the operation that is applied to each expression
\end{description}
\end{quote}
Example:\begin{rstpre}

\#? stdtmpl | standard
\#proc generateHTMLPage(title, currentTab, content: string,
\#                      tabs: openArray\symbol{91}string\symbol{93}): string =
\#  result = ""
<head><title>\$title</title></head>
<body>
  <div id="menu">
    <ul>
  \#for tab in items(tabs):
    \#if currentTab == tab:
    <li><a id="selected"
    \#else:
    <li><a
    \#end if
    href="\$\symbol{123}tab\symbol{125}.html">\$tab</a></li>
  \#end for
    </ul>
  </div>
  <div id="content">
    \$content
    A dollar: \$\$.
  </div>
</body>
\end{rstpre}


The filter transforms this into:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{generateHTMLPage}\spanPunctuation{(}\spanIdentifier{title}\spanPunctuation{,} \spanIdentifier{currentTab}\spanPunctuation{,} \spanIdentifier{content}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{,}
                      \spanIdentifier{tabs}\spanPunctuation{:} \spanIdentifier{openArray}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanStringLit{""}
  \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add}\spanPunctuation{(}\spanStringLit{"<head><title>"} \spanOperator{\&} \spanOperator{\$}\spanPunctuation{(}\spanIdentifier{title}\spanPunctuation{)} \spanOperator{\&} \spanStringLit{"</title></head>}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"} \spanOperator{\&}
    \spanStringLit{"<body>}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"} \spanOperator{\&}
    \spanStringLit{"  <div id=}\spanEscapeSequence{\symbol{92}"}\spanEscapeSequence{menu\symbol{92}"}\spanEscapeSequence{>\symbol{92}n}\spanStringLit{"} \spanOperator{\&}
    \spanStringLit{"    <ul>}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"}\spanPunctuation{)}
  \spanKeyword{for} \spanIdentifier{tab} \spanKeyword{in} \spanIdentifier{items}\spanPunctuation{(}\spanIdentifier{tabs}\spanPunctuation{)}\spanPunctuation{:}
    \spanKeyword{if} \spanIdentifier{currentTab} \spanOperator{==} \spanIdentifier{tab}\spanPunctuation{:}
      \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add}\spanPunctuation{(}\spanStringLit{"    <li><a id=}\spanEscapeSequence{\symbol{92}"}\spanEscapeSequence{selected\symbol{92}"}\spanEscapeSequence{ \symbol{92}n}\spanStringLit{"}\spanPunctuation{)}
    \spanKeyword{else}\spanPunctuation{:}
      \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add}\spanPunctuation{(}\spanStringLit{"    <li><a}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"}\spanPunctuation{)}
    \spanComment{\#end}
    \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add}\spanPunctuation{(}\spanStringLit{"    href=}\spanEscapeSequence{\symbol{92}"}\spanStringLit{"} \spanOperator{\&} \spanOperator{\$}\spanPunctuation{(}\spanIdentifier{tab}\spanPunctuation{)} \spanOperator{\&} \spanStringLit{".html}\spanEscapeSequence{\symbol{92}"}\spanStringLit{>"} \spanOperator{\&} \spanOperator{\$}\spanPunctuation{(}\spanIdentifier{tab}\spanPunctuation{)} \spanOperator{\&} \spanStringLit{"</a></li>}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"}\spanPunctuation{)}
  \spanComment{\#end}
  \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add}\spanPunctuation{(}\spanStringLit{"    </ul>}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"} \spanOperator{\&}
    \spanStringLit{"  </div>}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"} \spanOperator{\&}
    \spanStringLit{"  <div id=}\spanEscapeSequence{\symbol{92}"}\spanEscapeSequence{content\symbol{92}"}\spanEscapeSequence{>\symbol{92}n}\spanStringLit{"} \spanOperator{\&}
    \spanStringLit{"    "} \spanOperator{\&} \spanOperator{\$}\spanPunctuation{(}\spanIdentifier{content}\spanPunctuation{)} \spanOperator{\&} \spanStringLit{"}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"} \spanOperator{\&}
    \spanStringLit{"    A dollar: \$.}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"} \spanOperator{\&}
    \spanStringLit{"  </div>}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"} \spanOperator{\&}
    \spanStringLit{"</body>}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"}\spanPunctuation{)}
\end{rstpre}
Each line that does not start with the meta character (ignoring leading whitespace) is converted to a string literal that is added to \texttt{result}.

The substitution character introduces a Nim expression \emph{e} within the string literal. \emph{e} is converted to a string with the \emph{toString} operation which defaults to \texttt{\$}. For strong type checking, set \texttt{toString} to the empty string. \emph{e} must match this PEG pattern:\begin{rstpre}

e <- \symbol{91}a-zA-Z\symbol{92}128-\symbol{92}255\symbol{93}\symbol{91}a-zA-Z0-9\symbol{92}128-\symbol{92}255\_.\symbol{93}* / '\symbol{123}' x '\symbol{125}'
x <- '\symbol{123}' x+ '\symbol{125}' / \symbol{91}\symbol{94}\symbol{125}\symbol{93}*
\end{rstpre}


To produce a single substitution character it has to be doubled: \texttt{\$\$} produces \texttt{\$}.

The template engine is quite flexible. It is easy to produce a procedure that writes the template code directly to a file:\begin{rstpre}

\#? stdtmpl(emit="f.write") | standard
\#proc writeHTMLPage(f: File, title, currentTab, content: string,
\#                   tabs: openArray\symbol{91}string\symbol{93}) =
<head><title>\$title</title></head>
<body>
  <div id="menu">
    <ul>
  \#for tab in items(tabs):
    \#if currentTab == tab:
    <li><a id="selected"
    \#else:
    <li><a
    \#end if
    href="\$\symbol{123}tab\symbol{125}.html" title = "\$title - \$tab">\$tab</a></li>
  \#end for
    </ul>
  </div>
  <div id="content">
    \$content
    A dollar: \$\$.
  </div>
</body>
\end{rstpre}





\end{document}
