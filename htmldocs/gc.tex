% This file was generated by Nim.
% Generated: 2020-08-22 06:37:24 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{Nim's Memory Management 1.3.5}
\author{Andreas Rumpf}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

\begin{quote}"The road to hell is paved with good intentions."\end{quote}
\rsthA{Introduction}\label{introduction}
This document describes how the multi-paradigm memory management strategies work. How to tune the garbage collectors for your needs, like (soft) realtime systems\label{realtime-systems_1}, and how the memory management strategies that are not garbage collectors work.

\rsthA{Multi-paradigm Memory Management Strategies}\label{multiminusparadigm-memory-management-strategies}
To choose the memory management strategy use the \texttt{--gc:} switch.

\begin{itemize}\item \texttt{--gc:refc}. This is the default GC. It's a deferred reference counting based garbage collector with a simple Mark\&Sweep backup GC in order to collect cycles. Heaps are thread local.
\item \texttt{--gc:markAndSweep}. Simple Mark-And-Sweep based garbage collector. Heaps are thread local.
\item \texttt{--gc:boehm}. Boehm based garbage collector, it offers a shared heap.
\item \texttt{--gc:go}. Go's garbage collector, useful for interoperability with Go. Offers a shared heap.
\item \texttt{--gc:arc}. Plain reference counting with \href{destructors.html\#move-semantics}{move semantic optimizations}, offers a shared heap. It offers deterministic performance for hard realtime\label{hard-realtime_1} systems. Reference cycles cause memory leaks, beware.
\item \texttt{--gc:orc}. Same as \texttt{-gc:arc} but adds a cycle collector based on "trial deletion". Unfortunately that makes its performance profile hard to reason about so it is less useful for hard realtime systems.
\item \texttt{--gc:none}. No memory management strategy nor garbage collector. Allocated memory is simply never freed. You should use \texttt{--gc:arc} instead.
\end{itemize}
\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|X|}
\hline
\textbf{Memory Management} & \textbf{Heap} & \textbf{Reference Cycles} & \textbf{Stop-The-World} & \textbf{Command line switch}\\
\hline
RefC & Local & Cycle Collector & No & \texttt{--gc:refc}\\
\hline
Mark \& Sweep & Local & Cycle Collector & No & \texttt{--gc:markAndSweep}\\
\hline
ARC & Shared & Leak & No & \texttt{--gc:arc}\\
\hline
ORC & Shared & Cycle Collector & No & \texttt{--gc:orc}\\
\hline
Boehm & Shared & Cycle Collector & Yes & \texttt{--gc:boehm}\\
\hline
Go & Shared & Cycle Collector & Yes & \texttt{--gc:go}\\
\hline
None & Manual & Manual & Manual & \texttt{--gc:none}\\
\hline
\end{rsttab}\end{table}JavaScript's garbage collector is used for the \href{backends.html\#backends-the-javascript-target}{JavaScript and NodeJS} compilation targets. The \href{nims.html}{NimScript} target uses the memory management strategy built into the Nim compiler.

\rsthA{Tweaking the refc GC}\label{tweaking-the-refc-gc}
\rsthB{Cycle collector}\label{cycle-collector}
The cycle collector can be en-/disabled independently from the other parts of the garbage collector with \texttt{GC\_enableMarkAndSweep} and \texttt{GC\_disableMarkAndSweep}.

\rsthB{Soft realtime support}\label{soft-realtime-support}
To enable realtime support, the symbol useRealtimeGC\label{userealtimegc_1} needs to be defined via \texttt{--define:useRealtimeGC} (you can put this into your config file as well). With this switch the garbage collector supports the following operations:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{GC\_setMaxPause}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{maxPauseInUs}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}
\spanKeyword{proc} \spanIdentifier{GC\_step}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{us}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{strongAdvice} \spanOperator{=} \spanIdentifier{false}\spanPunctuation{,} \spanIdentifier{stackSize} \spanOperator{=} \spanOperator{-}\spanDecNumber{1}\spanPunctuation{)}
\end{rstpre}
The unit of the parameters \texttt{maxPauseInUs} and \texttt{us} is microseconds.

These two procs are the two modus operandi of the realtime garbage collector:

(1) GC\_SetMaxPause Mode

\begin{quote}You can call \texttt{GC\_SetMaxPause} at program startup and then each triggered garbage collector run tries to not take longer than \texttt{maxPause} time. However, it is possible (and common) that the work is nevertheless not evenly distributed as each call to \texttt{new} can trigger the garbage collector and thus take  \texttt{maxPause} time.\end{quote}
(2) GC\_step Mode

\begin{quote}This allows the garbage collector to perform some work for up to \texttt{us} time. This is useful to call in a main loop to ensure the garbage collector can do its work. To bind all garbage collector activity to a \texttt{GC\_step} call, deactivate the garbage collector with \texttt{GC\_disable} at program startup. If \texttt{strongAdvice} is set to \texttt{true}, then the garbage collector will be forced to perform collection cycle. Otherwise, the garbage collector may decide not to do anything, if there is not much garbage to collect. You may also specify the current stack size via \texttt{stackSize} parameter. It can improve performance, when you know that there are no unique Nim references below certain point on the stack. Make sure the size you specify is greater than the potential worst case size.\end{quote}
These procs provide a "best effort" realtime guarantee; in particular the cycle collector is not aware of deadlines. Deactivate it to get more predictable realtime behaviour. Tests show that a 1ms max pause time will be met in almost all cases on modern CPUs (with the cycle collector disabled).

\rsthB{Time measurement with garbage collectors}\label{time-measurement-with-garbage-collectors}
The garbage collectors's way of measuring time uses (see \texttt{lib/system/timers.nim} for the implementation):

\begin{enumerate}\item \texttt{QueryPerformanceCounter} and \texttt{QueryPerformanceFrequency} on Windows.
\item \texttt{mach\_absolute\_time} on Mac OS X.
\item \texttt{gettimeofday} on Posix systems.
\end{enumerate}
As such it supports a resolution of nanoseconds internally; however the API uses microseconds for convenience.

Define the symbol \texttt{reportMissedDeadlines} to make the garbage collector output whenever it missed a deadline. The reporting will be enhanced and supported by the API in later versions of the collector.

\rsthB{Tweaking the garbage collector}\label{tweaking-the-garbage-collector}
The collector checks whether there is still time left for its work after every \texttt{workPackage}'th iteration. This is currently set to 100 which means that up to 100 objects are traversed and freed before it checks again. Thus \texttt{workPackage} affects the timing granularity and may need to be tweaked in highly specialized environments or for older hardware.

\rsthA{Keeping track of memory}\label{keeping-track-of-memory}
If you need to pass around memory allocated by Nim to C, you can use the procs \texttt{GC\_ref} and \texttt{GC\_unref} to mark objects as referenced to avoid them being freed by the garbage collector. Other useful procs from \href{system.html}{system} you can use to keep track of memory are:

\begin{itemize}\item \texttt{getTotalMem()} Returns the amount of total memory managed by the garbage collector.
\item \texttt{getOccupiedMem()} Bytes reserved by the garbage collector and used by objects.
\item \texttt{getFreeMem()} Bytes reserved by the garbage collector and not in use.
\item \texttt{GC\_getStatistics()} Garbage collector statistics as a human-readable string.
\end{itemize}
These numbers are usually only for the running thread, not for the whole heap, with the exception of \texttt{--gc:boehm} and \texttt{--gc:go}.

In addition to \texttt{GC\_ref} and \texttt{GC\_unref} you can avoid the garbage collector by manually allocating memory with procs like \texttt{alloc}, \texttt{alloc0}, \texttt{allocShared}, \texttt{allocShared0} or \texttt{allocCStringArray}. The garbage collector won't try to free them, you need to call their respective \emph{dealloc} pairs (\texttt{dealloc}, \texttt{deallocShared}, \texttt{deallocCStringArray}, etc) when you are done with them or they will leak.

\rsthA{Heap dump}\label{heap-dump}
The heap dump feature is still in its infancy, but it already proved useful for us, so it might be useful for you. To get a heap dump, compile with \texttt{-d:nimTypeNames} and call \texttt{dumpNumberOfInstances} at a strategic place in your program. This produces a list of used types in your program and for every type the total amount of object instances for this type as well as the total amount of bytes these instances take up. This list is currently unsorted! You need to use external shell script hacking to sort it.

The numbers count the number of objects in all garbage collector heaps, they refer to all running threads, not only to the current thread. (The current thread would be the thread that calls \texttt{dumpNumberOfInstances}.) This might change in later versions. 




\end{document}
