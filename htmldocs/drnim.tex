% This file was generated by Nim.
% Generated: 2020-08-22 06:37:23 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{DrNim User Guide 1.3.5}
\author{Andreas Rumpf}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

\tableofcontents \newpage
\rsthA{Introduction}\label{introduction}
This document describes the usage of the \emph{DrNim} tool. DrNim combines the Nim frontend with the \href{https://github.com/Z3Prover/z3}{Z3} proof engine in order to allow verify / validate software written in Nim. DrNim's command line options are the same as the Nim compiler's.

DrNim currently only checks the sections of your code that are marked via \texttt{staticBoundChecks: on}:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{push} \spanIdentifier{staticBoundChecks}\spanPunctuation{:} \spanIdentifier{on}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanComment{\# <--- code section here ---->}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pop}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
DrNim currently only tries to prove array indexing or subrange checks, overflow errors are \emph{not} prevented. Overflows will be checked for in the future.

Later versions of the \textbf{Nim compiler} will \textbf{assume} that the checks inside the \texttt{staticBoundChecks: on} environment have been proven correct and so it will \textbf{omit} the runtime checks. If you do not want this behavior, use instead \texttt{\symbol{123}.push staticBoundChecks: defined(nimDrNim).\symbol{125}}. This way the Nim compiler remains unaware of the performed proofs but DrNim will prove your code.

\rsthA{Installation}\label{installation}
Run \texttt{koch drnim}, the executable will afterwards be in \texttt{\$nim/bin/drnim}.

\rsthA{Motivating Example}\label{motivating-example}
The follow example highlights what DrNim can easily do, even without additional annotations:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{push} \spanIdentifier{staticBoundChecks}\spanPunctuation{:} \spanIdentifier{on}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{proc} \spanIdentifier{sum}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{openArray}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{:}
    \spanIdentifier{result} \spanOperator{+=} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}

\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pop}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanIdentifier{echo} \spanIdentifier{sum}\spanPunctuation{(}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
This program contains a famous "index out of bounds" bug. DrNim detects it and produces the following error message:\begin{rstpre}

cannot prove: i <= len(a) + -1; counter example: i -> 0 a.len -> 0 \symbol{91}IndexCheck\symbol{93}
\end{rstpre}


In other words for \texttt{i == 0} and \texttt{a.len == 0} (for example!) there would be an index out of bounds error.

\rsthA{Pre-, postconditions and invariants}\label{preminus-postconditions-and-invariants}
DrNim adds 4 additional annotations (pragmas) to Nim:

\begin{itemize}\item requires\label{requires_1}
\item ensures\label{ensures_1}
\item invariant\label{invariant_1}
\item assume\label{assume_1}
\end{itemize}
These pragmas are ignored by the Nim compiler so that they don't have to be disabled via \texttt{when defined(nimDrNim)}.

\rsthB{Invariant}\label{preminus-postconditions-and-invariants-invariant}
An \texttt{invariant} is a proposition that must be true after every loop iteration, it's tied to the loop body it's part of.

\rsthB{Requires}\label{preminus-postconditions-and-invariants-requires}
A \texttt{requires} annotation describes what the function expects to be true before it's called so that it can perform its operation. A \texttt{requires} annotation is also called a precondition\label{precondition_1}.

\rsthB{Ensures}\label{preminus-postconditions-and-invariants-ensures}
An \texttt{ensures} annotation describes what will be true after the function call. An \texttt{ensures} annotation is also called a postcondition\label{postcondition_1}.

\rsthB{Assume}\label{preminus-postconditions-and-invariants-assume}
An \texttt{assume} annotation describes what DrNim should \textbf{assume} to be true in this section of the program. It is an unsafe escape mechanism comparable to Nim's \texttt{cast} statement. Use it only when you really know better than DrNim. You should add a comment to a paper that proves the proposition you assume.

\rsthA{Example: insertionSort}\label{examplecolon-insertionsort}
\textbf{Note}: This example does not yet work with DrNim.

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{std} \spanOperator{/} \spanIdentifier{logic}

\spanKeyword{proc} \spanIdentifier{insertionSort}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{openArray}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}
    \spanIdentifier{ensures}\spanPunctuation{:} \spanIdentifier{forall}\spanPunctuation{(}\spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{1.}\spanOperator{.<}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanOperator{-}\spanDecNumber{1}\spanPunctuation{\symbol{93}} \spanOperator{<=} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  
  \spanKeyword{for} \spanIdentifier{k} \spanKeyword{in} \spanDecNumber{1} \spanOperator{..<} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{:}
    \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{invariant}\spanPunctuation{:} \spanDecNumber{1} \spanOperator{<=} \spanIdentifier{k} \spanKeyword{and} \spanIdentifier{k} \spanOperator{<=} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{len}\spanOperator{.}\spanPunctuation{\symbol{125}}
    \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{invariant}\spanPunctuation{:} \spanIdentifier{forall}\spanPunctuation{(}\spanIdentifier{j} \spanKeyword{in} \spanFloatNumber{1.}\spanOperator{.<}\spanIdentifier{k}\spanPunctuation{,} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.<}\spanIdentifier{j}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{<=} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{j}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}}
    \spanKeyword{var} \spanIdentifier{t} \spanOperator{=} \spanIdentifier{k}
    \spanKeyword{while} \spanIdentifier{t} \spanOperator{>} \spanDecNumber{0} \spanKeyword{and} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{t}\spanOperator{-}\spanDecNumber{1}\spanPunctuation{\symbol{93}} \spanOperator{>} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{t}\spanPunctuation{\symbol{93}}\spanPunctuation{:}
      \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{invariant}\spanPunctuation{:} \spanIdentifier{k} \spanOperator{<} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{len}\spanOperator{.}\spanPunctuation{\symbol{125}}
      \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{invariant}\spanPunctuation{:} \spanDecNumber{0} \spanOperator{<=} \spanIdentifier{t} \spanKeyword{and} \spanIdentifier{t} \spanOperator{<=} \spanIdentifier{k}\spanOperator{.}\spanPunctuation{\symbol{125}}
      \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{invariant}\spanPunctuation{:} \spanIdentifier{forall}\spanPunctuation{(}\spanIdentifier{j} \spanKeyword{in} \spanFloatNumber{1.}\spanOperator{.}\spanIdentifier{k}\spanPunctuation{,} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.<}\spanIdentifier{j}\spanPunctuation{,} \spanIdentifier{j} \spanOperator{==} \spanIdentifier{t} \spanKeyword{or} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{<=} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{j}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}}
      \spanIdentifier{swap} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{t}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{t}\spanOperator{-}\spanDecNumber{1}\spanPunctuation{\symbol{93}}
      \spanIdentifier{dec} \spanIdentifier{t}
\end{rstpre}
Unfortunately the invariants required to prove this code correct take more code than the imperative instructions. However this effort can be compensated by the fact that the result needs very little testing. Be aware though that DrNim only proves that after \texttt{insertionSort} this condition holds:\begin{rstpre}

forall(i in 1..<a.len, a\symbol{91}i-1\symbol{93} <= a\symbol{91}i\symbol{93})
\end{rstpre}


This is required, but not sufficient to describe that a \texttt{sort} operation was performed. For example, the same postcondition is true for this proc which doesn't sort at all:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{std} \spanOperator{/} \spanIdentifier{logic}

\spanKeyword{proc} \spanIdentifier{insertionSort}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{openArray}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}
    \spanIdentifier{ensures}\spanPunctuation{:} \spanIdentifier{forall}\spanPunctuation{(}\spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{1.}\spanOperator{.<}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanOperator{-}\spanDecNumber{1}\spanPunctuation{\symbol{93}} \spanOperator{<=} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanComment{\# does not sort, overwrites \symbol{96}a\symbol{96}'s contents!}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.<}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{:} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{i}
\end{rstpre}
\rsthA{Syntax of propositions}\label{syntax-of-propositions}
The basic syntax is \texttt{ensures|requires|invariant: <prop>}. A \texttt{prop} is either a comparison or a compound:\begin{rstpre}

prop = nim\_bool\_expression
     | prop 'and' prop
     | prop 'or' prop
     | prop '->' prop \# implication
     | prop '<->' prop
     | 'not' prop
     | '(' prop ')' \# you can group props via ()
     | forallProp
     | existsProp

forallProp = 'forall' '(' quantifierList ',' prop ')'
existsProp = 'exists' '(' quantifierList ',' prop ')'

quantifierList = quantifier (',' quantifier)*
quantifier = <new identifier> 'in' nim\_iteration\_expression
\end{rstpre}


\texttt{nim\_iteration\_expression} here is an ordinary expression of Nim code that describes an iteration space, for example \texttt{1..4} or \texttt{1..<a.len}.

\texttt{nim\_bool\_expression} here is an ordinary expression of Nim code of type \texttt{bool} like \texttt{a == 3} or \texttt{23 > a.len}.

The supported subset of Nim code that can be used in these expressions is currently underspecified but \texttt{let} variables, function parameters and \texttt{result} (which represents the function's final result) are amenable for verification. The expressions must not have any side-effects and must terminate.

The operators \texttt{forall}, \texttt{exists}, \texttt{->}, \texttt{<->} have to imported from \texttt{std / logic}. 




\end{document}
