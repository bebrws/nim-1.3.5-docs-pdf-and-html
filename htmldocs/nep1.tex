% This file was generated by Nim.
% Generated: 2020-08-22 06:37:34 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{Nim Enhancement Proposal \#1 - Standard Library Style Guide 1.3.5}
\author{Clay Sweetser, Dominik Picheta}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

\tableofcontents \newpage
\rsthA{Introduction}\label{introduction}
Although Nim supports a variety of code and formatting styles, it is nevertheless beneficial that certain community efforts, such as the standard library, should follow a consistent set of style guidelines when suitable. This enhancement proposal aims to list a series of guidelines that the standard library should follow.

Note that there can be exceptions to these rules. Nim being as flexible as it is, there will be parts of this style guide that don't make sense in certain contexts. Furthermore, just as \href{http://legacy.python.org/dev/peps/pep-0008/}{Python's style guide} changes over time, this style guide will too.

These rules will only be enforced for contributions to the Nim codebase and official projects, such as the Nim compiler, the standard library, and the various official tools such as C2Nim.

\rsthB{Spacing and Whitespace Conventions}\label{introduction-spacing-and-whitespace-conventions}
\begin{itemize}\item Lines should be no longer than 80 characters. Limiting the amount of information present on each line makes for more readable code - the reader has smaller chunks to process.
\item Two spaces should be used for indentation of blocks; tabstops are not allowed (the compiler enforces this). Using spaces means that the appearance of code is more consistent across editors. Unlike spaces, tabstop width varies across editors, and not all editors provide means of changing this width.
\item Although use of whitespace for stylistic reasons other than the ones endorsed by this guide are allowed, careful thought should be put into such practices. Not all editors support automatic alignment of code sections, and re-aligning long sections of code by hand can quickly become tedious.\begin{rstpre}
\spanComment{\# This is bad, as the next time someone comes}
\spanComment{\# to edit this code block, they}
\spanComment{\# must re-align all the assignments again:}
\spanKeyword{type}
  \spanIdentifier{WordBool}\spanOperator{*}    \spanOperator{=} \spanIdentifier{int16}
  \spanIdentifier{CalType}\spanOperator{*}     \spanOperator{=} \spanIdentifier{int}
  \spanOperator{...} \spanComment{\# 5 lines later}
  \spanIdentifier{CalId}\spanOperator{*}       \spanOperator{=} \spanIdentifier{int}
  \spanIdentifier{LongLong}\spanOperator{*}    \spanOperator{=} \spanIdentifier{int64}
  \spanIdentifier{LongLongPtr}\spanOperator{*} \spanOperator{=} \spanKeyword{ptr} \spanIdentifier{LongLong}
\end{rstpre}

\end{itemize}
\rsthB{Naming Conventions}\label{introduction-naming-conventions}
Note: While the rules outlined below are the \emph{current} naming conventions, these conventions have not always been in place. Previously, the naming conventions for identifiers followed the Pascal tradition of prefixes which indicated the base type of the identifier - PFoo for pointer and reference types, TFoo for value types, EFoo for exceptions, etc. Though this has since changed, there are many places in the standard library which still use this convention. Such style remains in place purely for legacy reasons, and will be changed in the future.

\begin{itemize}\item Type identifiers should be in PascalCase. All other identifiers should be in camelCase with the exception of constants which \textbf{may} use PascalCase but are not required to.\begin{rstpre}
\spanComment{\# Constants can start with either a lower case or upper case letter.}
\spanKeyword{const} \spanIdentifier{aConstant} \spanOperator{=} \spanDecNumber{42}
\spanKeyword{const} \spanIdentifier{FooBar} \spanOperator{=} \spanFloatNumber{4.2}

\spanKeyword{var} \spanIdentifier{aVariable} \spanOperator{=} \spanStringLit{"Meep"} \spanComment{\# Variables must start with a lowercase letter.}

\spanComment{\# Types must start with an uppercase letter.}
\spanKeyword{type}
  \spanIdentifier{FooBar} \spanOperator{=} \spanKeyword{object}
\end{rstpre}
For constants coming from a C/C++ wrapper, ALL\_UPPERCASE are allowed, but ugly. (Why shout CONSTANT? Constants do no harm, variables do!)


\item When naming types that come in value, pointer, and reference varieties, use a regular name for the variety that is to be used the most, and add a "Obj", "Ref", or "Ptr" suffix for the other varieties. If there is no single variety that will be used the most, add the suffixes to the pointer variants only. The same applies to C/C++ wrappers.\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Handle} \spanOperator{=} \spanKeyword{object} \spanComment{\# Will be used most often}
    \spanIdentifier{fd}\spanPunctuation{:} \spanIdentifier{int64}
  \spanIdentifier{HandleRef} \spanOperator{=} \spanKeyword{ref} \spanIdentifier{Handle} \spanComment{\# Will be used less often}
\end{rstpre}

\end{itemize}
\begin{itemize}\item Exception and Error types should have the "Error" or "Defect" suffix.\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{ValueError} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{CatchableError}
  \spanIdentifier{AssertionDefect} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Defect}
  \spanIdentifier{Foo} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Exception} \spanComment{\# bad style, try to inherit CatchableError or Defect}
\end{rstpre}

\end{itemize}
\begin{itemize}\item Unless marked with the \texttt{\symbol{123}.pure.\symbol{125}} pragma, members of enums should have an identifying prefix, such as an abbreviation of the enum's name.\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{PathComponent} \spanOperator{=} \spanKeyword{enum}
    \spanIdentifier{pcDir}
    \spanIdentifier{pcLinkToDir}
    \spanIdentifier{pcFile}
    \spanIdentifier{pcLinkToFile}
\end{rstpre}

\end{itemize}
\begin{itemize}\item Non-pure enum values should use camelCase whereas pure enum values should use PascalCase.\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{PathComponent} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pure}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{enum}
    \spanIdentifier{Dir}
    \spanIdentifier{LinkToDir}
    \spanIdentifier{File}
    \spanIdentifier{LinkToFile}
\end{rstpre}

\end{itemize}
\begin{itemize}\item In the age of HTTP, HTML, FTP, TCP, IP, UTF, WWW it is foolish to pretend these are somewhat special words requiring all uppercase. Instead treat them as what they are: Real words. So it's \texttt{parseUrl} rather than \texttt{parseURL}, \texttt{checkHttpHeader} instead of \texttt{checkHTTPHeader} etc.
\item Operations like \texttt{mitems} or \texttt{mpairs} (or the now deprecated \texttt{mget}) that allow a \emph{mutating view} into some data structure should start with an \texttt{m}.
\item When both in-place mutation and 'returns transformed copy' are available the latter is a past participle of the former:\begin{itemize}\item reverse and reversed in algorithm
\item sort and sorted
\item rotate and rotated
\end{itemize}

\item When the 'returns transformed copy' version already exists like \texttt{strutils.replace} an in-place version should get an \texttt{-In} suffix (\texttt{replaceIn} for this example).
\end{itemize}
\begin{itemize}\item Use \texttt{subjectVerb}, not \texttt{verbSubject}, eg: \texttt{fileExists}, not \texttt{existsFile}.
\end{itemize}
The stdlib API is designed to be \textbf{easy to use} and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action. The ultimate goal is that the programmer can \emph{guess} a name.

The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful.

\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|}
\hline
\textbf{English word} & \textbf{To use} & \textbf{Notes}\\
\hline
initialize & initT  & \texttt{init} is used to create a value type \texttt{T}\\
\hline
new & newP  & \texttt{new} is used to create a reference type \texttt{P}\\
\hline
find & find & should return the position where something was found; for a bool result use \texttt{contains}\\
\hline
contains & contains & often short for \texttt{find() >= 0}\\
\hline
append & add & use \texttt{add} instead of \texttt{append}\\
\hline
compare & cmp & should return an int with the \texttt{< 0} \texttt{== 0} or \texttt{> 0} semantics; for a bool result use \texttt{sameXYZ}\\
\hline
put & put, \texttt{\symbol{91}\symbol{93}=} & consider overloading \texttt{\symbol{91}\symbol{93}=} for put\\
\hline
get & get, \texttt{\symbol{91}\symbol{93}} & consider overloading \texttt{\symbol{91}\symbol{93}} for get; consider to not use \texttt{get} as a prefix: \texttt{len} instead of \texttt{getLen}\\
\hline
length & len & also used for \emph{number of elements}\\
\hline
size & size, len & size should refer to a byte size\\
\hline
capacity & cap & \\
\hline
memory & mem & implies a low-level operation\\
\hline
items & items & default iterator over a collection\\
\hline
pairs & pairs & iterator over (key, value) pairs\\
\hline
delete & delete, del & del is supposed to be faster than delete, because it does not keep the order; delete keeps the order\\
\hline
remove & delete, del & inconsistent right now\\
\hline
include & incl & \\
\hline
exclude & excl & \\
\hline
command & cmd & \\
\hline
execute & exec & \\
\hline
environment & env & \\
\hline
variable & var & \\
\hline
value & value, val  & val is preferred, inconsistent right now\\
\hline
executable & exe & \\
\hline
directory & dir & \\
\hline
path & path & path is the string "/usr/bin" (for example), dir is the content of "/usr/bin"; inconsistent right now\\
\hline
extension & ext & \\
\hline
separator & sep & \\
\hline
column & col, column  & col is preferred, inconsistent right now\\
\hline
application & app & \\
\hline
configuration & cfg & \\
\hline
message & msg & \\
\hline
argument & arg & \\
\hline
object & obj & \\
\hline
parameter & param & \\
\hline
operator & opr & \\
\hline
procedure & proc & \\
\hline
function & func & \\
\hline
coordinate & coord & \\
\hline
rectangle & rect & \\
\hline
point & point & \\
\hline
symbol & sym & \\
\hline
literal & lit & \\
\hline
string & str & \\
\hline
identifier & ident & \\
\hline
indentation & indent & \\
\hline
\end{rsttab}\end{table}\rsthB{Coding Conventions}\label{introduction-coding-conventions}
\begin{itemize}\item The 'return' statement should ideally be used when its control-flow properties are required. Use a procedure's implicit 'result' variable whenever possible. This improves readability.\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{repeat}\spanPunctuation{(}\spanIdentifier{text}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanStringLit{""}
  
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanDecNumber{0} \spanOperator{..} \spanIdentifier{x}\spanPunctuation{:}
    \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add}\spanPunctuation{(}\spanOperator{\$}\spanIdentifier{i}\spanPunctuation{)}
\end{rstpre}

\end{itemize}
\begin{itemize}\item Use a proc when possible, only using the more powerful facilities of macros, templates, iterators, and converters when necessary.
\item Use the \texttt{let} statement (not the \texttt{var} statement) when declaring variables that do not change within their scope. Using the \texttt{let} statement ensures that variables remain immutable, and gives those who read the code a better idea of the code's purpose.
\end{itemize}
\rsthB{Conventions for multi-line statements and expressions}\label{introduction-conventions-for-multiminusline-statements-and-expressions}
\begin{itemize}\item Tuples which are longer than one line should indent their parameters to align with the parameters above it.\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{LongTupleA} \spanOperator{=} \spanKeyword{tuple}\spanPunctuation{\symbol{91}}\spanIdentifier{wordyTupleMemberOne}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{wordyTupleMemberTwo}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{,}
                     \spanIdentifier{wordyTupleMemberThree}\spanPunctuation{:} \spanIdentifier{float}\spanPunctuation{\symbol{93}}
\end{rstpre}

\end{itemize}
\begin{itemize}\item Similarly, any procedure and procedure type declarations that are longer than one line should do the same thing.\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{EventCallback} \spanOperator{=} \spanKeyword{proc} \spanPunctuation{(}\spanIdentifier{timeReceived}\spanPunctuation{:} \spanIdentifier{Time}\spanPunctuation{,} \spanIdentifier{errorCode}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{event}\spanPunctuation{:} \spanIdentifier{Event}\spanPunctuation{,}
                        \spanIdentifier{output}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{string}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{lotsOfArguments}\spanPunctuation{(}\spanIdentifier{argOne}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{argTwo}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{argThree}\spanPunctuation{:} \spanIdentifier{float}\spanPunctuation{,}
                     \spanIdentifier{argFour}\spanPunctuation{:} \spanKeyword{proc}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{argFive}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int}
                    \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{heyLookALongPragma}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
\end{rstpre}

\end{itemize}
\begin{itemize}\item Multi-line procedure calls should continue on the same column as the opening parenthesis (like multi-line procedure declarations).\begin{rstpre}
\spanIdentifier{startProcess}\spanPunctuation{(}\spanIdentifier{nimExecutable}\spanPunctuation{,} \spanIdentifier{currentDirectory}\spanPunctuation{,} \spanIdentifier{compilerArguments}
             \spanIdentifier{environment}\spanPunctuation{,} \spanIdentifier{processOptions}\spanPunctuation{)}
\end{rstpre}

\end{itemize}



\end{document}
