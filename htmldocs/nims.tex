% This file was generated by Nim.
% Generated: 2020-08-22 06:37:34 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{NimScript }
\author{}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

Strictly speaking, \texttt{NimScript} is the subset of Nim that can be evaluated by Nim's builtin virtual machine (VM). This VM is used for Nim's compiletime function evaluation features.

The \texttt{nim} executable processes the \texttt{.nims} configuration files in the following directories (in this order; later files overwrite previous settings):

\begin{enumerate}\item If environment variable \texttt{XDG\_CONFIG\_HOME} is defined, \texttt{\$XDG\_CONFIG\_HOME/nim/config.nims} or \texttt{\symbol{126}/.config/nim/config.nims} (POSIX) or \texttt{\%APPDATA\%/nim/config.nims} (Windows). This file can be skipped with the \texttt{--skipUserCfg} command line option.
\item \texttt{\$parentDir/config.nims} where \texttt{\$parentDir} stands for any parent directory of the project file's path. These files can be skipped with the \texttt{--skipParentCfg} command line option.
\item \texttt{\$projectDir/config.nims} where \texttt{\$projectDir} stands for the project's path. This file can be skipped with the \texttt{--skipProjCfg} command line option.
\item A project can also have a project specific configuration file named \texttt{\$project.nims} that resides in the same directory as \texttt{\$project.nim}. This file can be skipped with the same \texttt{--skipProjCfg} command line option.
\end{enumerate}
For available procs and implementation details see \href{nimscript.html}{nimscript}.

\rsthA{Limitations}\label{limitations}
NimScript is subject to some limitations caused by the implementation of the VM (virtual machine):

\begin{itemize}\item Nim's FFI (foreign function interface) is not available in NimScript. This means that any stdlib module which relies on \texttt{importc} can not be used in the VM.
\item \texttt{ptr} operations are are hard to emulate with the symbolic representation the VM uses. They are available and tested extensively but there are bugs left.
\item \texttt{var T} function arguments rely on \texttt{ptr} operations internally and might also be problematic in some cases.
\item More than one level of \texttt{ref} is generally not supported (for example, the type \texttt{ref ref int}).
\item Multimethods are not available.
\item \texttt{random.randomize()} requires an \texttt{int64} explicitly passed as argument, you \emph{must} pass a Seed integer.
\end{itemize}
\rsthA{Standard library modules}\label{standard-library-modules}
At least the following standard library modules are available:

\begin{itemize}\item \href{macros.html}{macros}
\item \href{os.html}{os}
\item \href{strutils.html}{strutils}
\item \href{math.html}{math}
\item \href{distros.html}{distros}
\item \href{sugar.html}{sugar}
\item \href{algorithm.html}{algorithm}
\item \href{base64.html}{base64}
\item \href{bitops.html}{bitops}
\item \href{chains.html}{chains}
\item \href{colors.html}{colors}
\item \href{complex.html}{complex}
\item \href{htmlgen.html}{htmlgen}
\item \href{httpcore.html}{httpcore}
\item \href{lenientops.html}{lenientops}
\item \href{mersenne.html}{mersenne}
\item \href{options.html}{options}
\item \href{parseutils.html}{parseutils}
\item \href{punycode.html}{punycode}
\item \href{punycode.html}{random}
\item \href{stats.html}{stats}
\item \href{strformat.html}{strformat}
\item \href{strmisc.html}{strmisc}
\item \href{strscans.html}{strscans}
\item \href{unicode.html}{unicode}
\item \href{uri.html}{uri}
\item \href{editdistance.html}{std/editdistance}
\item \href{wordwrap.html}{std/wordwrap}
\item \href{sums.html}{std/sums}
\item \href{parsecsv.html}{parsecsv}
\item \href{parsecfg.html}{parsecfg}
\item \href{parsesql.html}{parsesql}
\item \href{xmlparser.html}{xmlparser}
\item \href{htmlparser.html}{htmlparser}
\item \href{ropes.html}{ropes}
\item \href{json.html}{json}
\item \href{parsejson.html}{parsejson}
\item \href{strtabs.html}{strtabs}
\item \href{unidecode.html}{unidecode}
\end{itemize}
In addition to the standard Nim syntax (\href{system.html}{system} module), NimScripts support the procs and templates defined in the \href{nimscript.html}{nimscript} module too.

See also:

\begin{itemize}\item \href{https://github.com/nim-lang/Nim/blob/devel/tests/test\_nimscript.nims}{Check the tests for more information about modules compatible with NimScript.}
\end{itemize}
\rsthA{NimScript as a configuration file}\label{nimscript-as-a-configuration-file}
A command-line switch \texttt{--FOO} is written as \texttt{switch("FOO")} in NimScript. Similarly, command-line \texttt{--FOO:VAL} translates to \texttt{switch("FOO", "VAL")}.

Here are few examples of using the \texttt{switch} proc:

\begin{rstpre}
\spanComment{\# command-line: --opt:size}
\spanIdentifier{switch}\spanPunctuation{(}\spanStringLit{"opt"}\spanPunctuation{,} \spanStringLit{"size"}\spanPunctuation{)}
\spanComment{\# command-line: --define:foo or -d:foo}
\spanIdentifier{switch}\spanPunctuation{(}\spanStringLit{"define"}\spanPunctuation{,} \spanStringLit{"foo"}\spanPunctuation{)}
\spanComment{\# command-line: --forceBuild}
\spanIdentifier{switch}\spanPunctuation{(}\spanStringLit{"forceBuild"}\spanPunctuation{)}
\end{rstpre}
NimScripts also support \texttt{--} templates for convenience, which look like command-line switches written as-is in the NimScript file. So the above example can be rewritten as:

\begin{rstpre}
\spanOperator{--}\spanIdentifier{opt}\spanPunctuation{:}\spanIdentifier{size}
\spanOperator{--}\spanIdentifier{define}\spanPunctuation{:}\spanIdentifier{foo}
\spanOperator{--}\spanIdentifier{forceBuild}
\end{rstpre}
\textbf{Note}: In general, the \emph{define} switches can also be set in NimScripts using \texttt{switch} or \texttt{--}, as shown in above examples. Only the \texttt{release} define (\texttt{-d:release}) cannot be set in NimScripts.

\rsthA{NimScript as a build tool}\label{nimscript-as-a-build-tool}
The \texttt{task} template that the \texttt{system} module defines allows a NimScript file to be used as a build tool. The following example defines a task \texttt{build} that is an alias for the \texttt{c} command:

\begin{rstpre}
\spanIdentifier{task} \spanIdentifier{build}\spanPunctuation{,} \spanStringLit{"builds an example"}\spanPunctuation{:}
  \spanIdentifier{setCommand} \spanStringLit{"c"}
\end{rstpre}
In fact, as a convention the following tasks should be available:

\begin{table}\begin{rsttab}{|X|X|X|X|X|}
\hline
\textbf{Task} & \textbf{Description}\\
\hline
\texttt{help} & List all the available NimScript tasks along with their docstrings.\\
\hline
\texttt{build} & Build the project with the required backend (\texttt{c}, \texttt{cpp} or \texttt{js}).\\
\hline
\texttt{tests} & Runs the tests belonging to the project.\\
\hline
\texttt{bench} & Runs benchmarks belonging to the project.\\
\hline
\end{rsttab}\end{table}Look at the module \href{distros.html}{distros} for some support of the OS's native package managers.

\rsthA{Nimble integration}\label{nimble-integration}
See the \href{https://github.com/nim-lang/nimble\#readme}{Nimble readme} for more information.

\rsthA{Standalone NimScript}\label{standalone-nimscript}
NimScript can also be used directly as a portable replacement for Bash and Batch files. Use \texttt{nim myscript.nims} to run \texttt{myscript.nims}. For example, installation of Nimble could be accomplished with this simple script:

\begin{rstpre}
\spanIdentifier{mode} \spanOperator{=} \spanIdentifier{ScriptMode}\spanOperator{.}\spanIdentifier{Verbose}

\spanKeyword{var} \spanIdentifier{id} \spanOperator{=} \spanDecNumber{0}
\spanKeyword{while} \spanIdentifier{dirExists}\spanPunctuation{(}\spanStringLit{"nimble"} \spanOperator{\&} \spanOperator{\$}\spanIdentifier{id}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{inc} \spanIdentifier{id}

\spanIdentifier{exec} \spanStringLit{"git clone https://github.com/nim-lang/nimble.git nimble"} \spanOperator{\&} \spanOperator{\$}\spanIdentifier{id}

\spanIdentifier{withDir} \spanStringLit{"nimble"} \spanOperator{\&} \spanOperator{\$}\spanIdentifier{id} \spanOperator{\&} \spanStringLit{"/src"}\spanPunctuation{:}
  \spanIdentifier{exec} \spanStringLit{"nim c nimble"}

\spanIdentifier{mvFile} \spanStringLit{"nimble"} \spanOperator{\&} \spanOperator{\$}\spanIdentifier{id} \spanOperator{\&} \spanStringLit{"/src/nimble"}\spanOperator{.}\spanIdentifier{toExe}\spanPunctuation{,} \spanStringLit{"bin/nimble"}\spanOperator{.}\spanIdentifier{toExe}
\end{rstpre}
On Unix, you can also use the shebang \texttt{\#!/usr/bin/env nim}, as long as your filename ends with \texttt{.nims}:

\begin{rstpre}
\spanComment{\#!/usr/bin/env nim}
\spanIdentifier{mode} \spanOperator{=} \spanIdentifier{ScriptMode}\spanOperator{.}\spanIdentifier{Silent}

\spanIdentifier{echo} \spanStringLit{"hello world"}
\end{rstpre}
Use \texttt{\#!/usr/bin/env -S nim --hints:off} to disable hints.

\rsthA{Benefits}\label{benefits}
\rsthB{Cross-Platform}\label{crossminusplatform}
It is a cross-platform scripting language that can run where Nim can run, e.g. you can not run Batch or PowerShell on Linux or Mac, the Bash for Linux might not run on Mac, there are no unit tests tools for Batch, etc.

NimScript can detect on which platform, operating system, architecture, and even which Linux distribution is running on, allowing the same script to support a lot of systems.

See the following (incomplete) example:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{distros}

\spanComment{\# Architectures.}
\spanKeyword{if} \spanIdentifier{defined}\spanPunctuation{(}\spanIdentifier{amd64}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Architecture is x86 64Bits"}
\spanKeyword{elif} \spanIdentifier{defined}\spanPunctuation{(}\spanIdentifier{i386}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Architecture is x86 32Bits"}
\spanKeyword{elif} \spanIdentifier{defined}\spanPunctuation{(}\spanIdentifier{arm}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Architecture is ARM"}

\spanComment{\# Operating Systems.}
\spanKeyword{if} \spanIdentifier{defined}\spanPunctuation{(}\spanIdentifier{linux}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Operating System is GNU Linux"}
\spanKeyword{elif} \spanIdentifier{defined}\spanPunctuation{(}\spanIdentifier{windows}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Operating System is Microsoft Windows"}
\spanKeyword{elif} \spanIdentifier{defined}\spanPunctuation{(}\spanIdentifier{macosx}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Operating System is Apple OS X"}

\spanComment{\# Distros.}
\spanKeyword{if} \spanIdentifier{detectOs}\spanPunctuation{(}\spanIdentifier{Ubuntu}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Distro is Ubuntu"}
\spanKeyword{elif} \spanIdentifier{detectOs}\spanPunctuation{(}\spanIdentifier{ArchLinux}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Distro is ArchLinux"}
\spanKeyword{elif} \spanIdentifier{detectOs}\spanPunctuation{(}\spanIdentifier{Debian}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Distro is Debian"}
\end{rstpre}
\rsthB{Uniform Syntax}\label{uniform-syntax}
The syntax, style, and rest of the ecosystem is the same as for compiled Nim, that means there is nothing new to learn, no context switch for developers.

\rsthB{Powerful Metaprogramming}\label{powerful-metaprogramming}
NimScript can use Nim's templates, macros, types, concepts, effect tracking system, and more, you can create modules that work on compiled Nim and also on interpreted NimScript.

\texttt{func} will still check for side effects, \texttt{debugEcho} also works as expected, making it ideal for functional scripting metaprogramming.

This is an example of a third party module that uses macros and templates to translate text strings on unmodified NimScript:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{nimterlingua}
\spanIdentifier{nimterlingua}\spanPunctuation{(}\spanStringLit{"translations.cfg"}\spanPunctuation{)}
\spanIdentifier{echo} \spanStringLit{"cat"}  \spanComment{\# Run with -d:RU becomes "kot", -d:ES becomes "gato", ...}
\end{rstpre}
translations.cfg

\begin{rstpre}

\symbol{91}cat\symbol{93}
ES = gato
PT = minino
RU = kot
FR = chat
\end{rstpre}
\begin{itemize}\item \href{https://nimble.directory/pkg/nimterlingua}{Nimterlingua}
\end{itemize}
\rsthB{Graceful Fallback}\label{graceful-fallback}
Some features of compiled Nim may not work on NimScript, but often a graceful and seamless fallback degradation is used.

See the following NimScript:

\begin{rstpre}
\spanKeyword{if} \spanIdentifier{likely}\spanPunctuation{(}\spanIdentifier{true}\spanPunctuation{)}\spanPunctuation{:}
  \spanKeyword{discard}
\spanKeyword{elif} \spanIdentifier{unlikely}\spanPunctuation{(}\spanIdentifier{false}\spanPunctuation{)}\spanPunctuation{:}
  \spanKeyword{discard}

\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{compiletime}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanIdentifier{echo} \spanIdentifier{NimVersion}

\spanKeyword{static}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{CompileDate}
\end{rstpre}
\texttt{likely()}, \texttt{unlikely()}, \texttt{static:} and \texttt{\symbol{123}.compiletime.\symbol{125}} will produce no code at all when run on NimScript, but still no error nor warning is produced and the code just works.

\rsthB{Evolving Scripting language}\label{evolving-scripting-language}
NimScript evolves together with Nim, \href{https://github.com/nim-lang/Nim/pulls?utf8=\%E2\%9C\%93\&q=nimscript}{occasionally new features might become available on NimScript} , adapted from compiled Nim or added as new features on both.

\rsthB{Scripting Language with a Package Manager}\label{scripting-language-with-a-package-manager}
You can create your own modules to be compatible with NimScript, and check \href{https://nimble.directory}{Nimble} to search for third party modules that may work on NimScript.

\rsthB{DevOps Scripting}\label{devops-scripting}
You can use NimScript to deploy to production, run tests, build projects, do benchmarks, generate documentation, and all kinds of DevOps/SysAdmin specific tasks.

\begin{itemize}\item \href{https://github.com/kaushalmodi/nim\_config\#list-available-tasks}{An example of a third party NimScript that can be used as a project-agnostic tool.}
\end{itemize}



\end{document}
