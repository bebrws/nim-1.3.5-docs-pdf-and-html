% This file was generated by Nim.
% Generated: 2020-08-22 06:37:34 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{Nim Experimental Features 1.3.5}
\author{Andreas Rumpf}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

\tableofcontents \newpage
\rsthA{About this document}\label{about-this-document}
This document describes features of Nim that are to be considered experimental. Some of these are not covered by the \texttt{.experimental} pragma or \texttt{--experimental} switch because they are already behind a special syntax and one may want to use Nim libraries using these features without using them oneself.

\textbf{Note}: Unless otherwise indicated, these features are not to be removed, but refined and overhauled.

\rsthA{Package level objects}\label{package-level-objects}
Every Nim module resides in a (nimble) package. An object type can be attached to the package it resides in. If that is done, the type can be referenced from other modules as an incomplete\label{incomplete_1} object type. This feature allows to break up recursive type dependencies across module boundaries. Incomplete object types are always passed \texttt{byref} and can only be used in pointer like contexts (\texttt{var/ref/ptr IncompleteObject}) in general since the compiler does not yet know the size of the object. To complete an incomplete object the \texttt{package} pragma has to be used. \texttt{package} implies \texttt{byref}.

As long as a type \texttt{T} is incomplete, neither \texttt{sizeof(T)} nor runtime type information for \texttt{T} is available.

Example:

\begin{rstpre}
\spanComment{\# module A (in an arbitrary package)}
\spanKeyword{type}
  \spanIdentifier{Pack}\spanOperator{.}\spanIdentifier{SomeObject} \spanOperator{=} \spanKeyword{object} \spanComment{\#\# declare as incomplete object of package 'Pack'}
  \spanIdentifier{Triple} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{,} \spanIdentifier{c}\spanPunctuation{:} \spanKeyword{ref} \spanIdentifier{SomeObject} \spanComment{\#\# pointers to incomplete objects are allowed}

\spanComment{\#\# Incomplete objects can be used as parameters:}
\spanKeyword{proc} \spanIdentifier{myproc}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{SomeObject}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}
\end{rstpre}
\begin{rstpre}
\spanComment{\# module B (in package "Pack")}
\spanKeyword{type}
  \spanIdentifier{SomeObject}\spanOperator{*} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{package}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object} \spanComment{\#\# Use 'package' to complete the object}
    \spanIdentifier{s}\spanPunctuation{,} \spanIdentifier{t}\spanPunctuation{:} \spanIdentifier{string}
    \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}
\end{rstpre}
\rsthA{Void type}\label{void-type}
The \texttt{void} type denotes the absence of any type. Parameters of type \texttt{void} are treated as non-existent, \texttt{void} as a return type means that the procedure does not return a value:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{nothing}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{void}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{void} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"ha"}

\spanIdentifier{nothing}\spanPunctuation{(}\spanPunctuation{)} \spanComment{\# writes "ha" to stdout}
\end{rstpre}
The \texttt{void} type is particularly useful for generic code:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{callProc}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{p}\spanPunctuation{:} \spanKeyword{proc} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{when} \spanIdentifier{T} \spanKeyword{is} \spanIdentifier{void}\spanPunctuation{:}
    \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)}
  \spanKeyword{else}\spanPunctuation{:}
    \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{intProc}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}
\spanKeyword{proc} \spanIdentifier{emptyProc}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}

\spanIdentifier{callProc}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{intProc}\spanPunctuation{,} \spanDecNumber{12}\spanPunctuation{)}
\spanIdentifier{callProc}\spanPunctuation{\symbol{91}}\spanIdentifier{void}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{emptyProc}\spanPunctuation{)}
\end{rstpre}
However, a \texttt{void} type cannot be inferred in generic code:

\begin{rstpre}
\spanIdentifier{callProc}\spanPunctuation{(}\spanIdentifier{emptyProc}\spanPunctuation{)}
\spanComment{\# Error: type mismatch: got (proc ())}
\spanComment{\# but expected one of:}
\spanComment{\# callProc(p: proc (T), x: T)}
\end{rstpre}
The \texttt{void} type is only valid for parameters and return types; other symbols cannot have the type \texttt{void}.

\rsthA{Covariance}\label{covariance}
Covariance in Nim can be introduced only through pointer-like types such as \texttt{ptr} and \texttt{ref}. Sequence, Array and OpenArray types, instantiated with pointer-like types will be considered covariant if and only if they are also immutable. The introduction of a \texttt{var} modifier or additional \texttt{ptr} or \texttt{ref} indirections would result in invariant treatment of these types.

\texttt{proc} types are currently always invariant, but future versions of Nim may relax this rule.

User-defined generic types may also be covariant with respect to some of their parameters. By default, all generic params are considered invariant, but you may choose the apply the prefix modifier \texttt{in} to a parameter to make it contravariant or \texttt{out} to make it covariant:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{AnnotatedPtr}\spanPunctuation{\symbol{91}}\spanKeyword{out} \spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=}
    \spanIdentifier{metadata}\spanPunctuation{:} \spanIdentifier{MyTypeInfo}
    \spanIdentifier{p}\spanPunctuation{:} \spanKeyword{ref} \spanIdentifier{T}
  
  \spanIdentifier{RingBuffer}\spanPunctuation{\symbol{91}}\spanKeyword{out} \spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=}
    \spanIdentifier{startPos}\spanPunctuation{:} \spanIdentifier{int}
    \spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}
  
  \spanIdentifier{Action} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"std::function<void ('0)>"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanPunctuation{\symbol{91}}\spanKeyword{in} \spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{object}
\end{rstpre}
When the designated generic parameter is used to instantiate a pointer-like type as in the case of \texttt{AnnotatedPtr} above, the resulting generic type will also have pointer-like covariance:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{GuiWidget} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{RootObj}
  \spanIdentifier{Button} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{GuiWidget}
  \spanIdentifier{ComboBox} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{GuiWidget}

\spanKeyword{var}
  \spanIdentifier{widgetPtr}\spanPunctuation{:} \spanIdentifier{AnnotatedPtr}\spanPunctuation{\symbol{91}}\spanIdentifier{GuiWidget}\spanPunctuation{\symbol{93}}
  \spanIdentifier{buttonPtr}\spanPunctuation{:} \spanIdentifier{AnnotatedPtr}\spanPunctuation{\symbol{91}}\spanIdentifier{Button}\spanPunctuation{\symbol{93}}

\spanOperator{...}

\spanKeyword{proc} \spanIdentifier{drawWidget}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{AnnotatedPtr}\spanPunctuation{\symbol{91}}\spanIdentifier{GuiWidget}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}

\spanComment{\# you can call procs expecting base types by supplying a derived type}
\spanIdentifier{drawWidget}\spanPunctuation{(}\spanIdentifier{buttonPtr}\spanPunctuation{)}

\spanComment{\# and you can convert more-specific pointer types to more general ones}
\spanIdentifier{widgetPtr} \spanOperator{=} \spanIdentifier{buttonPtr}
\end{rstpre}
Just like with regular pointers, covariance will be enabled only for immutable values:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{makeComboBox}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{AnnotatedPtr}\spanPunctuation{\symbol{91}}\spanIdentifier{GuiWidget}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{x}\spanOperator{.}\spanIdentifier{p} \spanOperator{=} \spanIdentifier{new}\spanPunctuation{(}\spanIdentifier{ComboBox}\spanPunctuation{)}

\spanIdentifier{makeComboBox}\spanPunctuation{(}\spanIdentifier{buttonPtr}\spanPunctuation{)} \spanComment{\# Error, AnnotatedPtr\symbol{91}Button\symbol{93} cannot be modified}
                        \spanComment{\# to point to a ComboBox}
\end{rstpre}
On the other hand, in the \texttt{RingBuffer} example above, the designated generic param is used to instantiate the non-pointer \texttt{seq} type, which means that the resulting generic type will have covariance that mimics an array or sequence (i.e. it will be covariant only when instantiated with \texttt{ptr} and \texttt{ref} types):

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Base} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{RootObj}
  \spanIdentifier{Derived} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Base}

\spanKeyword{proc} \spanIdentifier{consumeBaseValues}\spanPunctuation{(}\spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{RingBuffer}\spanPunctuation{\symbol{91}}\spanIdentifier{Base}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}

\spanKeyword{var} \spanIdentifier{derivedValues}\spanPunctuation{:} \spanIdentifier{RingBuffer}\spanPunctuation{\symbol{91}}\spanIdentifier{Derived}\spanPunctuation{\symbol{93}}

\spanIdentifier{consumeBaseValues}\spanPunctuation{(}\spanIdentifier{derivedValues}\spanPunctuation{)} \spanComment{\# Error, Base and Derived values may differ}
                                 \spanComment{\# in size}

\spanKeyword{proc} \spanIdentifier{consumeBasePointers}\spanPunctuation{(}\spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{RingBuffer}\spanPunctuation{\symbol{91}}\spanKeyword{ptr} \spanIdentifier{Base}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}

\spanKeyword{var} \spanIdentifier{derivedPointers}\spanPunctuation{:} \spanIdentifier{RingBuffer}\spanPunctuation{\symbol{91}}\spanKeyword{ptr} \spanIdentifier{Derived}\spanPunctuation{\symbol{93}}

\spanIdentifier{consumeBaseValues}\spanPunctuation{(}\spanIdentifier{derivedPointers}\spanPunctuation{)} \spanComment{\# This is legal}
\end{rstpre}
Please note that Nim will treat the user-defined pointer-like types as proper alternatives to the built-in pointer types. That is, types such as \texttt{seq\symbol{91}AnnotatedPtr\symbol{91}T\symbol{93}\symbol{93}} or \texttt{RingBuffer\symbol{91}AnnotatedPtr\symbol{91}T\symbol{93}\symbol{93}} will also be considered covariant and you can create new pointer-like types by instantiating other user-defined pointer-like types.

The contravariant parameters introduced with the \texttt{in} modifier are currently useful only when interfacing with imported types having such semantics.

\rsthA{Automatic dereferencing}\label{automatic-dereferencing}
Automatic dereferencing is performed for the first argument of a routine call. This feature has to be only enabled via \texttt{\symbol{123}.experimental: "implicitDeref".\symbol{125}}:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{experimental}\spanPunctuation{:} \spanStringLit{"implicitDeref"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{proc} \spanIdentifier{depth}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{NodeObj}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanOperator{...}

\spanKeyword{var}
  \spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{Node}
\spanIdentifier{new}\spanPunctuation{(}\spanIdentifier{n}\spanPunctuation{)}
\spanIdentifier{echo} \spanIdentifier{n}\spanOperator{.}\spanIdentifier{depth}
\spanComment{\# no need to write n\symbol{91}\symbol{93}.depth either}
\end{rstpre}
\rsthA{Code reordering}\label{code-reordering}
The code reordering feature can implicitly rearrange procedure, template, and macro definitions along with variable declarations and initializations at the top level scope so that, to a large extent, a programmer should not have to worry about ordering definitions correctly or be forced to use forward declarations to preface definitions inside a module.

Example:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{experimental}\spanPunctuation{:} \spanStringLit{"codeReordering"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{bar}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{bar}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}

\spanIdentifier{foo}\spanPunctuation{(}\spanDecNumber{10}\spanPunctuation{)}
\end{rstpre}
Variables can also be reordered as well. Variables that are \emph{initialized} (i.e. variables that have their declaration and assignment combined in a single statement) can have their entire initialization statement reordered. Be wary of what code is executed at the top level:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{experimental}\spanPunctuation{:} \spanStringLit{"codeReordering"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{proc} \spanIdentifier{a}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo}\spanPunctuation{(}\spanIdentifier{foo}\spanPunctuation{)}

\spanKeyword{var} \spanIdentifier{foo} \spanOperator{=} \spanDecNumber{5}

\spanIdentifier{a}\spanPunctuation{(}\spanPunctuation{)} \spanComment{\# outputs: "5"}
\end{rstpre}
It is important to note that reordering \emph{only} works for symbols at top level scope. Therefore, the following will \emph{fail to compile:}

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{experimental}\spanPunctuation{:} \spanStringLit{"codeReordering"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{proc} \spanIdentifier{a}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{b}\spanPunctuation{(}\spanPunctuation{)}
  \spanKeyword{proc} \spanIdentifier{b}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
    \spanIdentifier{echo}\spanPunctuation{(}\spanStringLit{"Hello!"}\spanPunctuation{)}

\spanIdentifier{a}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
\rsthA{Automatic self insertions}\label{automatic-self-insertions}
\textbf{Note}: The \texttt{.this} pragma is deprecated and should not be used anymore.

Starting with version 0.14 of the language, Nim supports \texttt{field} as a shortcut for \texttt{self.field} comparable to the this\label{this_1} keyword in Java or C++. This feature has to be explicitly enabled via a \texttt{\symbol{123}.this: self.\symbol{125}} statement pragma (instead of \texttt{self} any other identifier can be used too). This pragma is active for the rest of the module:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Parent} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{RootObj}
    \spanIdentifier{parentField}\spanPunctuation{:} \spanIdentifier{int}
  \spanIdentifier{Child} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Parent}
    \spanIdentifier{childField}\spanPunctuation{:} \spanIdentifier{int}

\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{this}\spanPunctuation{:} \spanIdentifier{self}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanIdentifier{sumFields}\spanPunctuation{(}\spanIdentifier{self}\spanPunctuation{:} \spanIdentifier{Child}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{parentField} \spanOperator{+} \spanIdentifier{childField}
  \spanComment{\# is rewritten to:}
  \spanComment{\# result = self.parentField + self.childField}
\end{rstpre}
In addition to fields, routine applications are also rewritten, but only if no other interpretation of the call is possible:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{test}\spanPunctuation{(}\spanIdentifier{self}\spanPunctuation{:} \spanIdentifier{Child}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo} \spanIdentifier{childField}\spanPunctuation{,} \spanStringLit{" "}\spanPunctuation{,} \spanIdentifier{sumFields}\spanPunctuation{(}\spanPunctuation{)}
  \spanComment{\# is rewritten to:}
  \spanIdentifier{echo} \spanIdentifier{self}\spanOperator{.}\spanIdentifier{childField}\spanPunctuation{,} \spanStringLit{" "}\spanPunctuation{,} \spanIdentifier{sumFields}\spanPunctuation{(}\spanIdentifier{self}\spanPunctuation{)}
  \spanComment{\# but NOT rewritten to:}
  \spanIdentifier{echo} \spanIdentifier{self}\spanPunctuation{,} \spanIdentifier{self}\spanOperator{.}\spanIdentifier{childField}\spanPunctuation{,} \spanStringLit{" "}\spanPunctuation{,} \spanIdentifier{sumFields}\spanPunctuation{(}\spanIdentifier{self}\spanPunctuation{)}
\end{rstpre}
\rsthA{Named argument overloading}\label{named-argument-overloading}
Routines with the same type signature can be called differently if a parameter has different names. This does not need an \texttt{experimental} switch, but is an unstable feature.

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"Using x: "}\spanPunctuation{,} \spanIdentifier{x}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"Using y: "}\spanPunctuation{,} \spanIdentifier{y}

\spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{x} \spanOperator{=} \spanDecNumber{2}\spanPunctuation{)}
\spanComment{\# Using x: 2}
\spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{y} \spanOperator{=} \spanDecNumber{2}\spanPunctuation{)}
\spanComment{\# Using y: 2}
\end{rstpre}
\rsthA{Do notation}\label{do-notation}
As a special more convenient notation, proc expressions involved in procedure calls can use the \texttt{do} keyword:

\begin{rstpre}
\spanIdentifier{sort}\spanPunctuation{(}\spanIdentifier{cities}\spanPunctuation{)} \spanKeyword{do} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,}\spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{->} \spanIdentifier{int}\spanPunctuation{:}
  \spanIdentifier{cmp}\spanPunctuation{(}\spanIdentifier{x}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{,} \spanIdentifier{y}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{)}

\spanComment{\# Less parenthesis using the method plus command syntax:}
\spanIdentifier{cities} \spanOperator{=} \spanIdentifier{cities}\spanOperator{.}\spanIdentifier{map} \spanKeyword{do} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:}\spanIdentifier{string}\spanPunctuation{)} \spanOperator{->} \spanIdentifier{string}\spanPunctuation{:}
  \spanStringLit{"City of "} \spanOperator{\&} \spanIdentifier{x}

\spanComment{\# In macros, the do notation is often used for quasi-quoting}
\spanIdentifier{macroResults}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{quote} \spanKeyword{do}\spanPunctuation{:}
  \spanKeyword{if} \spanKeyword{not} \spanPunctuation{\symbol{96}}\spanIdentifier{ex}\spanPunctuation{\symbol{96}}\spanPunctuation{:}
    \spanIdentifier{echo} \spanPunctuation{\symbol{96}}\spanIdentifier{info}\spanPunctuation{\symbol{96}}\spanPunctuation{,} \spanStringLit{": Check failed: "}\spanPunctuation{,} \spanPunctuation{\symbol{96}}\spanIdentifier{expString}\spanPunctuation{\symbol{96}}
\end{rstpre}
\texttt{do} is written after the parentheses enclosing the regular proc params. The proc expression represented by the do block is appended to them. In calls using the command syntax, the do block will bind to the immediately preceding expression, transforming it in a call.

\texttt{do} with parentheses is an anonymous \texttt{proc}; however a \texttt{do} without parentheses is just a block of code. The \texttt{do} notation can be used to pass multiple blocks to a macro:

\begin{rstpre}
\spanKeyword{macro} \spanIdentifier{performWithUndo}\spanPunctuation{(}\spanIdentifier{task}\spanPunctuation{,} \spanIdentifier{undo}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}

\spanIdentifier{performWithUndo} \spanKeyword{do}\spanPunctuation{:}
  \spanComment{\# multiple-line block of code}
  \spanComment{\# to perform the task}
\spanKeyword{do}\spanPunctuation{:}
  \spanComment{\# code to undo it}
\end{rstpre}
\rsthA{Special Operators}\label{special-operators}
\rsthB{dot operators}\label{special-operators-dot-operators}
\textbf{Note}: Dot operators are still experimental and so need to be enabled via \texttt{\symbol{123}.experimental: "dotOperators".\symbol{125}}.

Nim offers a special family of dot operators that can be used to intercept and rewrite proc call and field access attempts, referring to previously undeclared symbol names. They can be used to provide a fluent interface to objects lying outside the static confines of the type system such as values from dynamic scripting languages or dynamic file formats such as JSON or XML.

When Nim encounters an expression that cannot be resolved by the standard overload resolution rules, the current scope will be searched for a dot operator that can be matched against a re-written form of the expression, where the unknown field or proc name is passed to an \texttt{untyped} parameter:

\begin{rstpre}
\spanIdentifier{a}\spanOperator{.}\spanIdentifier{b} \spanComment{\# becomes \symbol{96}.\symbol{96}(a, b)}
\spanIdentifier{a}\spanOperator{.}\spanIdentifier{b}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{,} \spanIdentifier{d}\spanPunctuation{)} \spanComment{\# becomes \symbol{96}.\symbol{96}(a, b, c, d)}
\end{rstpre}
The matched dot operators can be symbols of any callable kind (procs, templates and macros), depending on the desired effect:

\begin{rstpre}
\spanKeyword{template} \spanPunctuation{\symbol{96}}\spanOperator{.}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{js}\spanPunctuation{:} \spanIdentifier{PJsonNode}\spanPunctuation{,} \spanIdentifier{field}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{JSON} \spanOperator{=} \spanIdentifier{js}\spanPunctuation{\symbol{91}}\spanIdentifier{astToStr}\spanPunctuation{(}\spanIdentifier{field}\spanPunctuation{)}\spanPunctuation{\symbol{93}}

\spanKeyword{var} \spanIdentifier{js} \spanOperator{=} \spanIdentifier{parseJson}\spanPunctuation{(}\spanStringLit{"\symbol{123} x: 1, y: 2\symbol{125}"}\spanPunctuation{)}
\spanIdentifier{echo} \spanIdentifier{js}\spanOperator{.}\spanIdentifier{x} \spanComment{\# outputs 1}
\spanIdentifier{echo} \spanIdentifier{js}\spanOperator{.}\spanIdentifier{y} \spanComment{\# outputs 2}
\end{rstpre}
The following dot operators are available:

\rsthB{operator \texttt{.}}\label{special-operators-operator-dot}
This operator will be matched against both field accesses and method calls.

\rsthB{operator \texttt{.()}}\label{special-operators-operator-dot}
This operator will be matched exclusively against method calls. It has higher precedence than the \texttt{.} operator and this allows one to handle expressions like \texttt{x.y} and \texttt{x.y()} differently if one is interfacing with a scripting language for example.

\rsthB{operator \texttt{.=}}\label{special-operators-operator-doteq}
This operator will be matched against assignments to missing fields.

\begin{rstpre}
\spanIdentifier{a}\spanOperator{.}\spanIdentifier{b} \spanOperator{=} \spanIdentifier{c} \spanComment{\# becomes \symbol{96}.=\symbol{96}(a, b, c)}
\end{rstpre}
\rsthA{Not nil annotation}\label{not-nil-annotation}
\textbf{Note:} This is an experimental feature. It can be enabled with \texttt{\symbol{123}.experimental: "notnil"\symbol{125}}.

All types for which \texttt{nil} is a valid value can be annotated with the \texttt{not nil} annotation to exclude \texttt{nil} as a valid value:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{experimental}\spanPunctuation{:} \spanStringLit{"notnil"}\spanPunctuation{\symbol{125}}

\spanKeyword{type}
  \spanIdentifier{PObject} \spanOperator{=} \spanKeyword{ref} \spanIdentifier{TObj} \spanKeyword{not} \spanKeyword{nil}
  \spanIdentifier{TProc} \spanOperator{=} \spanPunctuation{(}\spanKeyword{proc} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{)} \spanKeyword{not} \spanKeyword{nil}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{PObject}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"not nil"}

\spanComment{\# compiler catches this:}
\spanIdentifier{p}\spanPunctuation{(}\spanKeyword{nil}\spanPunctuation{)}

\spanComment{\# and also this:}
\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{PObject}
\spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}
\end{rstpre}
The compiler ensures that every code path initializes variables which contain non-nilable pointers. The details of this analysis are still to be specified here.

\rsthA{Concepts}\label{concepts}
Concepts, also known as "user-defined type classes", are used to specify an arbitrary set of requirements that the matched type must satisfy.

Concepts are written in the following form:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Comparable} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}
    \spanPunctuation{(}\spanIdentifier{x} \spanOperator{<} \spanIdentifier{y}\spanPunctuation{)} \spanKeyword{is} \spanIdentifier{bool}
  
  \spanIdentifier{Stack}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{s}\spanPunctuation{,} \spanKeyword{var} \spanIdentifier{v}
    \spanIdentifier{s}\spanOperator{.}\spanIdentifier{pop}\spanPunctuation{(}\spanPunctuation{)} \spanKeyword{is} \spanIdentifier{T}
    \spanIdentifier{v}\spanOperator{.}\spanIdentifier{push}\spanPunctuation{(}\spanIdentifier{T}\spanPunctuation{)}
    
    \spanIdentifier{s}\spanOperator{.}\spanIdentifier{len} \spanKeyword{is} \spanIdentifier{Ordinal}
    
    \spanKeyword{for} \spanIdentifier{value} \spanKeyword{in} \spanIdentifier{s}\spanPunctuation{:}
      \spanIdentifier{value} \spanKeyword{is} \spanIdentifier{T}
\end{rstpre}
The concept is a match if:

\begin{enumerate}\item all of the expressions within the body can be compiled for the tested type
\item all statically evaluable boolean expressions in the body must be true
\end{enumerate}
The identifiers following the \texttt{concept} keyword represent instances of the currently matched type. You can apply any of the standard type modifiers such as \texttt{var}, \texttt{ref}, \texttt{ptr} and \texttt{static} to denote a more specific type of instance. You can also apply the \texttt{type} modifier to create a named instance of the type itself:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{MyConcept} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{x}\spanPunctuation{,} \spanKeyword{var} \spanIdentifier{v}\spanPunctuation{,} \spanKeyword{ref} \spanIdentifier{r}\spanPunctuation{,} \spanKeyword{ptr} \spanIdentifier{p}\spanPunctuation{,} \spanKeyword{static} \spanIdentifier{s}\spanPunctuation{,} \spanKeyword{type} \spanIdentifier{T}
    \spanOperator{...}
\end{rstpre}
Within the concept body, types can appear in positions where ordinary values and parameters are expected. This provides a more convenient way to check for the presence of callable symbols with specific signatures:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{OutputStream} \spanOperator{=} \spanKeyword{concept} \spanKeyword{var} \spanIdentifier{s}
    \spanIdentifier{s}\spanOperator{.}\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{string}\spanPunctuation{)}
\end{rstpre}
In order to check for symbols accepting \texttt{type} params, you must prefix the type with the explicit \texttt{type} modifier. The named instance of the type, following the \texttt{concept} keyword is also considered to have the explicit modifier and will be matched only as a type.

\begin{rstpre}
\spanKeyword{type}
  \spanComment{\# Let's imagine a user-defined casting framework with operators}
  \spanComment{\# such as \symbol{96}val.to(string)\symbol{96} and \symbol{96}val.to(JSonValue)\symbol{96}. We can test}
  \spanComment{\# for these with the following concept:}
  \spanIdentifier{MyCastables} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{x}
    \spanIdentifier{x}\spanOperator{.}\spanIdentifier{to}\spanPunctuation{(}\spanKeyword{type} \spanIdentifier{string}\spanPunctuation{)}
    \spanIdentifier{x}\spanOperator{.}\spanIdentifier{to}\spanPunctuation{(}\spanKeyword{type} \spanIdentifier{JSonValue}\spanPunctuation{)}
  
  \spanComment{\# Let's define a couple of concepts, known from Algebra:}
  \spanIdentifier{AdditiveMonoid}\spanOperator{*} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanKeyword{type} \spanIdentifier{T}
    \spanIdentifier{x} \spanOperator{+} \spanIdentifier{y} \spanKeyword{is} \spanIdentifier{T}
    \spanIdentifier{T}\spanOperator{.}\spanIdentifier{zero} \spanKeyword{is} \spanIdentifier{T} \spanComment{\# require a proc such as \symbol{96}int.zero\symbol{96} or 'Position.zero'}
  
  \spanIdentifier{AdditiveGroup}\spanOperator{*} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanKeyword{type} \spanIdentifier{T}
    \spanIdentifier{x} \spanKeyword{is} \spanIdentifier{AdditiveMonoid}
    \spanOperator{-}\spanIdentifier{x} \spanKeyword{is} \spanIdentifier{T}
    \spanIdentifier{x} \spanOperator{-} \spanIdentifier{y} \spanKeyword{is} \spanIdentifier{T}
\end{rstpre}
Please note that the \texttt{is} operator allows one to easily verify the precise type signatures of the required operations, but since type inference and default parameters are still applied in the concept body, it's also possible to describe usage protocols that do not reveal implementation details.

Much like generics, concepts are instantiated exactly once for each tested type and any static code included within the body is executed only once.

\rsthB{Concept diagnostics}\label{concepts-concept-diagnostics}
By default, the compiler will report the matching errors in concepts only when no other overload can be selected and a normal compilation error is produced. When you need to understand why the compiler is not matching a particular concept and, as a result, a wrong overload is selected, you can apply the \texttt{explain} pragma to either the concept body or a particular call-site.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{MyConcept} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{explain}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{concept} \spanOperator{...}

\spanIdentifier{overloadedProc}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanIdentifier{z}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{explain}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
This will provide Hints in the compiler output either every time the concept is not matched or only on the particular call-site.

\rsthB{Generic concepts and type binding rules}\label{concepts-generic-concepts-and-type-binding-rules}
The concept types can be parametric just like the regular generic types:

\begin{rstpre}
\spanComment{\#\#\# matrixalgo.nim}

\spanKeyword{import} \spanIdentifier{typetraits}

\spanKeyword{type}
  \spanIdentifier{AnyMatrix}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{R}\spanPunctuation{,} \spanIdentifier{C}\spanPunctuation{:} \spanKeyword{static} \spanIdentifier{int}\spanPunctuation{;} \spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{m}\spanPunctuation{,} \spanKeyword{var} \spanIdentifier{mvar}\spanPunctuation{,} \spanKeyword{type} \spanIdentifier{M}
    \spanIdentifier{M}\spanOperator{.}\spanIdentifier{ValueType} \spanKeyword{is} \spanIdentifier{T}
    \spanIdentifier{M}\spanOperator{.}\spanIdentifier{Rows} \spanOperator{==} \spanIdentifier{R}
    \spanIdentifier{M}\spanOperator{.}\spanIdentifier{Cols} \spanOperator{==} \spanIdentifier{C}
    
    \spanIdentifier{m}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{\symbol{93}} \spanKeyword{is} \spanIdentifier{T}
    \spanIdentifier{mvar}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{T}
    
    \spanKeyword{type} \spanIdentifier{TransposedType} \spanOperator{=} \spanIdentifier{stripGenericParams}\spanPunctuation{(}\spanIdentifier{M}\spanPunctuation{)}\spanPunctuation{\symbol{91}}\spanIdentifier{C}\spanPunctuation{,} \spanIdentifier{R}\spanPunctuation{,} \spanIdentifier{T}\spanPunctuation{\symbol{93}}
  
  \spanIdentifier{AnySquareMatrix}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{N}\spanPunctuation{:} \spanKeyword{static} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{AnyMatrix}\spanPunctuation{\symbol{91}}\spanIdentifier{N}\spanPunctuation{,} \spanIdentifier{N}\spanPunctuation{,} \spanIdentifier{T}\spanPunctuation{\symbol{93}}
  
  \spanIdentifier{AnyTransform3D}\spanOperator{*} \spanOperator{=} \spanIdentifier{AnyMatrix}\spanPunctuation{\symbol{91}}\spanDecNumber{4}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{,} \spanIdentifier{float}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanIdentifier{transposed}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{m}\spanPunctuation{:} \spanIdentifier{AnyMatrix}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{m}\spanOperator{.}\spanIdentifier{TransposedType} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{r} \spanKeyword{in} \spanDecNumber{0} \spanOperator{..<} \spanIdentifier{m}\spanOperator{.}\spanIdentifier{R}\spanPunctuation{:}
    \spanKeyword{for} \spanIdentifier{c} \spanKeyword{in} \spanDecNumber{0} \spanOperator{..<} \spanIdentifier{m}\spanOperator{.}\spanIdentifier{C}\spanPunctuation{:}
      \spanIdentifier{result}\spanPunctuation{\symbol{91}}\spanIdentifier{r}\spanPunctuation{,} \spanIdentifier{c}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{m}\spanPunctuation{\symbol{91}}\spanIdentifier{c}\spanPunctuation{,} \spanIdentifier{r}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanIdentifier{determinant}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{m}\spanPunctuation{:} \spanIdentifier{AnySquareMatrix}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanOperator{...}

\spanKeyword{proc} \spanIdentifier{setPerspectiveProjection}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{m}\spanPunctuation{:} \spanIdentifier{AnyTransform3D}\spanPunctuation{)} \spanOperator{=}
  \spanOperator{...}

\spanOperator{--------------}
\spanComment{\#\#\# matrix.nim}

\spanKeyword{type}
  \spanIdentifier{Matrix}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{M}\spanPunctuation{,} \spanIdentifier{N}\spanPunctuation{:} \spanKeyword{static} \spanIdentifier{int}\spanPunctuation{;} \spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanIdentifier{M}\spanOperator{*}\spanIdentifier{N}\spanPunctuation{,} \spanIdentifier{T}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{M}\spanPunctuation{:} \spanIdentifier{Matrix}\spanPunctuation{;} \spanIdentifier{m}\spanPunctuation{,} \spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{M}\spanOperator{.}\spanIdentifier{T} \spanOperator{=}
  \spanIdentifier{M}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{\symbol{91}}\spanIdentifier{m} \spanOperator{*} \spanIdentifier{M}\spanOperator{.}\spanIdentifier{N} \spanOperator{+} \spanIdentifier{n}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanOperator{=}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{M}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{Matrix}\spanPunctuation{;} \spanIdentifier{m}\spanPunctuation{,} \spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{;} \spanIdentifier{v}\spanPunctuation{:} \spanIdentifier{M}\spanOperator{.}\spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{M}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{\symbol{91}}\spanIdentifier{m} \spanOperator{*} \spanIdentifier{M}\spanOperator{.}\spanIdentifier{N} \spanOperator{+} \spanIdentifier{n}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{v}

\spanComment{\# Adapt the Matrix type to the concept's requirements}
\spanKeyword{template} \spanIdentifier{Rows}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{M}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanIdentifier{Matrix}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanIdentifier{M}\spanOperator{.}\spanIdentifier{M}
\spanKeyword{template} \spanIdentifier{Cols}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{M}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanIdentifier{Matrix}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanIdentifier{M}\spanOperator{.}\spanIdentifier{N}
\spanKeyword{template} \spanIdentifier{ValueType}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{M}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanIdentifier{Matrix}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{typedesc} \spanOperator{=} \spanIdentifier{M}\spanOperator{.}\spanIdentifier{T}

\spanOperator{-------------}
\spanComment{\#\#\# usage.nim}

\spanKeyword{import} \spanIdentifier{matrix}\spanPunctuation{,} \spanIdentifier{matrixalgo}

\spanKeyword{var}
  \spanIdentifier{m}\spanPunctuation{:} \spanIdentifier{Matrix}\spanPunctuation{\symbol{91}}\spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{\symbol{93}}
  \spanIdentifier{projectionMatrix}\spanPunctuation{:} \spanIdentifier{Matrix}\spanPunctuation{\symbol{91}}\spanDecNumber{4}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{,} \spanIdentifier{float}\spanPunctuation{\symbol{93}}

\spanIdentifier{echo} \spanIdentifier{m}\spanOperator{.}\spanIdentifier{transposed}\spanOperator{.}\spanIdentifier{determinant}
\spanIdentifier{setPerspectiveProjection} \spanIdentifier{projectionMatrix}
\end{rstpre}
When the concept type is matched against a concrete type, the unbound type parameters are inferred from the body of the concept in a way that closely resembles the way generic parameters of callable symbols are inferred on call sites.

Unbound types can appear both as params to calls such as \texttt{s.push(T)} and on the right-hand side of the \texttt{is} operator in cases such as \texttt{x.pop is T} and \texttt{x.data is seq\symbol{91}T\symbol{93}}.

Unbound static params will be inferred from expressions involving the \texttt{==} operator and also when types dependent on them are being matched:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{MatrixReducer}\spanPunctuation{\symbol{91}}\spanIdentifier{M}\spanPunctuation{,} \spanIdentifier{N}\spanPunctuation{:} \spanKeyword{static} \spanIdentifier{int}\spanPunctuation{;} \spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{x}
    \spanIdentifier{x}\spanOperator{.}\spanIdentifier{reduce}\spanPunctuation{(}\spanIdentifier{SquareMatrix}\spanPunctuation{\symbol{91}}\spanIdentifier{N}\spanPunctuation{,} \spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanKeyword{is} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanIdentifier{M}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{\symbol{93}}
\end{rstpre}
The Nim compiler includes a simple linear equation solver, allowing it to infer static params in some situations where integer arithmetic is involved.

Just like in regular type classes, Nim discriminates between \texttt{bind once} and \texttt{bind many} types when matching the concept. You can add the \texttt{distinct} modifier to any of the otherwise inferable types to get a type that will be matched without permanently inferring it. This may be useful when you need to match several procs accepting the same wide class of types:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Enumerable}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{e}
    \spanKeyword{for} \spanIdentifier{v} \spanKeyword{in} \spanIdentifier{e}\spanPunctuation{:}
      \spanIdentifier{v} \spanKeyword{is} \spanIdentifier{T}

\spanKeyword{type}
  \spanIdentifier{MyConcept} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{o}
    \spanComment{\# this could be inferred to a type such as Enumerable\symbol{91}int\symbol{93}}
    \spanIdentifier{o}\spanOperator{.}\spanIdentifier{foo} \spanKeyword{is} \spanKeyword{distinct} \spanIdentifier{Enumerable}
    
    \spanComment{\# this could be inferred to a different type such as Enumerable\symbol{91}float\symbol{93}}
    \spanIdentifier{o}\spanOperator{.}\spanIdentifier{bar} \spanKeyword{is} \spanKeyword{distinct} \spanIdentifier{Enumerable}
    
    \spanComment{\# it's also possible to give an alias name to a \symbol{96}bind many\symbol{96} type class}
    \spanKeyword{type} \spanKeyword{Enum} \spanOperator{=} \spanKeyword{distinct} \spanIdentifier{Enumerable}
    \spanIdentifier{o}\spanOperator{.}\spanIdentifier{baz} \spanKeyword{is} \spanKeyword{Enum}
\end{rstpre}
On the other hand, using \texttt{bind once} types allows you to test for equivalent types used in multiple signatures, without actually requiring any concrete types, thus allowing you to encode implementation-defined types:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{MyConcept} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{x}
    \spanKeyword{type} \spanIdentifier{T1} \spanOperator{=} \spanIdentifier{auto}
    \spanIdentifier{x}\spanOperator{.}\spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{T1}\spanPunctuation{)}
    \spanIdentifier{x}\spanOperator{.}\spanIdentifier{bar}\spanPunctuation{(}\spanIdentifier{T1}\spanPunctuation{)} \spanComment{\# both procs must accept the same type}
    
    \spanKeyword{type} \spanIdentifier{T2} \spanOperator{=} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{SomeNumber}\spanPunctuation{\symbol{93}}
    \spanIdentifier{x}\spanOperator{.}\spanIdentifier{alpha}\spanPunctuation{(}\spanIdentifier{T2}\spanPunctuation{)}
    \spanIdentifier{x}\spanOperator{.}\spanIdentifier{omega}\spanPunctuation{(}\spanIdentifier{T2}\spanPunctuation{)} \spanComment{\# both procs must accept the same type}
                \spanComment{\# and it must be a numeric sequence}
\end{rstpre}
As seen in the previous examples, you can refer to generic concepts such as \texttt{Enumerable\symbol{91}T\symbol{93}} just by their short name. Much like the regular generic types, the concept will be automatically instantiated with the bind once auto type in the place of each missing generic param.

Please note that generic concepts such as \texttt{Enumerable\symbol{91}T\symbol{93}} can be matched against concrete types such as \texttt{string}. Nim doesn't require the concept type to have the same number of parameters as the type being matched. If you wish to express a requirement towards the generic parameters of the matched type, you can use a type mapping operator such as \texttt{genericHead} or \texttt{stripGenericParams} within the body of the concept to obtain the uninstantiated version of the type, which you can then try to instantiate in any required way. For example, here is how one might define the classic \texttt{Functor} concept from Haskell and then demonstrate that Nim's \texttt{Option\symbol{91}T\symbol{93}} type is an instance of it:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{sugar}\spanPunctuation{,} \spanIdentifier{typetraits}

\spanKeyword{type}
  \spanIdentifier{Functor}\spanPunctuation{\symbol{91}}\spanIdentifier{A}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{f}
    \spanKeyword{type} \spanIdentifier{MatchedGenericType} \spanOperator{=} \spanIdentifier{genericHead}\spanPunctuation{(}\spanIdentifier{typeof}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{)}\spanPunctuation{)}
      \spanComment{\# \symbol{96}f\symbol{96} will be a value of a type such as \symbol{96}Option\symbol{91}T\symbol{93}\symbol{96}}
      \spanComment{\# \symbol{96}MatchedGenericType\symbol{96} will become the \symbol{96}Option\symbol{96} type}
    
    \spanIdentifier{f}\spanOperator{.}\spanIdentifier{val} \spanKeyword{is} \spanIdentifier{A}
      \spanComment{\# The Functor should provide a way to obtain}
      \spanComment{\# a value stored inside it}
    
    \spanKeyword{type} \spanIdentifier{T} \spanOperator{=} \spanIdentifier{auto}
    \spanIdentifier{map}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanIdentifier{A} \spanOperator{->} \spanIdentifier{T}\spanPunctuation{)} \spanKeyword{is} \spanIdentifier{MatchedGenericType}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}
      \spanComment{\# And it should provide a way to map one instance of}
      \spanComment{\# the Functor to a instance of a different type, given}
      \spanComment{\# a suitable \symbol{96}map\symbol{96} operation for the enclosed values}

\spanKeyword{import} \spanIdentifier{options}
\spanIdentifier{echo} \spanIdentifier{Option}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}} \spanKeyword{is} \spanIdentifier{Functor} \spanComment{\# prints true}
\end{rstpre}
\rsthB{Concept derived values}\label{concepts-concept-derived-values}
All top level constants or types appearing within the concept body are accessible through the dot operator in procs where the concept was successfully matched to a concrete type:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{DateTime} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{t1}\spanPunctuation{,} \spanIdentifier{t2}\spanPunctuation{,} \spanKeyword{type} \spanIdentifier{T}
    \spanKeyword{const} \spanIdentifier{Min} \spanOperator{=} \spanIdentifier{T}\spanOperator{.}\spanIdentifier{MinDate}
    \spanIdentifier{T}\spanOperator{.}\spanIdentifier{Now} \spanKeyword{is} \spanIdentifier{T}
    
    \spanIdentifier{t1} \spanOperator{<} \spanIdentifier{t2} \spanKeyword{is} \spanIdentifier{bool}
    
    \spanKeyword{type} \spanIdentifier{TimeSpan} \spanOperator{=} \spanIdentifier{typeof}\spanPunctuation{(}\spanIdentifier{t1} \spanOperator{-} \spanIdentifier{t2}\spanPunctuation{)}
    \spanIdentifier{TimeSpan} \spanOperator{*} \spanIdentifier{int} \spanKeyword{is} \spanIdentifier{TimeSpan}
    \spanIdentifier{TimeSpan} \spanOperator{+} \spanIdentifier{TimeSpan} \spanKeyword{is} \spanIdentifier{TimeSpan}
    
    \spanIdentifier{t1} \spanOperator{+} \spanIdentifier{TimeSpan} \spanKeyword{is} \spanIdentifier{T}

\spanKeyword{proc} \spanIdentifier{eventsJitter}\spanPunctuation{(}\spanIdentifier{events}\spanPunctuation{:} \spanIdentifier{Enumerable}\spanPunctuation{\symbol{91}}\spanIdentifier{DateTime}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{float} \spanOperator{=}
  \spanKeyword{var}
    \spanComment{\# this variable will have the inferred TimeSpan type for}
    \spanComment{\# the concrete Date-like value the proc was called with:}
    \spanIdentifier{averageInterval}\spanPunctuation{:} \spanIdentifier{DateTime}\spanOperator{.}\spanIdentifier{TimeSpan}
    
    \spanIdentifier{deviation}\spanPunctuation{:} \spanIdentifier{float}
  \spanOperator{...}
\end{rstpre}
\rsthB{Concept refinement}\label{concepts-concept-refinement}
When the matched type within a concept is directly tested against a different concept, we say that the outer concept is a refinement of the inner concept and thus it is more-specific. When both concepts are matched in a call during overload resolution, Nim will assign a higher precedence to the most specific one. As an alternative way of defining concept refinements, you can use the object inheritance syntax involving the \texttt{of} keyword:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Graph} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{g}\spanPunctuation{,} \spanKeyword{type} \spanIdentifier{G} \spanKeyword{of} \spanIdentifier{EquallyComparable}\spanPunctuation{,} \spanIdentifier{Copyable}
    \spanKeyword{type}
      \spanIdentifier{VertexType} \spanOperator{=} \spanIdentifier{G}\spanOperator{.}\spanIdentifier{VertexType}
      \spanIdentifier{EdgeType} \spanOperator{=} \spanIdentifier{G}\spanOperator{.}\spanIdentifier{EdgeType}
    
    \spanIdentifier{VertexType} \spanKeyword{is} \spanIdentifier{Copyable}
    \spanIdentifier{EdgeType} \spanKeyword{is} \spanIdentifier{Copyable}
    
    \spanKeyword{var}
      \spanIdentifier{v}\spanPunctuation{:} \spanIdentifier{VertexType}
      \spanIdentifier{e}\spanPunctuation{:} \spanIdentifier{EdgeType}
  
  \spanIdentifier{IncidendeGraph} \spanOperator{=} \spanKeyword{concept} \spanKeyword{of} \spanIdentifier{Graph}
    \spanComment{\# symbols such as variables and types from the refined}
    \spanComment{\# concept are automatically in scope:}
    
    \spanIdentifier{g}\spanOperator{.}\spanIdentifier{source}\spanPunctuation{(}\spanIdentifier{e}\spanPunctuation{)} \spanKeyword{is} \spanIdentifier{VertexType}
    \spanIdentifier{g}\spanOperator{.}\spanIdentifier{target}\spanPunctuation{(}\spanIdentifier{e}\spanPunctuation{)} \spanKeyword{is} \spanIdentifier{VertexType}
    
    \spanIdentifier{g}\spanOperator{.}\spanIdentifier{outgoingEdges}\spanPunctuation{(}\spanIdentifier{v}\spanPunctuation{)} \spanKeyword{is} \spanIdentifier{Enumerable}\spanPunctuation{\symbol{91}}\spanIdentifier{EdgeType}\spanPunctuation{\symbol{93}}
  
  \spanIdentifier{BidirectionalGraph} \spanOperator{=} \spanKeyword{concept} \spanIdentifier{g}\spanPunctuation{,} \spanKeyword{type} \spanIdentifier{G}
    \spanComment{\# The following will also turn the concept into a refinement when it}
    \spanComment{\# comes to overload resolution, but it doesn't provide the convenient}
    \spanComment{\# symbol inheritance}
    \spanIdentifier{g} \spanKeyword{is} \spanIdentifier{IncidendeGraph}
    
    \spanIdentifier{g}\spanOperator{.}\spanIdentifier{incomingEdges}\spanPunctuation{(}\spanIdentifier{G}\spanOperator{.}\spanIdentifier{VertexType}\spanPunctuation{)} \spanKeyword{is} \spanIdentifier{Enumerable}\spanPunctuation{\symbol{91}}\spanIdentifier{G}\spanOperator{.}\spanIdentifier{EdgeType}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanIdentifier{f}\spanPunctuation{(}\spanIdentifier{g}\spanPunctuation{:} \spanIdentifier{IncidendeGraph}\spanPunctuation{)}
\spanKeyword{proc} \spanIdentifier{f}\spanPunctuation{(}\spanIdentifier{g}\spanPunctuation{:} \spanIdentifier{BidirectionalGraph}\spanPunctuation{)} \spanComment{\# this one will be preferred if we pass a type}
                              \spanComment{\# matching the BidirectionalGraph concept}
\end{rstpre}
\rsthA{Type bound operations}\label{type-bound-operations}
There are 4 operations that are bound to a type:

\begin{enumerate}\item Assignment
\item Moves
\item Destruction
\item Deep copying for communication between threads
\end{enumerate}
These operations can be \emph{overridden} instead of \emph{overloaded}. This means the implementation is automatically lifted to structured types. For instance if type \texttt{T} has an overridden assignment operator \texttt{=} this operator is also used for assignments of the type \texttt{seq\symbol{91}T\symbol{93}}. Since these operations are bound to a type they have to be bound to a nominal type for reasons of simplicity of implementation: This means an overridden \texttt{deepCopy} for \texttt{ref T} is really bound to \texttt{T} and not to \texttt{ref T}. This also means that one cannot override \texttt{deepCopy} for both \texttt{ptr T} and \texttt{ref T} at the same time; instead a helper distinct or object type has to be used for one pointer type.

Assignments, moves and destruction are specified in the \href{destructors.html}{destructors} document.

\rsthB{deepCopy}\label{type-bound-operations-deepcopy}
\texttt{=deepCopy} is a builtin that is invoked whenever data is passed to a \texttt{spawn}'ed proc to ensure memory safety. The programmer can override its behaviour for a specific \texttt{ref} or \texttt{ptr} type \texttt{T}. (Later versions of the language may weaken this restriction.)

The signature has to be:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{deepCopy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{T}
\end{rstpre}
This mechanism will be used by most data structures that support shared memory like channels to implement thread safe automatic memory management.

The builtin \texttt{deepCopy} can even clone closures and their environments. See the documentation of \href{\#parallel-amp-spawn-spawn-statement}{spawn} for details.

\rsthA{Case statement macros}\label{case-statement-macros}
A macro that needs to be called match\label{match_1} can be used to rewrite \texttt{case} statements in order to implement pattern matching\label{pattern-matching_1} for certain types. The following example implements a simplistic form of pattern matching for tuples, leveraging the existing equality operator for tuples (as provided in \texttt{system.==}):

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{experimental}\spanPunctuation{:} \spanStringLit{"caseStmtMacros"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{import} \spanIdentifier{macros}

\spanKeyword{macro} \spanIdentifier{match}\spanPunctuation{(}\spanIdentifier{n}\spanPunctuation{:} \spanKeyword{tuple}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{newTree}\spanPunctuation{(}\spanIdentifier{nnkIfStmt}\spanPunctuation{)}
  \spanKeyword{let} \spanIdentifier{selector} \spanOperator{=} \spanIdentifier{n}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanDecNumber{1} \spanOperator{..<} \spanIdentifier{n}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{:}
    \spanKeyword{let} \spanIdentifier{it} \spanOperator{=} \spanIdentifier{n}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}
    \spanKeyword{case} \spanIdentifier{it}\spanOperator{.}\spanIdentifier{kind}
    \spanKeyword{of} \spanIdentifier{nnkElse}\spanPunctuation{,} \spanIdentifier{nnkElifBranch}\spanPunctuation{,} \spanIdentifier{nnkElifExpr}\spanPunctuation{,} \spanIdentifier{nnkElseExpr}\spanPunctuation{:}
      \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{it}
    \spanKeyword{of} \spanIdentifier{nnkOfBranch}\spanPunctuation{:}
      \spanKeyword{for} \spanIdentifier{j} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanIdentifier{it}\spanOperator{.}\spanIdentifier{len}\spanOperator{-}\spanDecNumber{2}\spanPunctuation{:}
        \spanKeyword{let} \spanIdentifier{cond} \spanOperator{=} \spanIdentifier{newCall}\spanPunctuation{(}\spanStringLit{"=="}\spanPunctuation{,} \spanIdentifier{selector}\spanPunctuation{,} \spanIdentifier{it}\spanPunctuation{\symbol{91}}\spanIdentifier{j}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
        \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{newTree}\spanPunctuation{(}\spanIdentifier{nnkElifBranch}\spanPunctuation{,} \spanIdentifier{cond}\spanPunctuation{,} \spanIdentifier{it}\spanPunctuation{\symbol{91}}\spanOperator{\symbol{94}}\spanDecNumber{1}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
    \spanKeyword{else}\spanPunctuation{:}
      \spanIdentifier{error} \spanStringLit{"'match' cannot handle this node"}\spanPunctuation{,} \spanIdentifier{it}
  \spanIdentifier{echo} \spanIdentifier{repr} \spanIdentifier{result}

\spanKeyword{case} \spanPunctuation{(}\spanStringLit{"foo"}\spanPunctuation{,} \spanDecNumber{78}\spanPunctuation{)}
\spanKeyword{of} \spanPunctuation{(}\spanStringLit{"foo"}\spanPunctuation{,} \spanDecNumber{78}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"yes"}
\spanKeyword{of} \spanPunctuation{(}\spanStringLit{"bar"}\spanPunctuation{,} \spanDecNumber{88}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"no"}
\spanKeyword{else}\spanPunctuation{:} \spanKeyword{discard}
\end{rstpre}
Currently case statement macros must be enabled explicitly via \texttt{\symbol{123}.experimental: "caseStmtMacros".\symbol{125}}.

\texttt{match} macros are subject to overload resolution. First the \texttt{case}'s selector expression is used to determine which \texttt{match} macro to call. To this macro is then passed the complete \texttt{case} statement body and the macro is evaluated.

In other words, the macro needs to transform the full \texttt{case} statement but only the statement's selector expression is used to determine which macro to call.

\rsthB{For loop macros}\label{case-statement-macros-for-loop-macros}
A macro that takes as its only input parameter an expression of the special type \texttt{system.ForLoopStmt} can rewrite the entirety of a \texttt{for} loop:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{macros}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{experimental}\spanPunctuation{:} \spanStringLit{"forLoopMacros"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{macro} \spanIdentifier{enumerate}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{ForLoopStmt}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanIdentifier{expectKind} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{nnkForStmt}
  \spanComment{\# we strip off the first for loop variable and use}
  \spanComment{\# it as an integer counter:}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{newStmtList}\spanPunctuation{(}\spanPunctuation{)}
  \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{newVarStmt}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{newLit}\spanPunctuation{(}\spanDecNumber{0}\spanPunctuation{)}\spanPunctuation{)}
  \spanKeyword{var} \spanIdentifier{body} \spanOperator{=} \spanIdentifier{x}\spanPunctuation{\symbol{91}}\spanOperator{\symbol{94}}\spanDecNumber{1}\spanPunctuation{\symbol{93}}
  \spanKeyword{if} \spanIdentifier{body}\spanOperator{.}\spanIdentifier{kind} \spanOperator{!=} \spanIdentifier{nnkStmtList}\spanPunctuation{:}
    \spanIdentifier{body} \spanOperator{=} \spanIdentifier{newTree}\spanPunctuation{(}\spanIdentifier{nnkStmtList}\spanPunctuation{,} \spanIdentifier{body}\spanPunctuation{)}
  \spanIdentifier{body}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{newCall}\spanPunctuation{(}\spanRawData{bindSym"inc"}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
  \spanKeyword{var} \spanIdentifier{newFor} \spanOperator{=} \spanIdentifier{newTree}\spanPunctuation{(}\spanIdentifier{nnkForStmt}\spanPunctuation{)}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{1.}\spanOperator{.}\spanIdentifier{x}\spanOperator{.}\spanIdentifier{len}\spanOperator{-}\spanDecNumber{3}\spanPunctuation{:}
    \spanIdentifier{newFor}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{x}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}
  \spanComment{\# transform enumerate(X) to 'X'}
  \spanIdentifier{newFor}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{x}\spanPunctuation{\symbol{91}}\spanOperator{\symbol{94}}\spanDecNumber{2}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}}
  \spanIdentifier{newFor}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{body}
  \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{newFor}
  \spanComment{\# now wrap the whole macro in a block to create a new scope}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{quote} \spanKeyword{do}\spanPunctuation{:}
    \spanKeyword{block}\spanPunctuation{:} \spanPunctuation{\symbol{96}}\spanIdentifier{result}\spanPunctuation{\symbol{96}}

\spanKeyword{for} \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b} \spanKeyword{in} \spanIdentifier{enumerate}\spanPunctuation{(}\spanIdentifier{items}\spanPunctuation{(}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{a}\spanPunctuation{,} \spanStringLit{" "}\spanPunctuation{,} \spanIdentifier{b}

\spanComment{\# without wrapping the macro in a block, we'd need to choose different}
\spanComment{\# names for \symbol{96}a\symbol{96} and \symbol{96}b\symbol{96} here to avoid redefinition errors}
\spanKeyword{for} \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b} \spanKeyword{in} \spanIdentifier{enumerate}\spanPunctuation{(}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{5}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{a}\spanPunctuation{,} \spanStringLit{" "}\spanPunctuation{,} \spanIdentifier{b}
\end{rstpre}
Currently for loop macros must be enabled explicitly via \texttt{\symbol{123}.experimental: "forLoopMacros".\symbol{125}}.

\rsthA{Term rewriting macros}\label{term-rewriting-macros}
Term rewriting macros are macros or templates that have not only a \emph{name} but also a \emph{pattern} that is searched for after the semantic checking phase of the compiler: This means they provide an easy way to enhance the compilation pipeline with user defined optimizations:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{optMul}\spanPunctuation{\symbol{123}}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{)}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanIdentifier{a}\spanOperator{+}\spanIdentifier{a}

\spanKeyword{let} \spanIdentifier{x} \spanOperator{=} \spanDecNumber{3}
\spanIdentifier{echo} \spanIdentifier{x} \spanOperator{*} \spanDecNumber{2}
\end{rstpre}
The compiler now rewrites \texttt{x * 2} as \texttt{x + x}. The code inside the curlies is the pattern to match against. The operators \texttt{*},  \texttt{**}, \texttt{|}, \texttt{\symbol{126}} have a special meaning in patterns if they are written in infix notation, so to match verbatim against \texttt{*} the ordinary function call syntax needs to be used.

Term rewriting macro are applied recursively, up to a limit. This means that if the result of a term rewriting macro is eligible for another rewriting, the compiler will try to perform it, and so on, until no more optimizations are applicable. To avoid putting the compiler into an infinite loop, there is a hard limit on how many times a single term rewriting macro can be applied. Once this limit has been passed, the term rewriting macro will be ignored.

Unfortunately optimizations are hard to get right and even the tiny example is \textbf{wrong}:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{optMul}\spanPunctuation{\symbol{123}}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{)}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanIdentifier{a}\spanOperator{+}\spanIdentifier{a}

\spanKeyword{proc} \spanIdentifier{f}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"side effect!"}
  \spanIdentifier{result} \spanOperator{=} \spanDecNumber{55}

\spanIdentifier{echo} \spanIdentifier{f}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{*} \spanDecNumber{2}
\end{rstpre}
We cannot duplicate 'a' if it denotes an expression that has a side effect! Fortunately Nim supports side effect analysis:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{optMul}\spanPunctuation{\symbol{123}}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{)}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{\symbol{123}}\spanIdentifier{noSideEffect}\spanPunctuation{\symbol{125}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanIdentifier{a}\spanOperator{+}\spanIdentifier{a}

\spanKeyword{proc} \spanIdentifier{f}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"side effect!"}
  \spanIdentifier{result} \spanOperator{=} \spanDecNumber{55}

\spanIdentifier{echo} \spanIdentifier{f}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{*} \spanDecNumber{2} \spanComment{\# not optimized ;-)}
\end{rstpre}
You can make one overload matching with a constraint and one without, and the one with a constraint will have precedence, and so you can handle both cases differently.

So what about \texttt{2 * a}? We should tell the compiler \texttt{*} is commutative. We cannot really do that however as the following code only swaps arguments blindly:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{mulIsCommutative}\spanPunctuation{\symbol{123}}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanIdentifier{b}\spanOperator{*}\spanIdentifier{a}
\end{rstpre}
What optimizers really need to do is a \emph{canonicalization}:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{canonMul}\spanPunctuation{\symbol{123}}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{\symbol{123}}\spanIdentifier{lit}\spanPunctuation{\symbol{125}}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanIdentifier{b}\spanOperator{*}\spanIdentifier{a}
\end{rstpre}
The \texttt{int\symbol{123}lit\symbol{125}} parameter pattern matches against an expression of type \texttt{int}, but only if it's a literal.

\rsthB{Parameter constraints}\label{term-rewriting-macros-parameter-constraints}
The parameter constraint\label{parameter-constraint_1} expression can use the operators \texttt{|} (or), \texttt{\&} (and) and \texttt{\symbol{126}} (not) and the following predicates:

\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|}
\hline
\textbf{Predicate} & \textbf{Meaning}\\
\hline
\texttt{atom} & The matching node has no children.\\
\hline
\texttt{lit} & The matching node is a literal like "abc", 12.\\
\hline
\texttt{sym} & The matching node must be a symbol (a bound identifier).\\
\hline
\texttt{ident} & The matching node must be an identifier (an unbound identifier).\\
\hline
\texttt{call} & The matching AST must be a call/apply expression.\\
\hline
\texttt{lvalue} & The matching AST must be an lvalue.\\
\hline
\texttt{sideeffect} & The matching AST must have a side effect.\\
\hline
\texttt{nosideeffect} & The matching AST must have no side effect.\\
\hline
\texttt{param} & A symbol which is a parameter.\\
\hline
\texttt{genericparam} & A symbol which is a generic parameter.\\
\hline
\texttt{module} & A symbol which is a module.\\
\hline
\texttt{type} & A symbol which is a type.\\
\hline
\texttt{var} & A symbol which is a variable.\\
\hline
\texttt{let} & A symbol which is a \texttt{let} variable.\\
\hline
\texttt{const} & A symbol which is a constant.\\
\hline
\texttt{result} & The special \texttt{result} variable.\\
\hline
\texttt{proc} & A symbol which is a proc.\\
\hline
\texttt{method} & A symbol which is a method.\\
\hline
\texttt{iterator} & A symbol which is an iterator.\\
\hline
\texttt{converter} & A symbol which is a converter.\\
\hline
\texttt{macro} & A symbol which is a macro.\\
\hline
\texttt{template} & A symbol which is a template.\\
\hline
\texttt{field} & A symbol which is a field in a tuple or an object.\\
\hline
\texttt{enumfield} & A symbol which is a field in an enumeration.\\
\hline
\texttt{forvar} & A for loop variable.\\
\hline
\texttt{label} & A label (used in \texttt{block} statements).\\
\hline
\texttt{nk*} & The matching AST must have the specified kind. (Example: \texttt{nkIfStmt} denotes an \texttt{if} statement.)\\
\hline
\texttt{alias} & States that the marked parameter needs to alias with \emph{some} other parameter.\\
\hline
\texttt{noalias} & States that \emph{every} other parameter must not alias with the marked parameter.\\
\hline
\end{rsttab}\end{table}Predicates that share their name with a keyword have to be escaped with backticks. The \texttt{alias} and \texttt{noalias} predicates refer not only to the matching AST, but also to every other bound parameter; syntactically they need to occur after the ordinary AST predicates:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{ex}\spanPunctuation{\symbol{123}}\spanIdentifier{a} \spanOperator{=} \spanIdentifier{b} \spanOperator{+} \spanIdentifier{c}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{\symbol{123}}\spanIdentifier{noalias}\spanPunctuation{\symbol{125}}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{,} \spanIdentifier{c}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# this transformation is only valid if 'b' and 'c' do not alias 'a':}
  \spanIdentifier{a} \spanOperator{=} \spanIdentifier{b}
  \spanIdentifier{inc} \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{c}
\end{rstpre}
\rsthB{Pattern operators}\label{term-rewriting-macros-pattern-operators}
The operators \texttt{*},  \texttt{**}, \texttt{|}, \texttt{\symbol{126}} have a special meaning in patterns if they are written in infix notation.

\rsthC{The \texttt{|} operator}\label{pattern-operators-the-bar-operator}
The \texttt{|} operator if used as infix operator creates an ordered choice:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{t}\spanPunctuation{\symbol{123}}\spanDecNumber{0}\spanOperator{|}\spanDecNumber{1}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=} \spanDecNumber{3}
\spanKeyword{let} \spanIdentifier{a} \spanOperator{=} \spanDecNumber{1}
\spanComment{\# outputs 3:}
\spanIdentifier{echo} \spanIdentifier{a}
\end{rstpre}
The matching is performed after the compiler performed some optimizations like constant folding, so the following does not work:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{t}\spanPunctuation{\symbol{123}}\spanDecNumber{0}\spanOperator{|}\spanDecNumber{1}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=} \spanDecNumber{3}
\spanComment{\# outputs 1:}
\spanIdentifier{echo} \spanDecNumber{1}
\end{rstpre}
The reason is that the compiler already transformed the 1 into "1" for the \texttt{echo} statement. However, a term rewriting macro should not change the semantics anyway. In fact they can be deactivated with the \texttt{--patterns:off} command line option or temporarily with the \texttt{patterns} pragma.

\rsthC{The \texttt{\symbol{123}\symbol{125}} operator}\label{pattern-operators-the-operator}
A pattern expression can be bound to a pattern parameter via the \texttt{expr\symbol{123}param\symbol{125}} notation:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{t}\spanPunctuation{\symbol{123}}\spanPunctuation{(}\spanDecNumber{0}\spanOperator{|}\spanDecNumber{1}\spanOperator{|}\spanDecNumber{2}\spanPunctuation{)}\spanPunctuation{\symbol{123}}\spanIdentifier{x}\spanPunctuation{\symbol{125}}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=} \spanIdentifier{x}\spanOperator{+}\spanDecNumber{1}
\spanKeyword{let} \spanIdentifier{a} \spanOperator{=} \spanDecNumber{1}
\spanComment{\# outputs 2:}
\spanIdentifier{echo} \spanIdentifier{a}
\end{rstpre}
\rsthC{The \texttt{\symbol{126}} operator}\label{pattern-operators-the-tilde-operator}
The \texttt{\symbol{126}} operator is the \textbf{not} operator in patterns:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{t}\spanPunctuation{\symbol{123}}\spanIdentifier{x} \spanOperator{=} \spanPunctuation{(}\spanOperator{\symbol{126}}\spanIdentifier{x}\spanPunctuation{)}\spanPunctuation{\symbol{123}}\spanIdentifier{y}\spanPunctuation{\symbol{125}} \spanKeyword{and} \spanPunctuation{(}\spanOperator{\symbol{126}}\spanIdentifier{x}\spanPunctuation{)}\spanPunctuation{\symbol{123}}\spanIdentifier{z}\spanPunctuation{\symbol{125}}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanIdentifier{z}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{x} \spanOperator{=} \spanIdentifier{y}
  \spanKeyword{if} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{z}

\spanKeyword{var}
  \spanIdentifier{a} \spanOperator{=} \spanIdentifier{false}
  \spanIdentifier{b} \spanOperator{=} \spanIdentifier{true}
  \spanIdentifier{c} \spanOperator{=} \spanIdentifier{false}
\spanIdentifier{a} \spanOperator{=} \spanIdentifier{b} \spanKeyword{and} \spanIdentifier{c}
\spanIdentifier{echo} \spanIdentifier{a}
\end{rstpre}
\rsthC{The \texttt{*} operator}\label{pattern-operators-the-star-operator}
The \texttt{*} operator can \emph{flatten} a nested binary expression like \texttt{a \& b \& c} to \texttt{\&(a, b, c)}:

\begin{rstpre}
\spanKeyword{var}
  \spanIdentifier{calls} \spanOperator{=} \spanDecNumber{0}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{\&\&}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{s}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{1.}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{)}\spanOperator{-}\spanDecNumber{1}\spanPunctuation{:} \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{s}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}
  \spanIdentifier{inc} \spanIdentifier{calls}

\spanKeyword{template} \spanIdentifier{optConc}\spanPunctuation{\symbol{123}} \spanPunctuation{\symbol{96}}\spanOperator{\&\&}\spanPunctuation{\symbol{96}} \spanOperator{*} \spanIdentifier{a} \spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=} \spanOperator{\&\&}\spanIdentifier{a}

\spanKeyword{let} \spanIdentifier{space} \spanOperator{=} \spanStringLit{" "}
\spanIdentifier{echo} \spanStringLit{"my"} \spanOperator{\&\&} \spanPunctuation{(}\spanIdentifier{space} \spanOperator{\&} \spanStringLit{"awe"} \spanOperator{\&\&} \spanStringLit{"some "} \spanPunctuation{)} \spanOperator{\&\&} \spanStringLit{"concat"}

\spanComment{\# check that it's been optimized properly:}
\spanIdentifier{doAssert} \spanIdentifier{calls} \spanOperator{==} \spanDecNumber{1}
\end{rstpre}
The second operator of \texttt{*} must be a parameter; it is used to gather all the arguments. The expression \texttt{"my" \&\& (space \& "awe" \&\& "some " ) \&\& "concat"} is passed to \texttt{optConc} in \texttt{a} as a special list (of kind \texttt{nkArgList}) which is flattened into a call expression; thus the invocation of \texttt{optConc} produces:

\begin{rstpre}
\spanPunctuation{\symbol{96}}\spanOperator{\&\&}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanStringLit{"my"}\spanPunctuation{,} \spanIdentifier{space} \spanOperator{\&} \spanStringLit{"awe"}\spanPunctuation{,} \spanStringLit{"some "}\spanPunctuation{,} \spanStringLit{"concat"}\spanPunctuation{)}
\end{rstpre}
\rsthC{The \texttt{**} operator}\label{pattern-operators-the-starstar-operator}
The \texttt{**} is much like the \texttt{*} operator, except that it gathers not only all the arguments, but also the matched operators in reverse polish notation:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{macros}

\spanKeyword{type}
  \spanIdentifier{Matrix} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{dummy}\spanPunctuation{:} \spanIdentifier{int}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Matrix}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Matrix} \spanOperator{=} \spanKeyword{discard}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{+}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Matrix}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Matrix} \spanOperator{=} \spanKeyword{discard}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{-}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Matrix}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Matrix} \spanOperator{=} \spanKeyword{discard}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{\$}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{Matrix}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanIdentifier{result} \spanOperator{=} \spanOperator{\$}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{dummy}
\spanKeyword{proc} \spanIdentifier{mat21}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Matrix} \spanOperator{=}
  \spanIdentifier{result}\spanOperator{.}\spanIdentifier{dummy} \spanOperator{=} \spanDecNumber{21}

\spanKeyword{macro} \spanIdentifier{optM}\spanPunctuation{\symbol{123}} \spanPunctuation{(}\spanPunctuation{\symbol{96}}\spanOperator{+}\spanPunctuation{\symbol{96}}\spanOperator{|}\spanPunctuation{\symbol{96}}\spanOperator{-}\spanPunctuation{\symbol{96}}\spanOperator{|}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}}\spanPunctuation{)} \spanOperator{**} \spanIdentifier{a} \spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{Matrix}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanIdentifier{echo} \spanIdentifier{treeRepr}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{newCall}\spanPunctuation{(}\spanRawData{bindSym"mat21"}\spanPunctuation{)}

\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanIdentifier{z}\spanPunctuation{:} \spanIdentifier{Matrix}

\spanIdentifier{echo} \spanIdentifier{x} \spanOperator{+} \spanIdentifier{y} \spanOperator{*} \spanIdentifier{z} \spanOperator{-} \spanIdentifier{x}
\end{rstpre}
This passes the expression \texttt{x + y * z - x} to the \texttt{optM} macro as an \texttt{nnkArgList} node containing:\begin{rstpre}

Arglist
  Sym "x"
  Sym "y"
  Sym "z"
  Sym "*"
  Sym "+"
  Sym "x"
  Sym "-"
\end{rstpre}


(Which is the reverse polish notation of \texttt{x + y * z - x}.)

\rsthB{Parameters}\label{term-rewriting-macros-parameters}
Parameters in a pattern are type checked in the matching process. If a parameter is of the type \texttt{varargs} it is treated specially and it can match 0 or more arguments in the AST to be matched against:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{optWrite}\spanPunctuation{\symbol{123}}
  \spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{)}
  \spanPunctuation{(}\spanPunctuation{(}\spanIdentifier{write}\spanOperator{|}\spanIdentifier{writeLine}\spanPunctuation{)}\spanPunctuation{\symbol{123}}\spanIdentifier{w}\spanPunctuation{\symbol{125}}\spanPunctuation{)}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{)}
\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{untyped}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{File}\spanPunctuation{,} \spanIdentifier{w}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{w}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{)}
\end{rstpre}
\rsthB{Example: Partial evaluation}\label{term-rewriting-macros-examplecolon-partial-evaluation}
The following example shows how some simple partial evaluation can be implemented with term rewriting:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{;} \spanIdentifier{cond}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanKeyword{if} \spanIdentifier{cond}\spanPunctuation{:} \spanIdentifier{x} \spanOperator{+} \spanIdentifier{y} \spanKeyword{else}\spanPunctuation{:} \spanIdentifier{x} \spanOperator{-} \spanIdentifier{y}

\spanKeyword{template} \spanIdentifier{optP1}\spanPunctuation{\symbol{123}}\spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanIdentifier{true}\spanPunctuation{)}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=} \spanIdentifier{x} \spanOperator{+} \spanIdentifier{y}
\spanKeyword{template} \spanIdentifier{optP2}\spanPunctuation{\symbol{123}}\spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanIdentifier{false}\spanPunctuation{)}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=} \spanIdentifier{x} \spanOperator{-} \spanIdentifier{y}
\end{rstpre}
\rsthB{Example: Hoisting}\label{term-rewriting-macros-examplecolon-hoisting}
The following example shows how some form of hoisting can be implemented:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{pegs}

\spanKeyword{template} \spanIdentifier{optPeg}\spanPunctuation{\symbol{123}}\spanIdentifier{peg}\spanPunctuation{(}\spanIdentifier{pattern}\spanPunctuation{)}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{pattern}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{\symbol{123}}\spanIdentifier{lit}\spanPunctuation{\symbol{125}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Peg} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{gl} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{global}\spanPunctuation{,} \spanIdentifier{gensym}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanIdentifier{peg}\spanPunctuation{(}\spanIdentifier{pattern}\spanPunctuation{)}
  \spanIdentifier{gl}

\spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanDecNumber{0} \spanOperator{..} \spanDecNumber{3}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{match}\spanPunctuation{(}\spanStringLit{"(a b c)"}\spanPunctuation{,} \spanRawData{peg"'(' \symbol{64} ')'"}\spanPunctuation{)}
  \spanIdentifier{echo} \spanIdentifier{match}\spanPunctuation{(}\spanStringLit{"W\_HI\_Le"}\spanPunctuation{,} \spanRawData{peg"\symbol{92}y 'while'"}\spanPunctuation{)}
\end{rstpre}
The \texttt{optPeg} template optimizes the case of a peg constructor with a string literal, so that the pattern will only be parsed once at program startup and stored in a global \texttt{gl} which is then re-used. This optimization is called hoisting because it is comparable to classical loop hoisting.

\rsthA{AST based overloading}\label{ast-based-overloading}
Parameter constraints can also be used for ordinary routine parameters; these constraints affect ordinary overloading resolution then:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{optLit}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{\symbol{123}}\spanIdentifier{lit}\spanOperator{|}\spanPunctuation{\symbol{96}}\spanKeyword{const}\spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{125}}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"string literal"}
\spanKeyword{proc} \spanIdentifier{optLit}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"no string literal"}

\spanKeyword{const}
  \spanIdentifier{constant} \spanOperator{=} \spanStringLit{"abc"}

\spanKeyword{var}
  \spanIdentifier{variable} \spanOperator{=} \spanStringLit{"xyz"}

\spanIdentifier{optLit}\spanPunctuation{(}\spanStringLit{"literal"}\spanPunctuation{)}
\spanIdentifier{optLit}\spanPunctuation{(}\spanIdentifier{constant}\spanPunctuation{)}
\spanIdentifier{optLit}\spanPunctuation{(}\spanIdentifier{variable}\spanPunctuation{)}
\end{rstpre}
However, the constraints \texttt{alias} and \texttt{noalias} are not available in ordinary routines.

\rsthA{Parallel \& Spawn}\label{parallel-amp-spawn}
Nim has two flavors of parallelism:

\begin{enumerate}\item Structured\label{structured_1} parallelism via the \texttt{parallel} statement.
\item Unstructured\label{unstructured_1} parallelism via the standalone \texttt{spawn} statement.
\end{enumerate}
Nim has a builtin thread pool that can be used for CPU intensive tasks. For IO intensive tasks the \texttt{async} and \texttt{await} features should be used instead. Both parallel and spawn need the \href{threadpool.html}{threadpool} module to work.

Somewhat confusingly, \texttt{spawn} is also used in the \texttt{parallel} statement with slightly different semantics. \texttt{spawn} always takes a call expression of the form \texttt{f(a, ...)}. Let \texttt{T} be \texttt{f}'s return type. If \texttt{T} is \texttt{void} then \texttt{spawn}'s return type is also \texttt{void} otherwise it is \texttt{FlowVar\symbol{91}T\symbol{93}}.

Within a \texttt{parallel} section sometimes the \texttt{FlowVar\symbol{91}T\symbol{93}} is eliminated to \texttt{T}. This happens when \texttt{T} does not contain any GC'ed memory. The compiler can ensure the location in \texttt{location = spawn f(...)} is not read prematurely within a \texttt{parallel} section and so there is no need for the overhead of an indirection via \texttt{FlowVar\symbol{91}T\symbol{93}} to ensure correctness.

\textbf{Note}: Currently exceptions are not propagated between \texttt{spawn}'ed tasks!

\rsthB{Spawn statement}\label{parallel-amp-spawn-spawn-statement}
spawn\label{spawn_1} can be used to pass a task to the thread pool:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{threadpool}

\spanKeyword{proc} \spanIdentifier{processLine}\spanPunctuation{(}\spanIdentifier{line}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{discard} \spanStringLit{"do some heavy lifting here"}

\spanKeyword{for} \spanIdentifier{x} \spanKeyword{in} \spanIdentifier{lines}\spanPunctuation{(}\spanStringLit{"myinput.txt"}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{spawn} \spanIdentifier{processLine}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}
\spanIdentifier{sync}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
For reasons of type safety and implementation simplicity the expression that \texttt{spawn} takes is restricted:

\begin{itemize}\item It must be a call expression \texttt{f(a, ...)}.
\item \texttt{f} must be \texttt{gcsafe}.
\item \texttt{f} must not have the calling convention \texttt{closure}.
\item \texttt{f}'s parameters may not be of type \texttt{var}. This means one has to use raw \texttt{ptr}'s for data passing reminding the programmer to be careful.
\item \texttt{ref} parameters are deeply copied which is a subtle semantic change and can cause performance problems but ensures memory safety. This deep copy is performed via \texttt{system.deepCopy} and so can be overridden.
\item For \emph{safe} data exchange between \texttt{f} and the caller a global \texttt{TChannel} needs to be used. However, since spawn can return a result, often no further communication is required.
\end{itemize}
\texttt{spawn} executes the passed expression on the thread pool and returns a data flow variable\label{data-flow-variable_1} \texttt{FlowVar\symbol{91}T\symbol{93}} that can be read from. The reading with the \texttt{\symbol{94}} operator is \textbf{blocking}. However, one can use \texttt{blockUntilAny} to wait on multiple flow variables at the same time:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{threadpool}\spanPunctuation{,} \spanOperator{...}

\spanComment{\# wait until 2 out of 3 servers received the update:}
\spanKeyword{proc} \spanIdentifier{main} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{responses} \spanOperator{=} \spanIdentifier{newSeq}\spanPunctuation{\symbol{91}}\spanIdentifier{FlowVarBase}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{)}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{2}\spanPunctuation{:}
    \spanIdentifier{responses}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{spawn} \spanIdentifier{tellServer}\spanPunctuation{(}\spanIdentifier{Update}\spanPunctuation{,} \spanStringLit{"key"}\spanPunctuation{,} \spanStringLit{"value"}\spanPunctuation{)}
  \spanKeyword{var} \spanIdentifier{index} \spanOperator{=} \spanIdentifier{blockUntilAny}\spanPunctuation{(}\spanIdentifier{responses}\spanPunctuation{)}
  \spanIdentifier{assert} \spanIdentifier{index} \spanOperator{>=} \spanDecNumber{0}
  \spanIdentifier{responses}\spanOperator{.}\spanIdentifier{del}\spanPunctuation{(}\spanIdentifier{index}\spanPunctuation{)}
  \spanKeyword{discard} \spanIdentifier{blockUntilAny}\spanPunctuation{(}\spanIdentifier{responses}\spanPunctuation{)}
\end{rstpre}
Data flow variables ensure that no data races are possible. Due to technical limitations not every type \texttt{T} is possible in a data flow variable: \texttt{T} has to be of the type \texttt{ref}, \texttt{string}, \texttt{seq} or of a type that doesn't contain a type that is garbage collected. This restriction is not hard to work-around in practice.

\rsthB{Parallel statement}\label{parallel-amp-spawn-parallel-statement}
Example:

\begin{rstpre}
\spanComment{\# Compute PI in an inefficient way}
\spanKeyword{import} \spanIdentifier{strutils}\spanPunctuation{,} \spanIdentifier{math}\spanPunctuation{,} \spanIdentifier{threadpool}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{experimental}\spanPunctuation{:} \spanStringLit{"parallel"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{proc} \spanIdentifier{term}\spanPunctuation{(}\spanIdentifier{k}\spanPunctuation{:} \spanIdentifier{float}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{float} \spanOperator{=} \spanDecNumber{4} \spanOperator{*} \spanIdentifier{math}\spanOperator{.}\spanIdentifier{pow}\spanPunctuation{(}\spanOperator{-}\spanDecNumber{1}\spanPunctuation{,} \spanIdentifier{k}\spanPunctuation{)} \spanOperator{/} \spanPunctuation{(}\spanDecNumber{2}\spanOperator{*}\spanIdentifier{k} \spanOperator{+} \spanDecNumber{1}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{pi}\spanPunctuation{(}\spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{float} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{ch} \spanOperator{=} \spanIdentifier{newSeq}\spanPunctuation{\symbol{91}}\spanIdentifier{float}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{n}\spanOperator{+}\spanDecNumber{1}\spanPunctuation{)}
  \spanIdentifier{parallel}\spanPunctuation{:}
    \spanKeyword{for} \spanIdentifier{k} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanIdentifier{ch}\spanOperator{.}\spanIdentifier{high}\spanPunctuation{:}
      \spanIdentifier{ch}\spanPunctuation{\symbol{91}}\spanIdentifier{k}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{spawn} \spanIdentifier{term}\spanPunctuation{(}\spanIdentifier{float}\spanPunctuation{(}\spanIdentifier{k}\spanPunctuation{)}\spanPunctuation{)}
  \spanKeyword{for} \spanIdentifier{k} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanIdentifier{ch}\spanOperator{.}\spanIdentifier{high}\spanPunctuation{:}
    \spanIdentifier{result} \spanOperator{+=} \spanIdentifier{ch}\spanPunctuation{\symbol{91}}\spanIdentifier{k}\spanPunctuation{\symbol{93}}

\spanIdentifier{echo} \spanIdentifier{formatFloat}\spanPunctuation{(}\spanIdentifier{pi}\spanPunctuation{(}\spanDecNumber{5000}\spanPunctuation{)}\spanPunctuation{)}
\end{rstpre}
The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a \texttt{parallel} section. This subset is checked during semantic analysis to be free of data races. A sophisticated disjoint checker\label{disjoint-checker_1} ensures that no data races are possible even though shared memory is extensively supported!

The subset is in fact the full language with the following restrictions / changes:

\begin{itemize}\item \texttt{spawn} within a \texttt{parallel} section has special semantics.
\item Every location of the form \texttt{a\symbol{91}i\symbol{93}} and \texttt{a\symbol{91}i..j\symbol{93}} and \texttt{dest} where \texttt{dest} is part of the pattern \texttt{dest = spawn f(...)} has to be provably disjoint. This is called the \emph{disjoint check}.
\item Every other complex location \texttt{loc} that is used in a spawned proc (\texttt{spawn f(loc)}) has to be immutable for the duration of the \texttt{parallel} section. This is called the \emph{immutability check}. Currently it is not specified what exactly "complex location" means. We need to make this an optimization!
\item Every array access has to be provably within bounds. This is called the \emph{bounds check}.
\item Slices are optimized so that no copy is performed. This optimization is not yet performed for ordinary slices outside of a \texttt{parallel} section.
\end{itemize}
\rsthA{Guards and locks}\label{guards-and-locks}
Apart from \texttt{spawn} and \texttt{parallel} Nim also provides all the common low level concurrency mechanisms like locks, atomic intrinsics or condition variables.

Nim significantly improves on the safety of these features via additional pragmas:

\begin{enumerate}\item A guard\label{guard_1} annotation is introduced to prevent data races.
\item Every access of a guarded memory location needs to happen in an appropriate locks\label{locks_1} statement.
\item Locks and routines can be annotated with lock levels\label{lock-levels_1} to allow potential deadlocks to be detected during semantic analysis.
\end{enumerate}
\rsthB{Guards and the locks section}\label{guards-and-locks-guards-and-the-locks-section}
\rsthC{Protecting global variables}\label{guards-and-the-locks-section-protecting-global-variables}
Object fields and global variables can be annotated via a \texttt{guard} pragma:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{glock}\spanPunctuation{:} \spanIdentifier{TLock}
\spanKeyword{var} \spanIdentifier{gdata} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{guard}\spanPunctuation{:} \spanIdentifier{glock}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int}
\end{rstpre}
The compiler then ensures that every access of \texttt{gdata} is within a \texttt{locks} section:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{invalid} \spanOperator{=}
  \spanComment{\# invalid: unguarded access:}
  \spanIdentifier{echo} \spanIdentifier{gdata}

\spanKeyword{proc} \spanIdentifier{valid} \spanOperator{=}
  \spanComment{\# valid access:}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{glock}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
    \spanIdentifier{echo} \spanIdentifier{gdata}
\end{rstpre}
Top level accesses to \texttt{gdata} are always allowed so that it can be initialized conveniently. It is \emph{assumed} (but not enforced) that every top level statement is executed before any concurrent action happens.

The \texttt{locks} section deliberately looks ugly because it has no runtime semantics and should not be used directly! It should only be used in templates that also implement some form of locking at runtime:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{lock}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{TLock}\spanPunctuation{;} \spanIdentifier{body}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{pthread\_mutex\_lock}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{a}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
    \spanKeyword{try}\spanPunctuation{:}
      \spanIdentifier{body}
    \spanKeyword{finally}\spanPunctuation{:}
      \spanIdentifier{pthread\_mutex\_unlock}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}
\end{rstpre}
The guard does not need to be of any particular type. It is flexible enough to model low level lockfree mechanisms:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{dummyLock} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{compileTime}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int}
\spanKeyword{var} \spanIdentifier{atomicCounter} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{guard}\spanPunctuation{:} \spanIdentifier{dummyLock}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int}

\spanKeyword{template} \spanIdentifier{atomicRead}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{dummyLock}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
    \spanIdentifier{memoryReadBarrier}\spanPunctuation{(}\spanPunctuation{)}
    \spanIdentifier{x}

\spanIdentifier{echo} \spanIdentifier{atomicRead}\spanPunctuation{(}\spanIdentifier{atomicCounter}\spanPunctuation{)}
\end{rstpre}
The \texttt{locks} pragma takes a list of lock expressions \texttt{locks: \symbol{91}a, b, ...\symbol{93}} in order to support \emph{multi lock} statements. Why these are essential is explained in the \href{\#guards-and-locks-lock-levels}{lock levels} section.

\rsthC{Protecting general locations}\label{guards-and-the-locks-section-protecting-general-locations}
The \texttt{guard} annotation can also be used to protect fields within an object. The guard then needs to be another field within the same object or a global variable.

Since objects can reside on the heap or on the stack this greatly enhances the expressivity of the language:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{ProtectedCounter} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{v} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{guard}\spanPunctuation{:} \spanIdentifier{L}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int}
    \spanIdentifier{L}\spanPunctuation{:} \spanIdentifier{TLock}

\spanKeyword{proc} \spanIdentifier{incCounters}\spanPunctuation{(}\spanIdentifier{counters}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{openArray}\spanPunctuation{\symbol{91}}\spanIdentifier{ProtectedCounter}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanIdentifier{counters}\spanOperator{.}\spanIdentifier{high}\spanPunctuation{:}
    \spanIdentifier{lock} \spanIdentifier{counters}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanIdentifier{L}\spanPunctuation{:}
      \spanIdentifier{inc} \spanIdentifier{counters}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanIdentifier{v}
\end{rstpre}
The access to field \texttt{x.v} is allowed since its guard \texttt{x.L}  is active. After template expansion, this amounts to:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{incCounters}\spanPunctuation{(}\spanIdentifier{counters}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{openArray}\spanPunctuation{\symbol{91}}\spanIdentifier{ProtectedCounter}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanIdentifier{counters}\spanOperator{.}\spanIdentifier{high}\spanPunctuation{:}
    \spanIdentifier{pthread\_mutex\_lock}\spanPunctuation{(}\spanIdentifier{counters}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanIdentifier{L}\spanPunctuation{)}
    \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{counters}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanIdentifier{L}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
      \spanKeyword{try}\spanPunctuation{:}
        \spanIdentifier{inc} \spanIdentifier{counters}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanIdentifier{v}
      \spanKeyword{finally}\spanPunctuation{:}
        \spanIdentifier{pthread\_mutex\_unlock}\spanPunctuation{(}\spanIdentifier{counters}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanIdentifier{L}\spanPunctuation{)}
\end{rstpre}
There is an analysis that checks that \texttt{counters\symbol{91}i\symbol{93}.L} is the lock that corresponds to the protected location \texttt{counters\symbol{91}i\symbol{93}.v}. This analysis is called path analysis\label{path-analysis_1} because it deals with paths to locations like \texttt{obj.field\symbol{91}i\symbol{93}.fieldB\symbol{91}j\symbol{93}}.

The path analysis is \textbf{currently unsound}, but that doesn't make it useless. Two paths are considered equivalent if they are syntactically the same.

This means the following compiles (for now) even though it really should not:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanIdentifier{L}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
  \spanIdentifier{inc} \spanIdentifier{i}
  \spanIdentifier{access} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanIdentifier{v}
\end{rstpre}
\rsthB{Lock levels}\label{guards-and-locks-lock-levels}
Lock levels are used to enforce a global locking order in order to detect potential deadlocks during semantic analysis. A lock level is an constant integer in the range 0..1\_000. Lock level 0 means that no lock is acquired at all.

If a section of code holds a lock of level \texttt{M} than it can also acquire any lock of level \texttt{N < M}. Another lock of level \texttt{M} cannot be acquired. Locks of the same level can only be acquired \emph{at the same time} within a single \texttt{locks} section:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{TLock}\spanPunctuation{\symbol{91}}\spanDecNumber{2}\spanPunctuation{\symbol{93}}
\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{TLock}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}}
\spanComment{\# invalid locking order: TLock\symbol{91}1\symbol{93} cannot be acquired before TLock\symbol{91}2\symbol{93}:}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{x}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{a}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
    \spanOperator{...}
\spanComment{\# valid locking order: TLock\symbol{91}2\symbol{93} acquired before TLock\symbol{91}1\symbol{93}:}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{a}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{x}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
    \spanOperator{...}

\spanComment{\# invalid locking order: TLock\symbol{91}2\symbol{93} acquired before TLock\symbol{91}2\symbol{93}:}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{a}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{b}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
    \spanOperator{...}

\spanComment{\# valid locking order, locks of the same level acquired at the same time:}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
  \spanOperator{...}
\end{rstpre}
Here is how a typical multilock statement can be implemented in Nim. Note how the runtime check is required to ensure a global ordering for two locks \texttt{a} and \texttt{b} of the same lock level:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{multilock}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanKeyword{ptr} \spanIdentifier{TLock}\spanPunctuation{;} \spanIdentifier{body}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{if} \spanKeyword{cast}\spanPunctuation{\symbol{91}}\spanIdentifier{ByteAddress}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)} \spanOperator{<} \spanKeyword{cast}\spanPunctuation{\symbol{91}}\spanIdentifier{ByteAddress}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{:}
    \spanIdentifier{pthread\_mutex\_lock}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}
    \spanIdentifier{pthread\_mutex\_lock}\spanPunctuation{(}\spanIdentifier{b}\spanPunctuation{)}
  \spanKeyword{else}\spanPunctuation{:}
    \spanIdentifier{pthread\_mutex\_lock}\spanPunctuation{(}\spanIdentifier{b}\spanPunctuation{)}
    \spanIdentifier{pthread\_mutex\_lock}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
    \spanKeyword{try}\spanPunctuation{:}
      \spanIdentifier{body}
    \spanKeyword{finally}\spanPunctuation{:}
      \spanIdentifier{pthread\_mutex\_unlock}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}
      \spanIdentifier{pthread\_mutex\_unlock}\spanPunctuation{(}\spanIdentifier{b}\spanPunctuation{)}
\end{rstpre}
Whole routines can also be annotated with a \texttt{locks} pragma that takes a lock level. This then means that the routine may acquire locks of up to this level. This is essential so that procs can be called within a \texttt{locks} section:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanFloatNumber{3.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{discard}

\spanKeyword{var} \spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{TLock}\spanPunctuation{\symbol{91}}\spanDecNumber{4}\spanPunctuation{\symbol{93}}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{locks}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{a}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
  \spanComment{\# p's locklevel (3) is strictly less than a's (4) so the call is allowed:}
  \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
As usual \texttt{locks} is an inferred effect and there is a subtype relation: \texttt{proc () \symbol{123}.locks: N.\symbol{125}} is a subtype of \texttt{proc () \symbol{123}.locks: M.\symbol{125}} iff (M <= N).

The \texttt{locks} pragma can also take the special value \texttt{"unknown"}. This is useful in the context of dynamic method dispatching. In the following example, the compiler can infer a lock level of 0 for the \texttt{base} case. However, one of the overloaded methods calls a procvar which is potentially locking. Thus, the lock level of calling \texttt{g.testMethod} cannot be inferred statically, leading to compiler warnings. By using \texttt{\symbol{123}.locks: "unknown".\symbol{125}}, the base method can be marked explicitly as having unknown lock level as well:

\begin{rstpre}
\spanKeyword{type} \spanIdentifier{SomeBase}\spanOperator{*} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{RootObj}
\spanKeyword{type} \spanIdentifier{SomeDerived}\spanOperator{*} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{SomeBase}
  \spanIdentifier{memberProc}\spanOperator{*:} \spanKeyword{proc} \spanPunctuation{(}\spanPunctuation{)}

\spanKeyword{method} \spanIdentifier{testMethod}\spanPunctuation{(}\spanIdentifier{g}\spanPunctuation{:} \spanIdentifier{SomeBase}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{base}\spanPunctuation{,} \spanIdentifier{locks}\spanPunctuation{:} \spanStringLit{"unknown"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{discard}
\spanKeyword{method} \spanIdentifier{testMethod}\spanPunctuation{(}\spanIdentifier{g}\spanPunctuation{:} \spanIdentifier{SomeDerived}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{if} \spanIdentifier{g}\spanOperator{.}\spanIdentifier{memberProc} \spanOperator{!=} \spanKeyword{nil}\spanPunctuation{:}
    \spanIdentifier{g}\spanOperator{.}\spanIdentifier{memberProc}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
\rsthB{noRewrite pragma}\label{guards-and-locks-norewrite-pragma}
Term rewriting macros and templates are currently greedy and they will rewrite as long as there is a match. There was no way to ensure some rewrite happens only once, eg. when rewriting term to same term plus extra content.

\texttt{noRewrite} pragma can actually prevent further rewriting on marked code, e.g. with given example \texttt{echo("ab")} will be rewritten just once:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{pwnEcho}\spanPunctuation{\symbol{123}}\spanIdentifier{echo}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}\spanPunctuation{\symbol{125}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{expr}\spanPunctuation{)} \spanOperator{=}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{noRewrite}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{echo}\spanPunctuation{(}\spanStringLit{"pwned!"}\spanPunctuation{)}

\spanIdentifier{echo} \spanStringLit{"ab"}
\end{rstpre}
\texttt{noRewrite} pragma can be useful to control term-rewriting macros recursion.

\rsthA{Taint mode}\label{taint-mode}
The Nim compiler and most parts of the standard library support a taint mode. Input strings are declared with the TaintedString\label{taintedstring_1} string type declared in the \texttt{system} module.

If the taint mode is turned on (via the \texttt{--taintMode:on} command line option) it is a distinct string type which helps to detect input validation errors:

\begin{rstpre}
\spanIdentifier{echo} \spanStringLit{"your name: "}
\spanKeyword{var} \spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{TaintedString} \spanOperator{=} \spanIdentifier{stdin}\spanOperator{.}\spanIdentifier{readline}
\spanComment{\# it is safe here to output the name without any input validation, so}
\spanComment{\# we simply convert \symbol{96}name\symbol{96} to string to make the compiler happy:}
\spanIdentifier{echo} \spanStringLit{"hi, "}\spanPunctuation{,} \spanIdentifier{name}\spanOperator{.}\spanIdentifier{string}
\end{rstpre}
If the taint mode is turned off, \texttt{TaintedString} is simply an alias for \texttt{string}.

\rsthA{Aliasing restrictions in parameter passing}\label{aliasing-restrictions-in-parameter-passing}
\textbf{Note}: The aliasing restrictions are currently not enforced by the implementation and need to be fleshed out further.

"Aliasing" here means that the underlying storage locations overlap in memory at runtime. An "output parameter" is a parameter of type \texttt{var T}, an input parameter is any parameter that is not of type \texttt{var}.

\begin{enumerate}\item Two output parameters should never be aliased.
\item An input and an output parameter should not be aliased.
\item An output parameter should never be aliased with a global or thread local variable referenced by the called proc.
\item An input parameter should not be aliased with a global or thread local variable updated by the called proc.
\end{enumerate}
One problem with rules 3 and 4 is that they affect specific global or thread local variables, but Nim's effect tracking only tracks "uses no global variable" via \texttt{.noSideEffect}. The rules 3 and 4 can also be approximated by a different rule:

\begin{enumerate}\item A global or thread local variable (or a location derived from such a location) can only passed to a parameter of a \texttt{.noSideEffect} proc.
\end{enumerate}
\rsthA{Strict funcs}\label{strict-funcs}
Since version 1.4 a stricter definition of "side effect" is available. In addition to the existing rule that a side effect is calling a function with side effects the following rule is also enforced:

Any mutation to an object does count as a side effect if that object is reachable via a parameter that is not declared as a \texttt{var} parameter.

For example:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{experimental}\spanPunctuation{:} \spanStringLit{"strictFuncs"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{type}
  \spanIdentifier{Node} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object}
    \spanIdentifier{le}\spanPunctuation{,} \spanIdentifier{ri}\spanPunctuation{:} \spanIdentifier{Node}
    \spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{string}

\spanKeyword{func} \spanIdentifier{len}\spanPunctuation{(}\spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{Node}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanComment{\# valid: len does not have side effects}
  \spanKeyword{var} \spanIdentifier{it} \spanOperator{=} \spanIdentifier{n}
  \spanKeyword{while} \spanIdentifier{it} \spanOperator{!=} \spanKeyword{nil}\spanPunctuation{:}
    \spanIdentifier{inc} \spanIdentifier{result}
    \spanIdentifier{it} \spanOperator{=} \spanIdentifier{it}\spanOperator{.}\spanIdentifier{ri}

\spanKeyword{func} \spanIdentifier{mut}\spanPunctuation{(}\spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{Node}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{let} \spanIdentifier{m} \spanOperator{=} \spanIdentifier{n} \spanComment{\# is the statement that connected the mutation to the parameter}
  \spanIdentifier{m}\spanOperator{.}\spanIdentifier{data} \spanOperator{=} \spanStringLit{"yeah"} \spanComment{\# the mutation is here}
  \spanComment{\# Error: 'mut' can have side effects}
  \spanComment{\# an object reachable from 'n' is potentially mutated}
\end{rstpre}
The algorithm behind this analysis is currently not documented. 




\end{document}
