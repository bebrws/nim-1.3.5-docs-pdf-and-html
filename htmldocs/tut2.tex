% This file was generated by Nim.
% Generated: 2020-08-22 06:37:50 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{Nim Tutorial (Part II) 1.3.5}
\author{Andreas Rumpf}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

\tableofcontents \newpage
\rsthA{Introduction}\label{introduction}
\begin{quote}"Repetition renders the ridiculous reasonable." -- Norman Wildberger\end{quote}
This document is a tutorial for the advanced constructs of the \emph{Nim} programming language. \textbf{Note that this document is somewhat obsolete as the} \href{manual.html}{manual} \textbf{contains many more examples of the advanced language features.}

\rsthA{Pragmas}\label{pragmas}
Pragmas are Nim's method to give the compiler additional information/ commands without introducing a massive number of new keywords. Pragmas are enclosed in the special \texttt{\symbol{123}.} and \texttt{.\symbol{125}} curly dot brackets. This tutorial does not cover pragmas. See the \href{manual.html\#pragmas}{manual} or \href{nimc.html\#additional-features}{user guide} for a description of the available pragmas.

\rsthA{Object Oriented Programming}\label{object-oriented-programming}
While Nim's support for object oriented programming (OOP) is minimalistic, powerful OOP techniques can be used. OOP is seen as \emph{one} way to design a program, not \emph{the only} way. Often a procedural approach leads to simpler and more efficient code. In particular, preferring composition over inheritance is often the better design.

\rsthB{Inheritance}\label{object-oriented-programming-inheritance}
Inheritance in Nim is entirely optional. To enable inheritance with runtime type information the object needs to inherit from \texttt{RootObj}.  This can be done directly, or indirectly by inheriting from an object that inherits from \texttt{RootObj}.  Usually types with inheritance are also marked as \texttt{ref} types even though this isn't strictly enforced. To check at runtime if an object is of a certain type, the \texttt{of} operator can be used.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Person} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{RootObj}
    \spanIdentifier{name}\spanOperator{*:} \spanIdentifier{string}  \spanComment{\# the * means that \symbol{96}name\symbol{96} is accessible from other modules}
    \spanIdentifier{age}\spanPunctuation{:} \spanIdentifier{int}       \spanComment{\# no * means that the field is hidden from other modules}
  
  \spanIdentifier{Student} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Person} \spanComment{\# Student inherits from Person}
    \spanIdentifier{id}\spanPunctuation{:} \spanIdentifier{int}                      \spanComment{\# with an id field}

\spanKeyword{var}
  \spanIdentifier{student}\spanPunctuation{:} \spanIdentifier{Student}
  \spanIdentifier{person}\spanPunctuation{:} \spanIdentifier{Person}
\spanIdentifier{assert}\spanPunctuation{(}\spanIdentifier{student} \spanKeyword{of} \spanIdentifier{Student}\spanPunctuation{)} \spanComment{\# is true}
\spanComment{\# object construction:}
\spanIdentifier{student} \spanOperator{=} \spanIdentifier{Student}\spanPunctuation{(}\spanIdentifier{name}\spanPunctuation{:} \spanStringLit{"Anton"}\spanPunctuation{,} \spanIdentifier{age}\spanPunctuation{:} \spanDecNumber{5}\spanPunctuation{,} \spanIdentifier{id}\spanPunctuation{:} \spanDecNumber{2}\spanPunctuation{)}
\spanIdentifier{echo} \spanIdentifier{student}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}
\end{rstpre}
Inheritance is done with the \texttt{object of} syntax. Multiple inheritance is currently not supported. If an object type has no suitable ancestor, \texttt{RootObj} can be used as its ancestor, but this is only a convention. Objects that have no ancestor are implicitly \texttt{final}. You can use the \texttt{inheritable} pragma to introduce new object roots apart from \texttt{system.RootObj}. (This is used in the GTK wrapper for instance.)

Ref objects should be used whenever inheritance is used. It isn't strictly necessary, but with non-ref objects assignments such as \texttt{let person: Person = Student(id: 123)} will truncate subclass fields.

\textbf{Note}: Composition (\emph{has-a} relation) is often preferable to inheritance (\emph{is-a} relation) for simple code reuse. Since objects are value types in Nim, composition is as efficient as inheritance.

\rsthB{Mutually recursive types}\label{object-oriented-programming-mutually-recursive-types}
Objects, tuples and references can model quite complex data structures which depend on each other; they are \emph{mutually recursive}. In Nim these types can only be declared within a single type section. (Anything else would require arbitrary symbol lookahead which slows down compilation.)

Example:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Node} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object}  \spanComment{\# a reference to an object with the following field:}
    \spanIdentifier{le}\spanPunctuation{,} \spanIdentifier{ri}\spanPunctuation{:} \spanIdentifier{Node}     \spanComment{\# left and right subtrees}
    \spanIdentifier{sym}\spanPunctuation{:} \spanKeyword{ref} \spanIdentifier{Sym}     \spanComment{\# leaves contain a reference to a Sym}
  
  \spanIdentifier{Sym} \spanOperator{=} \spanKeyword{object}       \spanComment{\# a symbol}
    \spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{string}     \spanComment{\# the symbol's name}
    \spanIdentifier{line}\spanPunctuation{:} \spanIdentifier{int}        \spanComment{\# the line the symbol was declared in}
    \spanIdentifier{code}\spanPunctuation{:} \spanIdentifier{Node}       \spanComment{\# the symbol's abstract syntax tree}
\end{rstpre}
\rsthB{Type conversions}\label{object-oriented-programming-type-conversions}
Nim distinguishes between type casts\label{type-casts_1} and type conversions\label{type-conversions_1}. Casts are done with the \texttt{cast} operator and force the compiler to interpret a bit pattern to be of another type.

Type conversions are a much more polite way to convert a type into another: They preserve the abstract \emph{value}, not necessarily the \emph{bit-pattern}. If a type conversion is not possible, the compiler complains or an exception is raised.

The syntax for type conversions is \texttt{destination\_type(expression\_to\_convert)} (like an ordinary call):

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{getID}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{Person}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{Student}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}\spanOperator{.}\spanIdentifier{id}
\end{rstpre}
The \texttt{InvalidObjectConversionDefect} exception is raised if \texttt{x} is not a \texttt{Student}.

\rsthB{Object variants}\label{object-oriented-programming-object-variants}
Often an object hierarchy is overkill in certain situations where simple variant types are needed.

An example:

\begin{rstpre}
\spanComment{\# This is an example how an abstract syntax tree could be modelled in Nim}
\spanKeyword{type}
  \spanIdentifier{NodeKind} \spanOperator{=} \spanKeyword{enum}  \spanComment{\# the different node types}
    \spanIdentifier{nkInt}\spanPunctuation{,}          \spanComment{\# a leaf with an integer value}
    \spanIdentifier{nkFloat}\spanPunctuation{,}        \spanComment{\# a leaf with a float value}
    \spanIdentifier{nkString}\spanPunctuation{,}       \spanComment{\# a leaf with a string value}
    \spanIdentifier{nkAdd}\spanPunctuation{,}          \spanComment{\# an addition}
    \spanIdentifier{nkSub}\spanPunctuation{,}          \spanComment{\# a subtraction}
    \spanIdentifier{nkIf}            \spanComment{\# an if statement}
  \spanIdentifier{Node} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object}
    \spanKeyword{case} \spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{NodeKind}  \spanComment{\# the \symbol{96}\symbol{96}kind\symbol{96}\symbol{96} field is the discriminator}
    \spanKeyword{of} \spanIdentifier{nkInt}\spanPunctuation{:} \spanIdentifier{intVal}\spanPunctuation{:} \spanIdentifier{int}
    \spanKeyword{of} \spanIdentifier{nkFloat}\spanPunctuation{:} \spanIdentifier{floatVal}\spanPunctuation{:} \spanIdentifier{float}
    \spanKeyword{of} \spanIdentifier{nkString}\spanPunctuation{:} \spanIdentifier{strVal}\spanPunctuation{:} \spanIdentifier{string}
    \spanKeyword{of} \spanIdentifier{nkAdd}\spanPunctuation{,} \spanIdentifier{nkSub}\spanPunctuation{:}
      \spanIdentifier{leftOp}\spanPunctuation{,} \spanIdentifier{rightOp}\spanPunctuation{:} \spanIdentifier{Node}
    \spanKeyword{of} \spanIdentifier{nkIf}\spanPunctuation{:}
      \spanIdentifier{condition}\spanPunctuation{,} \spanIdentifier{thenPart}\spanPunctuation{,} \spanIdentifier{elsePart}\spanPunctuation{:} \spanIdentifier{Node}

\spanKeyword{var} \spanIdentifier{n} \spanOperator{=} \spanIdentifier{Node}\spanPunctuation{(}\spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{nkFloat}\spanPunctuation{,} \spanIdentifier{floatVal}\spanPunctuation{:} \spanFloatNumber{1.0}\spanPunctuation{)}
\spanComment{\# the following statement raises an \symbol{96}FieldDefect\symbol{96} exception, because}
\spanComment{\# n.kind's value does not fit:}
\spanIdentifier{n}\spanOperator{.}\spanIdentifier{strVal} \spanOperator{=} \spanStringLit{""}
\end{rstpre}
As can been seen from the example, an advantage to an object hierarchy is that no conversion between different object types is needed. Yet, access to invalid object fields raises an exception.

\rsthB{Method call syntax}\label{object-oriented-programming-method-call-syntax}
There is a syntactic sugar for calling routines: The syntax \texttt{obj.method(args)} can be used instead of \texttt{method(obj, args)}. If there are no remaining arguments, the parentheses can be omitted: \texttt{obj.len} (instead of \texttt{len(obj)}).

This method call syntax is not restricted to objects, it can be used for any type:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{strutils}

\spanIdentifier{echo} \spanStringLit{"abc"}\spanOperator{.}\spanIdentifier{len} \spanComment{\# is the same as echo len("abc")}
\spanIdentifier{echo} \spanStringLit{"abc"}\spanOperator{.}\spanIdentifier{toUpperAscii}\spanPunctuation{(}\spanPunctuation{)}
\spanIdentifier{echo}\spanPunctuation{(}\spanPunctuation{\symbol{123}}\spanCharLit{'a'}\spanPunctuation{,} \spanCharLit{'b'}\spanPunctuation{,} \spanCharLit{'c'}\spanPunctuation{\symbol{125}}\spanOperator{.}\spanIdentifier{card}\spanPunctuation{)}
\spanIdentifier{stdout}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanStringLit{"Hallo"}\spanPunctuation{)} \spanComment{\# the same as writeLine(stdout, "Hallo")}
\end{rstpre}
(Another way to look at the method call syntax is that it provides the missing postfix notation.)

So "pure object oriented" code is easy to write:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{strutils}\spanPunctuation{,} \spanIdentifier{sequtils}

\spanIdentifier{stdout}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanStringLit{"Give a list of numbers (separated by spaces): "}\spanPunctuation{)}
\spanIdentifier{stdout}\spanOperator{.}\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdin}\spanOperator{.}\spanIdentifier{readLine}\spanOperator{.}\spanIdentifier{splitWhitespace}\spanOperator{.}\spanIdentifier{map}\spanPunctuation{(}\spanIdentifier{parseInt}\spanPunctuation{)}\spanOperator{.}\spanIdentifier{max}\spanOperator{.}\spanPunctuation{\symbol{96}}\spanOperator{\$}\spanPunctuation{\symbol{96}}\spanPunctuation{)}
\spanIdentifier{stdout}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanStringLit{" is the maximum!"}\spanPunctuation{)}
\end{rstpre}
\rsthB{Properties}\label{object-oriented-programming-properties}
As the above example shows, Nim has no need for \emph{get-properties}: Ordinary get-procedures that are called with the \emph{method call syntax} achieve the same. But setting a value is different; for this a special setter syntax is needed:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Socket}\spanOperator{*} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{RootObj}
    \spanIdentifier{h}\spanPunctuation{:} \spanIdentifier{int} \spanComment{\# cannot be accessed from the outside of the module due to missing star}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanIdentifier{host}\spanOperator{=}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{Socket}\spanPunctuation{,} \spanIdentifier{value}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{inline}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanComment{\#\# setter of host address}
  \spanIdentifier{s}\spanOperator{.}\spanIdentifier{h} \spanOperator{=} \spanIdentifier{value}

\spanKeyword{proc} \spanIdentifier{host}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{Socket}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{inline}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanComment{\#\# getter of host address}
  \spanIdentifier{s}\spanOperator{.}\spanIdentifier{h}

\spanKeyword{var} \spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{Socket}
\spanIdentifier{new} \spanIdentifier{s}
\spanIdentifier{s}\spanOperator{.}\spanIdentifier{host} \spanOperator{=} \spanDecNumber{34}  \spanComment{\# same as \symbol{96}host=\symbol{96}(s, 34)}
\end{rstpre}
(The example also shows \texttt{inline} procedures.)

The \texttt{\symbol{91}\symbol{93}} array access operator can be overloaded to provide array properties\label{array-properties_1}:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Vector}\spanOperator{*} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanIdentifier{z}\spanPunctuation{:} \spanIdentifier{float}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanOperator{=}\spanPunctuation{\symbol{96}}\spanOperator{*} \spanPunctuation{(}\spanIdentifier{v}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{Vector}\spanPunctuation{,} \spanIdentifier{i}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{value}\spanPunctuation{:} \spanIdentifier{float}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# setter}
  \spanKeyword{case} \spanIdentifier{i}
  \spanKeyword{of} \spanDecNumber{0}\spanPunctuation{:} \spanIdentifier{v}\spanOperator{.}\spanIdentifier{x} \spanOperator{=} \spanIdentifier{value}
  \spanKeyword{of} \spanDecNumber{1}\spanPunctuation{:} \spanIdentifier{v}\spanOperator{.}\spanIdentifier{y} \spanOperator{=} \spanIdentifier{value}
  \spanKeyword{of} \spanDecNumber{2}\spanPunctuation{:} \spanIdentifier{v}\spanOperator{.}\spanIdentifier{z} \spanOperator{=} \spanIdentifier{value}
  \spanKeyword{else}\spanPunctuation{:} \spanIdentifier{assert}\spanPunctuation{(}\spanIdentifier{false}\spanPunctuation{)}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{96}}\spanOperator{*} \spanPunctuation{(}\spanIdentifier{v}\spanPunctuation{:} \spanIdentifier{Vector}\spanPunctuation{,} \spanIdentifier{i}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{float} \spanOperator{=}
  \spanComment{\# getter}
  \spanKeyword{case} \spanIdentifier{i}
  \spanKeyword{of} \spanDecNumber{0}\spanPunctuation{:} \spanIdentifier{result} \spanOperator{=} \spanIdentifier{v}\spanOperator{.}\spanIdentifier{x}
  \spanKeyword{of} \spanDecNumber{1}\spanPunctuation{:} \spanIdentifier{result} \spanOperator{=} \spanIdentifier{v}\spanOperator{.}\spanIdentifier{y}
  \spanKeyword{of} \spanDecNumber{2}\spanPunctuation{:} \spanIdentifier{result} \spanOperator{=} \spanIdentifier{v}\spanOperator{.}\spanIdentifier{z}
  \spanKeyword{else}\spanPunctuation{:} \spanIdentifier{assert}\spanPunctuation{(}\spanIdentifier{false}\spanPunctuation{)}
\end{rstpre}
The example is silly, since a vector is better modelled by a tuple which already provides \texttt{v\symbol{91}\symbol{93}} access.

\rsthB{Dynamic dispatch}\label{object-oriented-programming-dynamic-dispatch}
Procedures always use static dispatch. For dynamic dispatch replace the \texttt{proc} keyword by \texttt{method}:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Expression} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{RootObj} \spanComment{\#\# abstract base class for an expression}
  \spanIdentifier{Literal} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Expression}
    \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}
  \spanIdentifier{PlusExpr} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Expression}
    \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Expression}

\spanComment{\# watch out: 'eval' relies on dynamic binding}
\spanKeyword{method} \spanIdentifier{eval}\spanPunctuation{(}\spanIdentifier{e}\spanPunctuation{:} \spanIdentifier{Expression}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{base}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanComment{\# override this base method}
  \spanIdentifier{quit} \spanStringLit{"to override!"}

\spanKeyword{method} \spanIdentifier{eval}\spanPunctuation{(}\spanIdentifier{e}\spanPunctuation{:} \spanIdentifier{Literal}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanIdentifier{e}\spanOperator{.}\spanIdentifier{x}
\spanKeyword{method} \spanIdentifier{eval}\spanPunctuation{(}\spanIdentifier{e}\spanPunctuation{:} \spanIdentifier{PlusExpr}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanIdentifier{eval}\spanPunctuation{(}\spanIdentifier{e}\spanOperator{.}\spanIdentifier{a}\spanPunctuation{)} \spanOperator{+} \spanIdentifier{eval}\spanPunctuation{(}\spanIdentifier{e}\spanOperator{.}\spanIdentifier{b}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{newLit}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Literal} \spanOperator{=} \spanIdentifier{Literal}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{x}\spanPunctuation{)}
\spanKeyword{proc} \spanIdentifier{newPlus}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Expression}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{PlusExpr} \spanOperator{=} \spanIdentifier{PlusExpr}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{b}\spanPunctuation{)}

\spanIdentifier{echo} \spanIdentifier{eval}\spanPunctuation{(}\spanIdentifier{newPlus}\spanPunctuation{(}\spanIdentifier{newPlus}\spanPunctuation{(}\spanIdentifier{newLit}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{newLit}\spanPunctuation{(}\spanDecNumber{2}\spanPunctuation{)}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{newLit}\spanPunctuation{(}\spanDecNumber{4}\spanPunctuation{)}\spanPunctuation{)}\spanPunctuation{)}
\end{rstpre}
Note that in the example the constructors \texttt{newLit} and \texttt{newPlus} are procs because it makes more sense for them to use static binding, but \texttt{eval} is a method because it requires dynamic binding.

\textbf{Note:} Starting from Nim 0.20, to use multi-methods one must explicitly pass \texttt{--multimethods:on} when compiling.

In a multi-method all parameters that have an object type are used for the dispatching:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Thing} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{RootObj}
  \spanIdentifier{Unit} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Thing}
    \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}

\spanKeyword{method} \spanIdentifier{collide}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Thing}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{inline}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{quit} \spanStringLit{"to override!"}

\spanKeyword{method} \spanIdentifier{collide}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{Thing}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Unit}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{inline}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"1"}

\spanKeyword{method} \spanIdentifier{collide}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{Unit}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Thing}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{inline}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"2"}

\spanKeyword{var} \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Unit}
\spanIdentifier{new} \spanIdentifier{a}
\spanIdentifier{new} \spanIdentifier{b}
\spanIdentifier{collide}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)} \spanComment{\# output: 2}
\end{rstpre}
As the example demonstrates, invocation of a multi-method cannot be ambiguous: Collide 2 is preferred over collide 1 because the resolution works from left to right. Thus \texttt{Unit, Thing} is preferred over \texttt{Thing, Unit}.

\textbf{Performance note}: Nim does not produce a virtual method table, but generates dispatch trees. This avoids the expensive indirect branch for method calls and enables inlining. However, other optimizations like compile time evaluation or dead code elimination do not work with methods.

\rsthA{Exceptions}\label{exceptions}
In Nim exceptions are objects. By convention, exception types are suffixed with 'Error'. The \href{system.html}{system} module defines an exception hierarchy that you might want to stick to. Exceptions derive from \texttt{system.Exception}, which provides the common interface.

Exceptions have to be allocated on the heap because their lifetime is unknown. The compiler will prevent you from raising an exception created on the stack. All raised exceptions should at least specify the reason for being raised in the \texttt{msg} field.

A convention is that exceptions should be raised in \emph{exceptional} cases: For example, if a file cannot be opened, this should not raise an exception since this is quite common (the file may not exist).

\rsthB{Raise statement}\label{exceptions-raise-statement}
Raising an exception is done with the \texttt{raise} statement:

\begin{rstpre}
\spanKeyword{var}
  \spanIdentifier{e}\spanPunctuation{:} \spanKeyword{ref} \spanIdentifier{OSError}
\spanIdentifier{new}\spanPunctuation{(}\spanIdentifier{e}\spanPunctuation{)}
\spanIdentifier{e}\spanOperator{.}\spanIdentifier{msg} \spanOperator{=} \spanStringLit{"the request to the OS failed"}
\spanKeyword{raise} \spanIdentifier{e}
\end{rstpre}
If the \texttt{raise} keyword is not followed by an expression, the last exception is \emph{re-raised}. For the purpose of avoiding repeating this common code pattern, the template \texttt{newException} in the \texttt{system} module can be used:

\begin{rstpre}
\spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{OSError}\spanPunctuation{,} \spanStringLit{"the request to the OS failed"}\spanPunctuation{)}
\end{rstpre}
\rsthB{Try statement}\label{exceptions-try-statement}
The \texttt{try} statement handles exceptions:

\begin{rstpre}
\spanKeyword{from} \spanIdentifier{strutils} \spanKeyword{import} \spanIdentifier{parseInt}

\spanComment{\# read the first two lines of a text file that should contain numbers}
\spanComment{\# and tries to add them}
\spanKeyword{var}
  \spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{File}
\spanKeyword{if} \spanIdentifier{open}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanStringLit{"numbers.txt"}\spanPunctuation{)}\spanPunctuation{:}
  \spanKeyword{try}\spanPunctuation{:}
    \spanKeyword{let} \spanIdentifier{a} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{)}
    \spanKeyword{let} \spanIdentifier{b} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{)}
    \spanIdentifier{echo} \spanStringLit{"sum: "}\spanPunctuation{,} \spanIdentifier{parseInt}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)} \spanOperator{+} \spanIdentifier{parseInt}\spanPunctuation{(}\spanIdentifier{b}\spanPunctuation{)}
  \spanKeyword{except} \spanIdentifier{OverflowDefect}\spanPunctuation{:}
    \spanIdentifier{echo} \spanStringLit{"overflow!"}
  \spanKeyword{except} \spanIdentifier{ValueError}\spanPunctuation{:}
    \spanIdentifier{echo} \spanStringLit{"could not convert string to integer"}
  \spanKeyword{except} \spanIdentifier{IOError}\spanPunctuation{:}
    \spanIdentifier{echo} \spanStringLit{"IO error!"}
  \spanKeyword{except}\spanPunctuation{:}
    \spanIdentifier{echo} \spanStringLit{"Unknown exception!"}
    \spanComment{\# reraise the unknown exception:}
    \spanKeyword{raise}
  \spanKeyword{finally}\spanPunctuation{:}
    \spanIdentifier{close}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{)}
\end{rstpre}
The statements after the \texttt{try} are executed unless an exception is raised. Then the appropriate \texttt{except} part is executed.

The empty \texttt{except} part is executed if there is an exception that is not explicitly listed. It is similar to an \texttt{else} part in \texttt{if} statements.

If there is a \texttt{finally} part, it is always executed after the exception handlers.

The exception is \emph{consumed} in an \texttt{except} part. If an exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a \texttt{finally} clause - is not executed (if an exception occurs).

If you need to \emph{access} the actual exception object or message inside an \texttt{except} branch you can use the \href{system.html\#getCurrentException}{getCurrentException()} and \href{system.html\#getCurrentExceptionMsg}{getCurrentExceptionMsg()} procs from the \href{system.html}{system} module. Example:

\begin{rstpre}
\spanKeyword{try}\spanPunctuation{:}
  \spanIdentifier{doSomethingHere}\spanPunctuation{(}\spanPunctuation{)}
\spanKeyword{except}\spanPunctuation{:}
  \spanKeyword{let}
    \spanIdentifier{e} \spanOperator{=} \spanIdentifier{getCurrentException}\spanPunctuation{(}\spanPunctuation{)}
    \spanIdentifier{msg} \spanOperator{=} \spanIdentifier{getCurrentExceptionMsg}\spanPunctuation{(}\spanPunctuation{)}
  \spanIdentifier{echo} \spanStringLit{"Got exception "}\spanPunctuation{,} \spanIdentifier{repr}\spanPunctuation{(}\spanIdentifier{e}\spanPunctuation{)}\spanPunctuation{,} \spanStringLit{" with message "}\spanPunctuation{,} \spanIdentifier{msg}
\end{rstpre}
\rsthB{Annotating procs with raised exceptions}\label{exceptions-annotating-procs-with-raised-exceptions}
Through the use of the optional \texttt{\symbol{123}.raises.\symbol{125}} pragma you can specify that a proc is meant to raise a specific set of exceptions, or none at all. If the \texttt{\symbol{123}.raises.\symbol{125}} pragma is used, the compiler will verify that this is true. For instance, if you specify that a proc raises \texttt{IOError}, and at some point it (or one of the procs it calls) starts raising a new exception the compiler will prevent that proc from compiling. Usage example:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{complexProc}\spanPunctuation{(}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{raises}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{IOError}\spanPunctuation{,} \spanIdentifier{ArithmeticDefect}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanOperator{...}

\spanKeyword{proc} \spanIdentifier{simpleProc}\spanPunctuation{(}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{raises}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanOperator{...}
\end{rstpre}
Once you have code like this in place, if the list of raised exception changes the compiler will stop with an error specifying the line of the proc which stopped validating the pragma and the raised exception not being caught, along with the file and line where the uncaught exception is being raised, which may help you locate the offending code which has changed.

If you want to add the \texttt{\symbol{123}.raises.\symbol{125}} pragma to existing code, the compiler can also help you. You can add the \texttt{\symbol{123}.effects.\symbol{125}} pragma statement to your proc and the compiler will output all inferred effects up to that point (exception tracking is part of Nim's effect system). Another more roundabout way to find out the list of exceptions raised by a proc is to use the Nim \texttt{doc2} command which generates documentation for a whole module and decorates all procs with the list of raised exceptions. You can read more about Nim's \href{manual.html\#effect-system}{effect system and related pragmas in the manual}.

\rsthA{Generics}\label{generics}
Generics are Nim's means to parametrize procs, iterators or types with type parameters\label{type-parameters_1}. Generic parameters are written within square brackets, for example \texttt{Foo\symbol{91}T\symbol{93}}. They are most useful for efficient type safe containers:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{BinaryTree}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanComment{\# BinaryTree is a generic type with}
                              \spanComment{\# generic param \symbol{96}\symbol{96}T\symbol{96}\symbol{96}}
    \spanIdentifier{le}\spanPunctuation{,} \spanIdentifier{ri}\spanPunctuation{:} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}     \spanComment{\# left and right subtrees; may be nil}
    \spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{T}                   \spanComment{\# the data stored in a node}

\spanKeyword{proc} \spanIdentifier{newNode}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=}
  \spanComment{\# constructor for a node}
  \spanIdentifier{new}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{)}
  \spanIdentifier{result}\spanOperator{.}\spanIdentifier{data} \spanOperator{=} \spanIdentifier{data}

\spanKeyword{proc} \spanIdentifier{add}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# insert a node into the tree}
  \spanKeyword{if} \spanIdentifier{root} \spanOperator{==} \spanKeyword{nil}\spanPunctuation{:}
    \spanIdentifier{root} \spanOperator{=} \spanIdentifier{n}
  \spanKeyword{else}\spanPunctuation{:}
    \spanKeyword{var} \spanIdentifier{it} \spanOperator{=} \spanIdentifier{root}
    \spanKeyword{while} \spanIdentifier{it} \spanOperator{!=} \spanKeyword{nil}\spanPunctuation{:}
      \spanComment{\# compare the data items; uses the generic \symbol{96}\symbol{96}cmp\symbol{96}\symbol{96} proc}
      \spanComment{\# that works for any type that has a \symbol{96}\symbol{96}==\symbol{96}\symbol{96} and \symbol{96}\symbol{96}<\symbol{96}\symbol{96} operator}
      \spanKeyword{var} \spanIdentifier{c} \spanOperator{=} \spanIdentifier{cmp}\spanPunctuation{(}\spanIdentifier{it}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{,} \spanIdentifier{n}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{)}
      \spanKeyword{if} \spanIdentifier{c} \spanOperator{<} \spanDecNumber{0}\spanPunctuation{:}
        \spanKeyword{if} \spanIdentifier{it}\spanOperator{.}\spanIdentifier{le} \spanOperator{==} \spanKeyword{nil}\spanPunctuation{:}
          \spanIdentifier{it}\spanOperator{.}\spanIdentifier{le} \spanOperator{=} \spanIdentifier{n}
          \spanKeyword{return}
        \spanIdentifier{it} \spanOperator{=} \spanIdentifier{it}\spanOperator{.}\spanIdentifier{le}
      \spanKeyword{else}\spanPunctuation{:}
        \spanKeyword{if} \spanIdentifier{it}\spanOperator{.}\spanIdentifier{ri} \spanOperator{==} \spanKeyword{nil}\spanPunctuation{:}
          \spanIdentifier{it}\spanOperator{.}\spanIdentifier{ri} \spanOperator{=} \spanIdentifier{n}
          \spanKeyword{return}
        \spanIdentifier{it} \spanOperator{=} \spanIdentifier{it}\spanOperator{.}\spanIdentifier{ri}

\spanKeyword{proc} \spanIdentifier{add}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# convenience proc:}
  \spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{,} \spanIdentifier{newNode}\spanPunctuation{(}\spanIdentifier{data}\spanPunctuation{)}\spanPunctuation{)}

\spanKeyword{iterator} \spanIdentifier{preorder}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{:} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{T} \spanOperator{=}
  \spanComment{\# Preorder traversal of a binary tree.}
  \spanComment{\# Since recursive iterators are not yet implemented,}
  \spanComment{\# this uses an explicit stack (which is more efficient anyway):}
  \spanKeyword{var} \spanIdentifier{stack}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanIdentifier{root}\spanPunctuation{\symbol{93}}
  \spanKeyword{while} \spanIdentifier{stack}\spanOperator{.}\spanIdentifier{len} \spanOperator{>} \spanDecNumber{0}\spanPunctuation{:}
    \spanKeyword{var} \spanIdentifier{n} \spanOperator{=} \spanIdentifier{stack}\spanOperator{.}\spanIdentifier{pop}\spanPunctuation{(}\spanPunctuation{)}
    \spanKeyword{while} \spanIdentifier{n} \spanOperator{!=} \spanKeyword{nil}\spanPunctuation{:}
      \spanKeyword{yield} \spanIdentifier{n}\spanOperator{.}\spanIdentifier{data}
      \spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{stack}\spanPunctuation{,} \spanIdentifier{n}\spanOperator{.}\spanIdentifier{ri}\spanPunctuation{)}  \spanComment{\# push right subtree onto the stack}
      \spanIdentifier{n} \spanOperator{=} \spanIdentifier{n}\spanOperator{.}\spanIdentifier{le}          \spanComment{\# and follow the left pointer}

\spanKeyword{var}
  \spanIdentifier{root}\spanPunctuation{:} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}} \spanComment{\# instantiate a BinaryTree with \symbol{96}\symbol{96}string\symbol{96}\symbol{96}}
\spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{,} \spanIdentifier{newNode}\spanPunctuation{(}\spanStringLit{"hello"}\spanPunctuation{)}\spanPunctuation{)} \spanComment{\# instantiates \symbol{96}\symbol{96}newNode\symbol{96}\symbol{96} and \symbol{96}\symbol{96}add\symbol{96}\symbol{96}}
\spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{,} \spanStringLit{"world"}\spanPunctuation{)}          \spanComment{\# instantiates the second \symbol{96}\symbol{96}add\symbol{96}\symbol{96} proc}
\spanKeyword{for} \spanIdentifier{str} \spanKeyword{in} \spanIdentifier{preorder}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{stdout}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanIdentifier{str}\spanPunctuation{)}
\end{rstpre}
The example shows a generic binary tree. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type. As the example shows, generics work with overloading: the best match of \texttt{add} is used. The built-in \texttt{add} procedure for sequences is not hidden and is used in the \texttt{preorder} iterator.

\rsthA{Templates}\label{templates}
Templates are a simple substitution mechanism that operates on Nim's abstract syntax trees. Templates are processed in the semantic pass of the compiler. They integrate well with the rest of the language and share none of C's preprocessor macros flaws.

To \emph{invoke} a template, call it like a procedure.

Example:

\begin{rstpre}
\spanKeyword{template} \spanPunctuation{\symbol{96}}\spanOperator{!=}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanComment{\# this definition exists in the System module}
  \spanKeyword{not} \spanPunctuation{(}\spanIdentifier{a} \spanOperator{==} \spanIdentifier{b}\spanPunctuation{)}

\spanIdentifier{assert}\spanPunctuation{(}\spanDecNumber{5} \spanOperator{!=} \spanDecNumber{6}\spanPunctuation{)} \spanComment{\# the compiler rewrites that to: assert(not (5 == 6))}
\end{rstpre}
The \texttt{!=}, \texttt{>}, \texttt{>=}, \texttt{in}, \texttt{notin}, \texttt{isnot} operators are in fact templates: this has the benefit that if you overload the \texttt{==} operator, the \texttt{!=} operator is available automatically and does the right thing. (Except for IEEE floating point numbers - NaN breaks basic boolean logic.)

\texttt{a > b} is transformed into \texttt{b < a}. \texttt{a in b} is transformed into \texttt{contains(b, a)}. \texttt{notin} and \texttt{isnot} have the obvious meanings.

Templates are especially useful for lazy evaluation purposes. Consider a simple proc for logging:

\begin{rstpre}
\spanKeyword{const}
  \spanIdentifier{debug} \spanOperator{=} \spanIdentifier{true}

\spanKeyword{proc} \spanIdentifier{log}\spanPunctuation{(}\spanIdentifier{msg}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{inline}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanKeyword{if} \spanIdentifier{debug}\spanPunctuation{:} \spanIdentifier{stdout}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanIdentifier{msg}\spanPunctuation{)}

\spanKeyword{var}
  \spanIdentifier{x} \spanOperator{=} \spanDecNumber{4}
\spanIdentifier{log}\spanPunctuation{(}\spanStringLit{"x has the value: "} \spanOperator{\&} \spanOperator{\$}\spanIdentifier{x}\spanPunctuation{)}
\end{rstpre}
This code has a shortcoming: if \texttt{debug} is set to false someday, the quite expensive \texttt{\$} and \texttt{\&} operations are still performed! (The argument evaluation for procedures is \emph{eager}).

Turning the \texttt{log} proc into a template solves this problem:

\begin{rstpre}
\spanKeyword{const}
  \spanIdentifier{debug} \spanOperator{=} \spanIdentifier{true}

\spanKeyword{template} \spanIdentifier{log}\spanPunctuation{(}\spanIdentifier{msg}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{if} \spanIdentifier{debug}\spanPunctuation{:} \spanIdentifier{stdout}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanIdentifier{msg}\spanPunctuation{)}

\spanKeyword{var}
  \spanIdentifier{x} \spanOperator{=} \spanDecNumber{4}
\spanIdentifier{log}\spanPunctuation{(}\spanStringLit{"x has the value: "} \spanOperator{\&} \spanOperator{\$}\spanIdentifier{x}\spanPunctuation{)}
\end{rstpre}
The parameters' types can be ordinary types or the meta types \texttt{untyped}, \texttt{typed}, or \texttt{type}. \texttt{type} suggests that only a type symbol may be given as an argument, and \texttt{untyped} means symbol lookups and type resolution is not performed before the expression is passed to the template.

If the template has no explicit return type, \texttt{void} is used for consistency with procs and methods.

To pass a block of statements to a template, use \texttt{untyped} for the last parameter:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{withFile}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{,} \spanIdentifier{filename}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{mode}\spanPunctuation{:} \spanIdentifier{FileMode}\spanPunctuation{,}
                  \spanIdentifier{body}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{let} \spanIdentifier{fn} \spanOperator{=} \spanIdentifier{filename}
  \spanKeyword{var} \spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{File}
  \spanKeyword{if} \spanIdentifier{open}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanIdentifier{fn}\spanPunctuation{,} \spanIdentifier{mode}\spanPunctuation{)}\spanPunctuation{:}
    \spanKeyword{try}\spanPunctuation{:}
      \spanIdentifier{body}
    \spanKeyword{finally}\spanPunctuation{:}
      \spanIdentifier{close}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{)}
  \spanKeyword{else}\spanPunctuation{:}
    \spanIdentifier{quit}\spanPunctuation{(}\spanStringLit{"cannot open: "} \spanOperator{\&} \spanIdentifier{fn}\spanPunctuation{)}

\spanIdentifier{withFile}\spanPunctuation{(}\spanIdentifier{txt}\spanPunctuation{,} \spanStringLit{"ttempl3.txt"}\spanPunctuation{,} \spanIdentifier{fmWrite}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{txt}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanStringLit{"line 1"}\spanPunctuation{)}
  \spanIdentifier{txt}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanStringLit{"line 2"}\spanPunctuation{)}
\end{rstpre}
In the example the two \texttt{writeLine} statements are bound to the \texttt{body} parameter. The \texttt{withFile} template contains boilerplate code and helps to avoid a common bug: to forget to close the file. Note how the \texttt{let fn = filename} statement ensures that \texttt{filename} is evaluated only once.

\rsthB{Example: Lifting Procs}\label{templates-examplecolon-lifting-procs}
\begin{rstpre}
\spanKeyword{import} \spanIdentifier{math}

\spanKeyword{template} \spanIdentifier{liftScalarProc}\spanPunctuation{(}\spanIdentifier{fname}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\#\# Lift a proc taking one scalar parameter and returning a}
  \spanComment{\#\# scalar value (eg \symbol{96}\symbol{96}proc sssss\symbol{91}T\symbol{93}(x: T): float\symbol{96}\symbol{96}),}
  \spanComment{\#\# to provide templated procs that can handle a single}
  \spanComment{\#\# parameter of seq\symbol{91}T\symbol{93} or nested seq\symbol{91}seq\symbol{91}\symbol{93}\symbol{93} or the same type}
  \spanComment{\#\#}
  \spanComment{\#\# .. code-block:: Nim}
  \spanComment{\#\#  liftScalarProc(abs)}
  \spanComment{\#\#  \# now abs(\symbol{64}\symbol{91}\symbol{64}\symbol{91}1,-2\symbol{93}, \symbol{64}\symbol{91}-2,-3\symbol{93}\symbol{93}) == \symbol{64}\symbol{91}\symbol{64}\symbol{91}1,2\symbol{93}, \symbol{64}\symbol{91}2,3\symbol{93}\symbol{93}}
  \spanKeyword{proc} \spanIdentifier{fname}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{openarray}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{auto} \spanOperator{=}
    \spanKeyword{var} \spanIdentifier{temp}\spanPunctuation{:} \spanIdentifier{T}
    \spanKeyword{type} \spanIdentifier{outType} \spanOperator{=} \spanIdentifier{typeof}\spanPunctuation{(}\spanIdentifier{fname}\spanPunctuation{(}\spanIdentifier{temp}\spanPunctuation{)}\spanPunctuation{)}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{newSeq}\spanPunctuation{\symbol{91}}\spanIdentifier{outType}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{)}
    \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.<}\spanIdentifier{x}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{:}
      \spanIdentifier{result}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{fname}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanPunctuation{)}

\spanIdentifier{liftScalarProc}\spanPunctuation{(}\spanIdentifier{sqrt}\spanPunctuation{)}   \spanComment{\# make sqrt() work for sequences}
\spanIdentifier{echo} \spanIdentifier{sqrt}\spanPunctuation{(}\spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanFloatNumber{4.0}\spanPunctuation{,} \spanFloatNumber{16.0}\spanPunctuation{,} \spanFloatNumber{25.0}\spanPunctuation{,} \spanFloatNumber{36.0}\spanPunctuation{\symbol{93}}\spanPunctuation{)}   \spanComment{\# => \symbol{64}\symbol{91}2.0, 4.0, 5.0, 6.0\symbol{93}}
\end{rstpre}
\rsthA{Compilation to JavaScript}\label{compilation-to-javascript}
Nim code can be compiled to JavaScript. However in order to write JavaScript-compatible code you should remember the following:

\begin{itemize}\item \texttt{addr} and \texttt{ptr} have slightly different semantic meaning in JavaScript. It is recommended to avoid those if you're not sure how they are translated to JavaScript.
\item \texttt{cast\symbol{91}T\symbol{93}(x)} in JavaScript is translated to \texttt{(x)}, except for casting between signed/unsigned ints, in which case it behaves as static cast in C language.
\item \texttt{cstring} in JavaScript means JavaScript string. It is a good practice to use \texttt{cstring} only when it is semantically appropriate. E.g. don't use \texttt{cstring} as a binary data buffer.
\end{itemize}
\rsthA{Part 3}\label{part-3}
The next part is entirely about metaprogramming via macros: \href{tut3.html}{Part III} 




\end{document}
