% This file was generated by Nim.
% Generated: 2020-08-22 06:37:23 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{Nim Destructors and Move Semantics 1.3.5}
\author{Andreas Rumpf}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

\tableofcontents \newpage
\rsthA{About this document}\label{about-this-document}
This document describes the upcoming Nim runtime which does not use classical GC algorithms anymore but is based on destructors and move semantics. The new runtime's advantages are that Nim programs become oblivious to the involved heap sizes and programs are easier to write to make effective use of multi-core machines. As a nice bonus, files and sockets and the like will not require manual \texttt{close} calls anymore.

This document aims to be a precise specification about how move semantics and destructors work in Nim.

\rsthA{Motivating example}\label{motivating-example}
With the language mechanisms described here a custom seq could be written as:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{myseq}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{len}\spanPunctuation{,} \spanIdentifier{cap}\spanPunctuation{:} \spanIdentifier{int}
    \spanIdentifier{data}\spanPunctuation{:} \spanKeyword{ptr} \spanIdentifier{UncheckedArray}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{myseq}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{if} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{data} \spanOperator{!=} \spanKeyword{nil}\spanPunctuation{:}
    \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.<}\spanIdentifier{x}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{:} \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
    \spanIdentifier{dealloc}\spanPunctuation{(}\spanIdentifier{x}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{)}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{=}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{myseq}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{;} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{myseq}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# do nothing for self-assignments:}
  \spanKeyword{if} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{data} \spanOperator{==} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{:} \spanKeyword{return}
  \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}
  \spanIdentifier{wasMoved}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}
  \spanIdentifier{a}\spanOperator{.}\spanIdentifier{len} \spanOperator{=} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{len}
  \spanIdentifier{a}\spanOperator{.}\spanIdentifier{cap} \spanOperator{=} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{cap}
  \spanKeyword{if} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{data} \spanOperator{!=} \spanKeyword{nil}\spanPunctuation{:}
    \spanIdentifier{a}\spanOperator{.}\spanIdentifier{data} \spanOperator{=} \spanKeyword{cast}\spanPunctuation{\symbol{91}}\spanIdentifier{typeof}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{)}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{alloc}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{cap} \spanOperator{*} \spanIdentifier{sizeof}\spanPunctuation{(}\spanIdentifier{T}\spanPunctuation{)}\spanPunctuation{)}\spanPunctuation{)}
    \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.<}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{:}
      \spanIdentifier{a}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{sink}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{myseq}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{;} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{myseq}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# move assignment, optional.}
  \spanComment{\# Compiler is using \symbol{96}=destroy\symbol{96} and \symbol{96}copyMem\symbol{96} when not provided}
  \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}
  \spanIdentifier{wasMoved}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}
  \spanIdentifier{a}\spanOperator{.}\spanIdentifier{len} \spanOperator{=} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{len}
  \spanIdentifier{a}\spanOperator{.}\spanIdentifier{cap} \spanOperator{=} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{cap}
  \spanIdentifier{a}\spanOperator{.}\spanIdentifier{data} \spanOperator{=} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{data}

\spanKeyword{proc} \spanIdentifier{add}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{myseq}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{;} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{sink} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{if} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{len} \spanOperator{>=} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{cap}\spanPunctuation{:} \spanIdentifier{resize}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}
  \spanIdentifier{x}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{\symbol{91}}\spanIdentifier{x}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{y}
  \spanIdentifier{inc} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{len}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{myseq}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{;} \spanIdentifier{i}\spanPunctuation{:} \spanIdentifier{Natural}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{lent} \spanIdentifier{T} \spanOperator{=}
  \spanIdentifier{assert} \spanIdentifier{i} \spanOperator{<} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{len}
  \spanIdentifier{x}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanOperator{=}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{myseq}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{;} \spanIdentifier{i}\spanPunctuation{:} \spanIdentifier{Natural}\spanPunctuation{;} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{sink} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{assert} \spanIdentifier{i} \spanOperator{<} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{len}
  \spanIdentifier{x}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{y}

\spanKeyword{proc} \spanIdentifier{createSeq}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{elems}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{myseq}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=}
  \spanIdentifier{result}\spanOperator{.}\spanIdentifier{cap} \spanOperator{=} \spanIdentifier{elems}\spanOperator{.}\spanIdentifier{len}
  \spanIdentifier{result}\spanOperator{.}\spanIdentifier{len} \spanOperator{=} \spanIdentifier{elems}\spanOperator{.}\spanIdentifier{len}
  \spanIdentifier{result}\spanOperator{.}\spanIdentifier{data} \spanOperator{=} \spanKeyword{cast}\spanPunctuation{\symbol{91}}\spanIdentifier{typeof}\spanPunctuation{(}\spanIdentifier{result}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{)}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{alloc}\spanPunctuation{(}\spanIdentifier{result}\spanOperator{.}\spanIdentifier{cap} \spanOperator{*} \spanIdentifier{sizeof}\spanPunctuation{(}\spanIdentifier{T}\spanPunctuation{)}\spanPunctuation{)}\spanPunctuation{)}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.<}\spanIdentifier{result}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{:} \spanIdentifier{result}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{elems}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanIdentifier{len}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{myseq}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{inline}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{len}
\end{rstpre}
\rsthA{Lifetime-tracking hooks}\label{lifetimeminustracking-hooks}
The memory management for Nim's standard \texttt{string} and \texttt{seq} types as well as other standard collections is performed via so called "Lifetime-tracking hooks" or "type-bound operators". There are 3 different hooks for each (generic or concrete) object type \texttt{T} (\texttt{T} can also be a \texttt{distinct} type) that are called implicitly by the compiler.

(Note: The word "hook" here does not imply any kind of dynamic binding or runtime indirections, the implicit calls are statically bound and potentially inlined.)

\rsthB{\texttt{=destroy} hook}\label{lifetimeminustracking-hooks-eqdestroy-hook}
A \texttt{=destroy} hook frees the object's associated memory and releases other associated resources. Variables are destroyed via this hook when they go out of scope or when the routine they were declared in is about to return.

The prototype of this hook for a type \texttt{T} needs to be:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{T}\spanPunctuation{)}
\end{rstpre}
The general pattern in \texttt{=destroy} looks like:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# first check if 'x' was moved to somewhere else:}
  \spanKeyword{if} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{field} \spanOperator{!=} \spanKeyword{nil}\spanPunctuation{:}
    \spanIdentifier{freeResource}\spanPunctuation{(}\spanIdentifier{x}\spanOperator{.}\spanIdentifier{field}\spanPunctuation{)}
\end{rstpre}
\rsthB{\texttt{=sink} hook}\label{lifetimeminustracking-hooks-eqsink-hook}
A \texttt{=sink} hook moves an object around, the resources are stolen from the source and passed to the destination. It is ensured that source's destructor does not free the resources afterwards by setting the object to its default value (the value the object's state started in). Setting an object \texttt{x} back to its default value is written as \texttt{wasMoved(x)}. When not provided the compiler is using a combination of \texttt{=destroy} and \texttt{copyMem} instead. This is efficient hence users rarely need to implement their own \texttt{=sink} operator, it is enough to provide \texttt{=destroy} and \texttt{=}, compiler will take care about the rest.

The prototype of this hook for a type \texttt{T} needs to be:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{sink}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{dest}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{T}\spanPunctuation{;} \spanIdentifier{source}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)}
\end{rstpre}
The general pattern in \texttt{=sink} looks like:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{sink}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{dest}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{T}\spanPunctuation{;} \spanIdentifier{source}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{dest}\spanPunctuation{)}
  \spanIdentifier{wasMoved}\spanPunctuation{(}\spanIdentifier{dest}\spanPunctuation{)}
  \spanIdentifier{dest}\spanOperator{.}\spanIdentifier{field} \spanOperator{=} \spanIdentifier{source}\spanOperator{.}\spanIdentifier{field}
\end{rstpre}
\textbf{Note}: \texttt{=sink} does not need to check for self-assignments. How self-assignments are handled is explained later in this document.

\rsthB{\texttt{=} (copy) hook}\label{lifetimeminustracking-hooks-eq-copy-hook}
The ordinary assignment in Nim conceptually copies the values. The \texttt{=} hook is called for assignments that couldn't be transformed into \texttt{=sink} operations.

The prototype of this hook for a type \texttt{T} needs to be:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{=}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{dest}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{T}\spanPunctuation{;} \spanIdentifier{source}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)}
\end{rstpre}
The general pattern in \texttt{=} looks like:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{=}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{dest}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{T}\spanPunctuation{;} \spanIdentifier{source}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# protect against self-assignments:}
  \spanKeyword{if} \spanIdentifier{dest}\spanOperator{.}\spanIdentifier{field} \spanOperator{!=} \spanIdentifier{source}\spanOperator{.}\spanIdentifier{field}\spanPunctuation{:}
    \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{dest}\spanPunctuation{)}
    \spanIdentifier{wasMoved}\spanPunctuation{(}\spanIdentifier{dest}\spanPunctuation{)}
    \spanIdentifier{dest}\spanOperator{.}\spanIdentifier{field} \spanOperator{=} \spanIdentifier{duplicateResource}\spanPunctuation{(}\spanIdentifier{source}\spanOperator{.}\spanIdentifier{field}\spanPunctuation{)}
\end{rstpre}
The \texttt{=} proc can be marked with the \texttt{\symbol{123}.error.\symbol{125}} pragma. Then any assignment that otherwise would lead to a copy is prevented at compile-time.

\rsthA{Move semantics}\label{move-semantics}
A "move" can be regarded as an optimized copy operation. If the source of the copy operation is not used afterwards, the copy can be replaced by a move. This document uses the notation \texttt{lastReadOf(x)} to describe that \texttt{x} is not used afterwards. This property is computed by a static control flow analysis but can also be enforced by using \texttt{system.move} explicitly.

\rsthA{Swap}\label{swap}
The need to check for self-assignments and also the need to destroy previous objects inside \texttt{=} and \texttt{=sink} is a strong indicator to treat \texttt{system.swap} as a builtin primitive of its own that simply swaps every field in the involved objects via \texttt{copyMem} or a comparable mechanism. In other words, \texttt{swap(a, b)} is \textbf{not} implemented as \texttt{let tmp = move(b); b = move(a); a = move(tmp)}.

This has further consequences:

\begin{itemize}\item Objects that contain pointers that point to the same object are not supported by Nim's model. Otherwise swapped objects would end up in an inconsistent state.
\item Seqs can use \texttt{realloc} in the implementation.
\end{itemize}
\rsthA{Sink parameters}\label{sink-parameters}
To move a variable into a collection usually \texttt{sink} parameters are involved. A location that is passed to a \texttt{sink} parameter should not be used afterwards. This is ensured by a static analysis over a control flow graph. If it cannot be proven to be the last usage of the location, a copy is done instead and this copy is then passed to the sink parameter.

A sink parameter \emph{may} be consumed once in the proc's body but doesn't have to be consumed at all. The reason for this is that signatures like \texttt{proc put(t: var Table; k: sink Key, v: sink Value)} should be possible without any further overloads and \texttt{put} might not take ownership of \texttt{k} if \texttt{k} already exists in the table. Sink parameters enable an affine type system, not a linear type system.

The employed static analysis is limited and only concerned with local variables; however object and tuple fields are treated as separate entities:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{consume}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{sink} \spanIdentifier{Obj}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard} \spanStringLit{"no implementation"}

\spanKeyword{proc} \spanIdentifier{main} \spanOperator{=}
  \spanKeyword{let} \spanIdentifier{tup} \spanOperator{=} \spanPunctuation{(}\spanIdentifier{Obj}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{Obj}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{)}
  \spanIdentifier{consume} \spanIdentifier{tup}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}
  \spanComment{\# ok, only tup\symbol{91}0\symbol{93} was consumed, tup\symbol{91}1\symbol{93} is still alive:}
  \spanIdentifier{echo} \spanIdentifier{tup}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}}
\end{rstpre}
Sometimes it is required to explicitly \texttt{move} a value into its final position:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{main} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{dest}\spanPunctuation{,} \spanIdentifier{src}\spanPunctuation{:} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanDecNumber{10}\spanPunctuation{,} \spanIdentifier{string}\spanPunctuation{\symbol{93}}
  \spanComment{\# ...}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanIdentifier{high}\spanPunctuation{(}\spanIdentifier{dest}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{dest}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{move}\spanPunctuation{(}\spanIdentifier{src}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
An implementation is allowed, but not required to implement even more move optimizations (and the current implementation does not).

\rsthA{Sink parameter inference}\label{sink-parameter-inference}
The current implementation can do a limited form of sink parameter inference. But it has to be enabled via \texttt{--sinkInference:on}, either on the command line or via a \texttt{push} pragma.

To enable it for a section of code, one can use \texttt{\symbol{123}.push sinkInference: on.\symbol{125}}...\symbol{96}\symbol{123}.pop.\symbol{125}\symbol{96}.

The .nosinks\label{dotnosinks_1} pragma can be used to disable this inference for a single routine:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{addX}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{;} \spanIdentifier{child}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{nosinks}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{x}\spanOperator{.}\spanIdentifier{s}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{child}
\end{rstpre}
The details of the inference algorithm are currently undocumented.

\rsthA{Rewrite rules}\label{rewrite-rules}
\textbf{Note}: There are two different allowed implementation strategies:

\begin{enumerate}\item The produced \texttt{finally} section can be a single section that is wrapped around the complete routine body.
\item The produced \texttt{finally} section is wrapped around the enclosing scope.
\end{enumerate}
The current implementation follows strategy (2). This means that resources are destroyed at the scope exit.

\begin{rstpre}

var x: T; stmts
---------------             (destroy-var)
var x: T; try stmts
finally: \symbol{96}=destroy\symbol{96}(x)


g(f(...))
------------------------    (nested-function-call)
g(let tmp;
bitwiseCopy tmp, f(...);
tmp)
finally: \symbol{96}=destroy\symbol{96}(tmp)


x = f(...)
------------------------    (function-sink)
\symbol{96}=sink\symbol{96}(x, f(...))


x = lastReadOf z
------------------          (move-optimization)
\symbol{96}=sink\symbol{96}(x, z)
wasMoved(z)


v = v
------------------   (self-assignment-removal)
discard "nop"


x = y
------------------          (copy)
\symbol{96}=\symbol{96}(x, y)


f\_sink(g())
-----------------------     (call-to-sink)
f\_sink(g())


f\_sink(notLastReadOf y)
--------------------------     (copy-to-sink)
(let tmp; \symbol{96}=\symbol{96}(tmp, y);
f\_sink(tmp))


f\_sink(lastReadOf y)
-----------------------     (move-to-sink)
f\_sink(y)
wasMoved(y)
\end{rstpre}
\rsthA{Object and array construction}\label{object-and-array-construction}
Object and array construction is treated as a function call where the function has \texttt{sink} parameters.

\rsthA{Destructor removal}\label{destructor-removal}
\texttt{wasMoved(x);} followed by a \texttt{=destroy(x)} operation cancel each other out. An implementation is encouraged to exploit this in order to improve efficiency and code sizes. The current implementation does perform this optimization.

\rsthA{Self assignments}\label{self-assignments}
\texttt{=sink} in combination with \texttt{wasMoved} can handle self-assignments but it's subtle.

The simple case of \texttt{x = x} cannot be turned into \texttt{=sink(x, x); wasMoved(x)} because that would lose \texttt{x}'s value. The solution is that simple self-assignments are simply transformed into an empty statement that does nothing.

The complex case looks like a variant of \texttt{x = f(x)}, we consider \texttt{x = select(rand() < 0.5, x, y)} here:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{select}\spanPunctuation{(}\spanIdentifier{cond}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{;} \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{sink} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanKeyword{if} \spanIdentifier{cond}\spanPunctuation{:}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{a} \spanComment{\# moves a into result}
  \spanKeyword{else}\spanPunctuation{:}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanComment{\# moves b into result}

\spanKeyword{proc} \spanIdentifier{main} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanStringLit{"abc"}
  \spanKeyword{var} \spanIdentifier{y} \spanOperator{=} \spanStringLit{"xyz"}
  \spanComment{\# possible self-assignment:}
  \spanIdentifier{x} \spanOperator{=} \spanIdentifier{select}\spanPunctuation{(}\spanIdentifier{true}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{)}
\end{rstpre}
Is transformed into:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{select}\spanPunctuation{(}\spanIdentifier{cond}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{;} \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{sink} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanKeyword{try}\spanPunctuation{:}
    \spanKeyword{if} \spanIdentifier{cond}\spanPunctuation{:}
      \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{sink}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{)}
      \spanIdentifier{wasMoved}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}
    \spanKeyword{else}\spanPunctuation{:}
      \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{sink}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)}
      \spanIdentifier{wasMoved}\spanPunctuation{(}\spanIdentifier{b}\spanPunctuation{)}
  \spanKeyword{finally}\spanPunctuation{:}
    \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{b}\spanPunctuation{)}
    \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{main} \spanOperator{=}
  \spanKeyword{var}
    \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{string}
    \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{string}
  \spanKeyword{try}\spanPunctuation{:}
    \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{sink}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanStringLit{"abc"}\spanPunctuation{)}
    \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{sink}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{y}\spanPunctuation{,} \spanStringLit{"xyz"}\spanPunctuation{)}
    \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{sink}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{select}\spanPunctuation{(}\spanIdentifier{true}\spanPunctuation{,}
      \spanKeyword{let} \spanIdentifier{blitTmp} \spanOperator{=} \spanIdentifier{x}
      \spanIdentifier{wasMoved}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}
      \spanIdentifier{blitTmp}\spanPunctuation{,}
      \spanKeyword{let} \spanIdentifier{blitTmp} \spanOperator{=} \spanIdentifier{y}
      \spanIdentifier{wasMoved}\spanPunctuation{(}\spanIdentifier{y}\spanPunctuation{)}
      \spanIdentifier{blitTmp}\spanPunctuation{)}\spanPunctuation{)}
    \spanIdentifier{echo} \spanPunctuation{\symbol{91}}\spanIdentifier{x}\spanPunctuation{\symbol{93}}
  \spanKeyword{finally}\spanPunctuation{:}
    \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{y}\spanPunctuation{)}
    \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}
\end{rstpre}
As can be manually verified, this transformation is correct for self-assignments.

\rsthA{Lent type}\label{lent-type}
\texttt{proc p(x: sink T)} means that the proc \texttt{p} takes ownership of \texttt{x}. To eliminate even more creation/copy <-> destruction pairs, a proc's return type can be annotated as \texttt{lent T}. This is useful for "getter" accessors that seek to allow an immutable view into a container.

The \texttt{sink} and \texttt{lent} annotations allow us to remove most (if not all) superfluous copies and destructions.

\texttt{lent T} is like \texttt{var T} a hidden pointer. It is proven by the compiler that the pointer does not outlive its origin. No destructor call is injected for expressions of type \texttt{lent T} or of type \texttt{var T}.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Tree} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{kids}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{Tree}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanIdentifier{construct}\spanPunctuation{(}\spanIdentifier{kids}\spanPunctuation{:} \spanIdentifier{sink} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{Tree}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Tree} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{Tree}\spanPunctuation{(}\spanIdentifier{kids}\spanPunctuation{:} \spanIdentifier{kids}\spanPunctuation{)}
  \spanComment{\# converted into:}
  \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{sink}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{result}\spanOperator{.}\spanIdentifier{kids}\spanPunctuation{,} \spanIdentifier{kids}\spanPunctuation{)}\spanPunctuation{;} \spanIdentifier{wasMoved}\spanPunctuation{(}\spanIdentifier{kids}\spanPunctuation{)}
  \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{kids}\spanPunctuation{)}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{Tree}\spanPunctuation{;} \spanIdentifier{i}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{lent} \spanIdentifier{Tree} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{kids}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}
  \spanComment{\# borrows from 'x', this is transformed into:}
  \spanIdentifier{result} \spanOperator{=} \spanKeyword{addr} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{kids}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}
  \spanComment{\# This means 'lent' is like 'var T' a hidden pointer.}
  \spanComment{\# Unlike 'var' this hidden pointer cannot be used to mutate the object.}

\spanKeyword{iterator} \spanIdentifier{children}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{t}\spanPunctuation{:} \spanIdentifier{Tree}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{lent} \spanIdentifier{Tree} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{x} \spanKeyword{in} \spanIdentifier{t}\spanOperator{.}\spanIdentifier{kids}\spanPunctuation{:} \spanKeyword{yield} \spanIdentifier{x}

\spanKeyword{proc} \spanIdentifier{main} \spanOperator{=}
  \spanComment{\# everything turned into moves:}
  \spanKeyword{let} \spanIdentifier{t} \spanOperator{=} \spanIdentifier{construct}\spanPunctuation{(}\spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanIdentifier{construct}\spanPunctuation{(}\spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{construct}\spanPunctuation{(}\spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
  \spanIdentifier{echo} \spanIdentifier{t}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}} \spanComment{\# accessor does not copy the element!}
\end{rstpre}
\rsthA{The .cursor annotation}\label{the-dotcursor-annotation}
Under the \texttt{--gc:arc|orc} modes Nim's \texttt{ref} type is implemented via the same runtime "hooks" and thus via reference counting. This means that cyclic structures cannot be freed immediately (\texttt{--gc:orc} ships with a cycle collector). With the \texttt{.cursor} annotation one can break up cycles declaratively:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Node} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object}
    \spanIdentifier{left}\spanPunctuation{:} \spanIdentifier{Node} \spanComment{\# owning ref}
    \spanIdentifier{right} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{cursor}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{Node} \spanComment{\# non-owning ref}
\end{rstpre}
But please notice that this is not C++'s weak\_ptr, it means the right field is not involved in the reference counting, it is a raw pointer without runtime checks.

Automatic reference counting also has the disadvantage that it introduces overhead when iterating over linked structures. The \texttt{.cursor} annotation can also be used to avoid this overhead:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{it} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{cursor}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanIdentifier{listRoot}
\spanKeyword{while} \spanIdentifier{it} \spanOperator{!=} \spanKeyword{nil}\spanPunctuation{:}
  \spanIdentifier{use}\spanPunctuation{(}\spanIdentifier{it}\spanPunctuation{)}
  \spanIdentifier{it} \spanOperator{=} \spanIdentifier{it}\spanOperator{.}\spanIdentifier{next}
\end{rstpre}
In fact, \texttt{.cursor} more generally prevents object construction/destruction pairs and so can also be useful in other contexts. The alternative solution would be to use raw pointers (\texttt{ptr}) instead which is more cumbersome and also more dangerous for Nim's evolution: Later on the compiler can try to prove \texttt{.cursor} annotations to be safe, but for \texttt{ptr} the compiler has to remain silent about possible problems.

\rsthA{Cursor inference / copy elision}\label{cursor-inference-slash-copy-elision}
The current implementation also performs \texttt{.cursor} inference. Cursor inference is a form of copy elision.

To see how and when we can do that, think about this question: In \texttt{dest = src} when do we really have to \emph{materialize} the full copy? - Only if \texttt{dest} or \texttt{src} are mutated afterwards. If \texttt{dest} is a local variable that is simple to analyse. And if \texttt{src} is a location derived from a formal parameter, we also know it is not mutated! In other words, we do a compile-time copy-on-write analysis.

This means that "borrowed" views can be written naturally and without explicit pointer indirections:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{main}\spanPunctuation{(}\spanIdentifier{tab}\spanPunctuation{:} \spanIdentifier{Table}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{string}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{let} \spanIdentifier{v} \spanOperator{=} \spanIdentifier{tab}\spanPunctuation{\symbol{91}}\spanStringLit{"key"}\spanPunctuation{\symbol{93}} \spanComment{\# inferred as .cursor because 'tab' is not mutated.}
  \spanComment{\# no copy into 'v', no destruction of 'v'.}
  \spanIdentifier{use}\spanPunctuation{(}\spanIdentifier{v}\spanPunctuation{)}
  \spanIdentifier{useItAgain}\spanPunctuation{(}\spanIdentifier{v}\spanPunctuation{)}
\end{rstpre}
\rsthA{Hook lifting}\label{hook-lifting}
The hooks of a tuple type \texttt{(A, B, ...)} are generated by lifting the hooks of the involved types \texttt{A}, \texttt{B}, ... to the tuple type. In other words, a copy \texttt{x = y} is implemented as \texttt{x\symbol{91}0\symbol{93} = y\symbol{91}0\symbol{93}; x\symbol{91}1\symbol{93} = y\symbol{91}1\symbol{93}; ...}, likewise for \texttt{=sink} and \texttt{=destroy}.

Other value-based compound types like \texttt{object} and \texttt{array} are handled correspondingly. For \texttt{object} however, the compiler generated hooks can be overridden. This can also be important to use an alternative traversal of the involved datastructure that is more efficient or in order to avoid deep recursions.

\rsthA{Hook generation}\label{hook-generation}
The ability to override a hook leads to a phase ordering problem:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Foo}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{object}

\spanKeyword{proc} \spanIdentifier{main} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{Foo}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}
  \spanComment{\# error: destructor for 'f' called here before}
  \spanComment{\# it was seen in this module.}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{Foo}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{discard}
\end{rstpre}
The solution is to define \texttt{proc \symbol{96}=destroy\symbol{96}\symbol{91}T\symbol{93}(f: var Foo\symbol{91}T\symbol{93})} before it is used. The compiler generates implicit hooks for all types in \emph{strategic places} so that an explicitly provided hook that comes too "late" can be detected reliably. These \emph{strategic places} have been derived from the rewrite rules and are as follows:

\begin{itemize}\item In the construct \texttt{let/var x = ...} (var/let binding) hooks are generated for \texttt{typeof(x)}.
\item In \texttt{x = ...} (assignment) hooks are generated for \texttt{typeof(x)}.
\item In \texttt{f(...)} (function call) hooks are generated for \texttt{typeof(f(...))}.
\item For every sink parameter \texttt{x: sink T} the hooks are generated for \texttt{typeof(x)}.
\end{itemize}
\rsthA{nodestroy pragma}\label{nodestroy-pragma}
The experimental nodestroy\label{nodestroy_1} pragma inhibits hook injections. This can be used to specialize the object traversal in order to avoid deep recursions:

\begin{rstpre}
\spanKeyword{type} \spanIdentifier{Node} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object}
  \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int32}
  \spanIdentifier{left}\spanPunctuation{,} \spanIdentifier{right}\spanPunctuation{:} \spanIdentifier{Node}

\spanKeyword{type} \spanIdentifier{Tree} \spanOperator{=} \spanKeyword{object}
  \spanIdentifier{root}\spanPunctuation{:} \spanIdentifier{Node}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{t}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{Tree}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{nodestroy}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanComment{\# use an explicit stack so that we do not get stack overflows:}
  \spanKeyword{var} \spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{Node}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanIdentifier{t}\spanOperator{.}\spanIdentifier{root}\spanPunctuation{\symbol{93}}
  \spanKeyword{while} \spanIdentifier{s}\spanOperator{.}\spanIdentifier{len} \spanOperator{>} \spanDecNumber{0}\spanPunctuation{:}
    \spanKeyword{let} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{s}\spanOperator{.}\spanIdentifier{pop}
    \spanKeyword{if} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{left} \spanOperator{!=} \spanKeyword{nil}\spanPunctuation{:} \spanIdentifier{s}\spanOperator{.}\spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{x}\spanOperator{.}\spanIdentifier{left}\spanPunctuation{)}
    \spanKeyword{if} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{right} \spanOperator{!=} \spanKeyword{nil}\spanPunctuation{:} \spanIdentifier{s}\spanOperator{.}\spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{x}\spanOperator{.}\spanIdentifier{right}\spanPunctuation{)}
    \spanComment{\# free the memory explicit:}
    \spanIdentifier{dispose}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}
  \spanComment{\# notice how even the destructor for 's' is not called implicitly}
  \spanComment{\# anymore thanks to .nodestroy, so we have to call it on our own:}
  \spanPunctuation{\symbol{96}}\spanOperator{=}\spanIdentifier{destroy}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{)}
\end{rstpre}
As can be seen from the example, this solution is hardly sufficient and should eventually be replaced by a better solution. 




\end{document}
