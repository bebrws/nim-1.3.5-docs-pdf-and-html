% This file was generated by Nim.
% Generated: 2020-08-22 06:37:32 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{Nim Manual 1.3.5}
\author{Andreas Rumpf, Zahary Karadjov}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

\tableofcontents \newpage
\begin{quote}"Complexity" seems to be a lot like "energy": you can transfer it from the end user to one/some of the other players, but the total amount seems to remain pretty much constant for a given task. -- Ran\end{quote}
\rsthA{About this document}\label{about-this-document}
\textbf{Note}: This document is a draft! Several of Nim's features may need more precise wording. This manual is constantly evolving into a proper specification.

\textbf{Note}: The experimental features of Nim are covered \href{manual\_experimental.html}{here}.

\textbf{Note}: Assignments, moves and destruction are specified in the \href{destructors.html}{destructors} document.

This document describes the lexis, the syntax, and the semantics of the Nim language.

To learn how to compile Nim programs and generate documentation see \href{nimc.html}{Compiler User Guide} and \href{docgen.html}{DocGen Tools Guide}.

The language constructs are explained using an extended BNF, in which \texttt{(a)*} means 0 or more \texttt{a}'s, \texttt{a+} means 1 or more \texttt{a}'s, and \texttt{(a)?} means an optional \emph{a}. Parentheses may be used to group elements.

\texttt{\&} is the lookahead operator; \texttt{\&a} means that an \texttt{a} is expected but not consumed. It will be consumed in the following rule.

The \texttt{|}, \texttt{/} symbols are used to mark alternatives and have the lowest precedence. \texttt{/} is the ordered choice that requires the parser to try the alternatives in the given order. \texttt{/} is often used to ensure the grammar is not ambiguous.

Non-terminals start with a lowercase letter, abstract terminal symbols are in UPPERCASE. Verbatim terminal symbols (including keywords) are quoted with \texttt{'}. An example:\begin{rstpre}

ifStmt = 'if' expr ':' stmts ('elif' expr ':' stmts)* ('else' stmts)?
\end{rstpre}


The binary \texttt{\symbol{94}*} operator is used as a shorthand for 0 or more occurrences separated by its second argument; likewise \texttt{\symbol{94}+} means 1 or more occurrences: \texttt{a \symbol{94}+ b} is short for \texttt{a (b a)*} and \texttt{a \symbol{94}* b} is short for \texttt{(a (b a)*)?}. Example:\begin{rstpre}

arrayConstructor = '\symbol{91}' expr \symbol{94}* ',' '\symbol{93}'
\end{rstpre}


Other parts of Nim, like scoping rules or runtime semantics, are described informally.

\rsthA{Definitions}\label{definitions}
Nim code specifies a computation that acts on a memory consisting of components called locations\label{locations_1}. A variable is basically a name for a location. Each variable and location is of a certain type\label{type_1}. The variable's type is called static type\label{static-type_1}, the location's type is called dynamic type\label{dynamic-type_1}. If the static type is not the same as the dynamic type, it is a super-type or subtype of the dynamic type.

An identifier\label{identifier_1} is a symbol declared as a name for a variable, type, procedure, etc. The region of the program over which a declaration applies is called the scope\label{scope_1} of the declaration. Scopes can be nested. The meaning of an identifier is determined by the smallest enclosing scope in which the identifier is declared unless overloading resolution rules suggest otherwise.

An expression specifies a computation that produces a value or location. Expressions that produce locations are called l-values\label{lminusvalues_1}. An l-value can denote either a location or the value the location contains, depending on the context.

A Nim program\label{program_1} consists of one or more text source files\label{source-files_1} containing Nim code. It is processed by a Nim compiler\label{compiler_1} into an executable\label{executable_1}. The nature of this executable depends on the compiler implementation; it may, for example, be a native binary or JavaScript source code.

In a typical Nim program, most of the code is compiled into the executable. However, some of the code may be executed at compile time\label{compile-time_1}. This can include constant expressions, macro definitions, and Nim procedures used by macro definitions. Most of the Nim language is supported at compile time, but there are some restrictions -- see \href{\#restrictions-on-compileminustime-execution}{Restrictions on Compile-Time Execution} for details. We use the term runtime\label{runtime_1} to cover both compile-time execution and code execution in the executable.

The compiler parses Nim source code into an internal data structure called the abstract syntax tree\label{abstract-syntax-tree_1} (AST\label{ast_1}). Then, before executing the code or compiling it into the executable, it transforms the AST through semantic analysis\label{semantic-analysis_1}. This adds semantic information such as expression types, identifier meanings, and in some cases expression values. An error detected during semantic analysis is called a static error\label{static-error_1}. Errors described in this manual are static errors when not otherwise specified.

A panic\label{panic_1} is an error that the implementation detects and reports at runtime. The method for reporting such errors is via \emph{raising exceptions} or \emph{dying with a fatal error}. However, the implementation provides a means to disable these runtime checks\label{runtime-checks_1}. See the section pragmas\ref{pragmas} for details.

Whether a panic results in an exception or in a fatal error is implementation specific. Thus the following program is invalid; even though the code purports to catch the \texttt{IndexDefect} from an out-of-bounds array access, the compiler may instead choose to allow the program to die with a fatal error.

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{1}\spanPunctuation{,} \spanIdentifier{char}\spanPunctuation{\symbol{93}}
\spanKeyword{let} \spanIdentifier{i} \spanOperator{=} \spanDecNumber{5}
\spanKeyword{try}\spanPunctuation{:}
  \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanCharLit{'N'}
\spanKeyword{except} \spanIdentifier{IndexDefect}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"invalid index"}
\end{rstpre}
The current implementation allows to switch between these different behaviors via \texttt{--panics:on|off}. When panics are turned on, the program dies on a panic, if they are turned off the runtime errors are turned into exceptions. The benefit of \texttt{--panics:on} is that it produces smaller binary code and the compiler has more freedom to optimize the code.

An unchecked runtime error\label{unchecked-runtime-error_1} is an error that is not guaranteed to be detected, and can cause the subsequent behavior of the computation to be arbitrary. Unchecked runtime errors cannot occur if only safe\label{safe_1} language features are used and if no runtime checks are disabled.

A constant expression\label{constant-expression_1} is an expression whose value can be computed during semantic analysis of the code in which it appears. It is never an l-value and never has side effects. Constant expressions are not limited to the capabilities of semantic analysis, such as constant folding; they can use all Nim language features that are supported for compile-time execution. Since constant expressions can be used as an input to semantic analysis (such as for defining array bounds), this flexibility requires the compiler to interleave semantic analysis and compile-time code execution.

It is mostly accurate to picture semantic analysis proceeding top to bottom and left to right in the source code, with compile-time code execution interleaved when necessary to compute values that are required for subsequent semantic analysis. We will see much later in this document that macro invocation not only requires this interleaving, but also creates a situation where semantic analysis does not entirely proceed top to bottom and left to right.

\rsthA{Lexical Analysis}\label{lexical-analysis}
\rsthB{Encoding}\label{lexical-analysis-encoding}
All Nim source files are in the UTF-8 encoding (or its ASCII subset). Other encodings are not supported. Any of the standard platform line termination sequences can be used - the Unix form using ASCII LF (linefeed), the Windows form using the ASCII sequence CR LF (return followed by linefeed), or the old Macintosh form using the ASCII CR (return) character. All of these forms can be used equally, regardless of platform.

\rsthB{Indentation}\label{lexical-analysis-indentation}
Nim's standard grammar describes an indentation sensitive\label{indentation-sensitive_1} language. This means that all the control structures are recognized by indentation. Indentation consists only of spaces; tabulators are not allowed.

The indentation handling is implemented as follows: The lexer annotates the following token with the preceding number of spaces; indentation is not a separate token. This trick allows parsing of Nim with only 1 token of lookahead.

The parser uses a stack of indentation levels: the stack consists of integers counting the spaces. The indentation information is queried at strategic places in the parser but ignored otherwise: The pseudo terminal \texttt{IND\symbol{123}>\symbol{125}} denotes an indentation that consists of more spaces than the entry at the top of the stack; \texttt{IND\symbol{123}=\symbol{125}} an indentation that has the same number of spaces. \texttt{DED} is another pseudo terminal that describes the \emph{action} of popping a value from the stack, \texttt{IND\symbol{123}>\symbol{125}} then implies to push onto the stack.

With this notation we can now easily define the core of the grammar: A block of statements (simplified example):\begin{rstpre}

ifStmt = 'if' expr ':' stmt
         (IND\symbol{123}=\symbol{125} 'elif' expr ':' stmt)*
         (IND\symbol{123}=\symbol{125} 'else' ':' stmt)?

simpleStmt = ifStmt / ...

stmt = IND\symbol{123}>\symbol{125} stmt \symbol{94}+ IND\symbol{123}=\symbol{125} DED  \# list of statements
     / simpleStmt                 \# or a simple statement
\end{rstpre}


\rsthB{Comments}\label{lexical-analysis-comments}
Comments start anywhere outside a string or character literal with the hash character \texttt{\#}. Comments consist of a concatenation of comment pieces\label{comment-pieces_1}. A comment piece starts with \texttt{\#} and runs until the end of the line. The end of line characters belong to the piece. If the next line only consists of a comment piece with no other tokens between it and the preceding one, it does not start a new comment:

\begin{rstpre}
\spanIdentifier{i} \spanOperator{=} \spanDecNumber{0}     \spanComment{\# This is a single comment over multiple lines.}
  \spanComment{\# The scanner merges these two pieces.}
  \spanComment{\# The comment continues here.}
\end{rstpre}
Documentation comments\label{documentation-comments_1} are comments that start with two \texttt{\#\#}. Documentation comments are tokens; they are only allowed at certain places in the input file as they belong to the syntax tree!

\rsthB{Multiline comments}\label{lexical-analysis-multiline-comments}
Starting with version 0.13.0 of the language Nim supports multiline comments. They look like:

\begin{rstpre}
\spanLongComment{\#\symbol{91}Comment here.
Multiple lines
are not a problem.\symbol{93}\#}
\end{rstpre}
Multiline comments support nesting:

\begin{rstpre}
\spanLongComment{\#\symbol{91}  \#\symbol{91} Multiline comment in already
   commented out code. \symbol{93}\#
proc p\symbol{91}T\symbol{93}(x: T) = discard
\symbol{93}\#}
\end{rstpre}
Multiline documentation comments also exist and support nesting too:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{foo} \spanOperator{=}
  \spanLongComment{\#\#\symbol{91}Long documentation comment
  here.
  \symbol{93}\#\#}
\end{rstpre}
\rsthB{Identifiers \& Keywords}\label{lexical-analysis-identifiers-amp-keywords}
Identifiers in Nim can be any string of letters, digits and underscores, with the following restrictions:

\begin{itemize}\item begins with a letter
\item does not end with an underscore \texttt{\_}
\item two immediate following underscores \texttt{\_\_} are not allowed::

letter ::= 'A'..'Z' | 'a'..'z' | 'x80'..'xff' digit ::= '0'..'9' IDENTIFIER ::= letter ( \symbol{91}'\_'\symbol{93} (letter | digit) )*


\end{itemize}
Currently any Unicode character with an ordinal value > 127 (non ASCII) is classified as a \texttt{letter} and may thus be part of an identifier but later versions of the language may assign some Unicode characters to belong to the operator characters instead.

The following keywords are reserved and cannot be used as identifiers:

\begin{rstpre}
\spanKeyword{addr} \spanKeyword{and} \spanKeyword{as} \spanKeyword{asm}
\spanKeyword{bind} \spanKeyword{block} \spanKeyword{break}
\spanKeyword{case} \spanKeyword{cast} \spanKeyword{concept} \spanKeyword{const} \spanKeyword{continue} \spanKeyword{converter}
\spanKeyword{defer} \spanKeyword{discard} \spanKeyword{distinct} \spanKeyword{div} \spanKeyword{do}
\spanKeyword{elif} \spanKeyword{else} \spanKeyword{end} \spanKeyword{enum} \spanKeyword{except} \spanKeyword{export}
\spanKeyword{finally} \spanKeyword{for} \spanKeyword{from} \spanKeyword{func}
\spanKeyword{if} \spanKeyword{import} \spanKeyword{in} \spanKeyword{include} \spanKeyword{interface} \spanKeyword{is} \spanKeyword{isnot} \spanKeyword{iterator}
\spanKeyword{let}
\spanKeyword{macro} \spanKeyword{method} \spanKeyword{mixin} \spanKeyword{mod}
\spanKeyword{nil} \spanKeyword{not} \spanKeyword{notin}
\spanKeyword{object} \spanKeyword{of} \spanKeyword{or} \spanKeyword{out}
\spanKeyword{proc} \spanKeyword{ptr}
\spanKeyword{raise} \spanKeyword{ref} \spanKeyword{return}
\spanKeyword{shl} \spanKeyword{shr} \spanKeyword{static}
\spanKeyword{template} \spanKeyword{try} \spanKeyword{tuple} \spanKeyword{type}
\spanKeyword{using}
\spanKeyword{var}
\spanKeyword{when} \spanKeyword{while}
\spanKeyword{xor}
\spanKeyword{yield}

\end{rstpre}
Some keywords are unused; they are reserved for future developments of the language.

\rsthB{Identifier equality}\label{lexical-analysis-identifier-equality}
Two identifiers are considered equal if the following algorithm returns true:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{sameIdentifier}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}} \spanOperator{==} \spanIdentifier{b}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}} \spanKeyword{and}
    \spanIdentifier{a}\spanOperator{.}\spanIdentifier{replace}\spanPunctuation{(}\spanStringLit{"\_"}\spanPunctuation{,} \spanStringLit{""}\spanPunctuation{)}\spanOperator{.}\spanIdentifier{toLowerAscii} \spanOperator{==} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{replace}\spanPunctuation{(}\spanStringLit{"\_"}\spanPunctuation{,} \spanStringLit{""}\spanPunctuation{)}\spanOperator{.}\spanIdentifier{toLowerAscii}
\end{rstpre}
That means only the first letters are compared in a case sensitive manner. Other letters are compared case insensitively within the ASCII range and underscores are ignored.

This rather unorthodox way to do identifier comparisons is called partial case insensitivity\label{partial-case-insensitivity_1} and has some advantages over the conventional case sensitivity:

It allows programmers to mostly use their own preferred spelling style, be it humpStyle or snake\_style, and libraries written by different programmers cannot use incompatible conventions. A Nim-aware editor or IDE can show the identifiers as preferred. Another advantage is that it frees the programmer from remembering the exact spelling of an identifier. The exception with respect to the first letter allows common code like \texttt{var foo: Foo} to be parsed unambiguously.

Note that this rule also applies to keywords, meaning that \texttt{notin} is the same as \texttt{notIn} and \texttt{not\_in} (all-lowercase version (\texttt{notin}, \texttt{isnot}) is the preferred way of writing keywords).

Historically, Nim was a fully style-insensitive\label{styleminusinsensitive_1} language. This meant that it was not case-sensitive and underscores were ignored and there was not even a distinction between \texttt{foo} and \texttt{Foo}.

\rsthB{String literals}\label{lexical-analysis-string-literals}
Terminal symbol in the grammar: \texttt{STR\_LIT}.

String literals can be delimited by matching double quotes, and can contain the following escape sequences\label{escape-sequences_1}:

\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|}
\hline
\textbf{Escape sequence} & \textbf{Meaning}\\
\hline
\texttt{\symbol{92}p} & platform specific newline: CRLF on Windows, LF on Unix\\
\hline
\texttt{\symbol{92}r}, \texttt{\symbol{92}c} & carriage return\label{carriage-return_1}\\
\hline
\texttt{\symbol{92}n}, \texttt{\symbol{92}l} & line feed\label{line-feed_1} (often called newline\label{newline_1})\\
\hline
\texttt{\symbol{92}f} & form feed\label{form-feed_1}\\
\hline
\texttt{\symbol{92}t} & tabulator\label{tabulator_1}\\
\hline
\texttt{\symbol{92}v} & vertical tabulator\label{vertical-tabulator_1}\\
\hline
\texttt{\symbol{92}\symbol{92}} & backslash\label{backslash_1}\\
\hline
\texttt{\symbol{92}"} & quotation mark\label{quotation-mark_1}\\
\hline
\texttt{\symbol{92}'} & apostrophe\label{apostrophe_1}\\
\hline
\texttt{\symbol{92}} '0'..'9'+ & character with decimal value d\label{character-with-decimal-value-d_1}; all decimal digits directly following are used for the character\\
\hline
\texttt{\symbol{92}a} & alert\label{alert_1}\\
\hline
\texttt{\symbol{92}b} & backspace\label{backspace_1}\\
\hline
\texttt{\symbol{92}e} & escape\label{escape_1} \symbol{91}ESC\symbol{93}\label{esc_1}\\
\hline
\texttt{\symbol{92}x} HH & character with hex value HH\label{character-with-hex-value-hh_1}; exactly two hex digits are allowed\\
\hline
\texttt{\symbol{92}u} HHHH & unicode codepoint with hex value HHHH\label{unicode-codepoint-with-hex-value-hhhh_1}; exactly four hex digits are allowed\\
\hline
\texttt{\symbol{92}u} \symbol{123}H+\symbol{125} & unicode codepoint\label{unicode-codepoint_1}; all hex digits enclosed in \texttt{\symbol{123}\symbol{125}} are used for the codepoint\\
\hline
\end{rsttab}\end{table}Strings in Nim may contain any 8-bit value, even embedded zeros. However some operations may interpret the first binary zero as a terminator.

\rsthB{Triple quoted string literals}\label{lexical-analysis-triple-quoted-string-literals}
Terminal symbol in the grammar: \texttt{TRIPLESTR\_LIT}.

String literals can also be delimited by three double quotes \texttt{"""} ... \texttt{"""}. Literals in this form may run for several lines, may contain \texttt{"} and do not interpret any escape sequences. For convenience, when the opening \texttt{"""} is followed by a newline (there may be whitespace between the opening \texttt{"""} and the newline), the newline (and the preceding whitespace) is not included in the string. The ending of the string literal is defined by the pattern \texttt{"""\symbol{91}\symbol{94}"\symbol{93}}, so this:

\begin{rstpre}
\spanLongStringLit{""""long string within quotes""""}
\end{rstpre}
Produces:\begin{rstpre}

"long string within quotes"
\end{rstpre}


\rsthB{Raw string literals}\label{lexical-analysis-raw-string-literals}
Terminal symbol in the grammar: \texttt{RSTR\_LIT}.

There are also raw string literals that are preceded with the letter \texttt{r} (or \texttt{R}) and are delimited by matching double quotes (just like ordinary string literals) and do not interpret the escape sequences. This is especially convenient for regular expressions or Windows paths:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{f} \spanOperator{=} \spanIdentifier{openFile}\spanPunctuation{(}\spanRawData{r"C:\symbol{92}texts\symbol{92}text.txt"}\spanPunctuation{)} \spanComment{\# a raw string, so \symbol{96}\symbol{96}\symbol{92}t\symbol{96}\symbol{96} is no tab}
\end{rstpre}
To produce a single \texttt{"} within a raw string literal, it has to be doubled:

\begin{rstpre}
\spanRawData{r"a""}\spanRawData{b"}
\end{rstpre}
Produces:\begin{rstpre}

a"b
\end{rstpre}


\texttt{r""""} is not possible with this notation, because the three leading quotes introduce a triple quoted string literal. \texttt{r"""} is the same as \texttt{"""} since triple quoted string literals do not interpret escape sequences either.

\rsthB{Generalized raw string literals}\label{lexical-analysis-generalized-raw-string-literals}
Terminal symbols in the grammar: \texttt{GENERALIZED\_STR\_LIT}, \texttt{GENERALIZED\_TRIPLESTR\_LIT}.

The construct \texttt{identifier"string literal"} (without whitespace between the identifier and the opening quotation mark) is a generalized raw string literal. It is a shortcut for the construct \texttt{identifier(r"string literal")}, so it denotes a procedure call with a raw string literal as its only argument. Generalized raw string literals are especially convenient for embedding mini languages directly into Nim (for example regular expressions).

The construct \texttt{identifier"""string literal"""} exists too. It is a shortcut for \texttt{identifier("""string literal""")}.

\rsthB{Character literals}\label{lexical-analysis-character-literals}
Character literals are enclosed in single quotes \texttt{''} and can contain the same escape sequences as strings - with one exception: the platform dependent newline\label{newline_2} (\texttt{\symbol{92}p}) is not allowed as it may be wider than one character (often it is the pair CR/LF for example).  Here are the valid escape sequences\label{escape-sequences_2} for character literals:

\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|X|X|X|X|X|X|X|}
\hline
\textbf{Escape sequence} & \textbf{Meaning}\\
\hline
\texttt{\symbol{92}r}, \texttt{\symbol{92}c} & carriage return\label{carriage-return_2}\\
\hline
\texttt{\symbol{92}n}, \texttt{\symbol{92}l} & line feed\label{line-feed_2}\\
\hline
\texttt{\symbol{92}f} & form feed\label{form-feed_2}\\
\hline
\texttt{\symbol{92}t} & tabulator\label{tabulator_2}\\
\hline
\texttt{\symbol{92}v} & vertical tabulator\label{vertical-tabulator_2}\\
\hline
\texttt{\symbol{92}\symbol{92}} & backslash\label{backslash_2}\\
\hline
\texttt{\symbol{92}"} & quotation mark\label{quotation-mark_2}\\
\hline
\texttt{\symbol{92}'} & apostrophe\label{apostrophe_2}\\
\hline
\texttt{\symbol{92}} '0'..'9'+ & character with decimal value d\label{character-with-decimal-value-d_2}; all decimal digits directly following are used for the character\\
\hline
\texttt{\symbol{92}a} & alert\label{alert_2}\\
\hline
\texttt{\symbol{92}b} & backspace\label{backspace_2}\\
\hline
\texttt{\symbol{92}e} & escape\label{escape_2} \symbol{91}ESC\symbol{93}\label{esc_2}\\
\hline
\texttt{\symbol{92}x} HH & character with hex value HH\label{character-with-hex-value-hh_2}; exactly two hex digits are allowed\\
\hline
\end{rsttab}\end{table}A character is not an Unicode character but a single byte. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can thus support \texttt{array\symbol{91}char, int\symbol{93}} or \texttt{set\symbol{91}char\symbol{93}} efficiently as many algorithms rely on this feature.  The \texttt{Rune} type is used for Unicode characters, it can represent any Unicode character. \texttt{Rune} is declared in the \href{unicode.html}{unicode module}.

\rsthB{Numerical constants}\label{lexical-analysis-numerical-constants}
Numerical constants are of a single type and have the form:\begin{rstpre}

hexdigit = digit | 'A'..'F' | 'a'..'f'
octdigit = '0'..'7'
bindigit = '0'..'1'
HEX\_LIT = '0' ('x' | 'X' ) hexdigit ( \symbol{91}'\_'\symbol{93} hexdigit )*
DEC\_LIT = digit ( \symbol{91}'\_'\symbol{93} digit )*
OCT\_LIT = '0' 'o' octdigit ( \symbol{91}'\_'\symbol{93} octdigit )*
BIN\_LIT = '0' ('b' | 'B' ) bindigit ( \symbol{91}'\_'\symbol{93} bindigit )*

INT\_LIT = HEX\_LIT
        | DEC\_LIT
        | OCT\_LIT
        | BIN\_LIT

INT8\_LIT = INT\_LIT \symbol{91}'\symbol{92}''\symbol{93} ('i' | 'I') '8'
INT16\_LIT = INT\_LIT \symbol{91}'\symbol{92}''\symbol{93} ('i' | 'I') '16'
INT32\_LIT = INT\_LIT \symbol{91}'\symbol{92}''\symbol{93} ('i' | 'I') '32'
INT64\_LIT = INT\_LIT \symbol{91}'\symbol{92}''\symbol{93} ('i' | 'I') '64'

UINT\_LIT = INT\_LIT \symbol{91}'\symbol{92}''\symbol{93} ('u' | 'U')
UINT8\_LIT = INT\_LIT \symbol{91}'\symbol{92}''\symbol{93} ('u' | 'U') '8'
UINT16\_LIT = INT\_LIT \symbol{91}'\symbol{92}''\symbol{93} ('u' | 'U') '16'
UINT32\_LIT = INT\_LIT \symbol{91}'\symbol{92}''\symbol{93} ('u' | 'U') '32'
UINT64\_LIT = INT\_LIT \symbol{91}'\symbol{92}''\symbol{93} ('u' | 'U') '64'

exponent = ('e' | 'E' ) \symbol{91}'+' | '-'\symbol{93} digit ( \symbol{91}'\_'\symbol{93} digit )*
FLOAT\_LIT = digit (\symbol{91}'\_'\symbol{93} digit)* (('.' digit (\symbol{91}'\_'\symbol{93} digit)* \symbol{91}exponent\symbol{93}) |exponent)
FLOAT32\_SUFFIX = ('f' | 'F') \symbol{91}'32'\symbol{93}
FLOAT32\_LIT = HEX\_LIT '\symbol{92}'' FLOAT32\_SUFFIX
            | (FLOAT\_LIT | DEC\_LIT | OCT\_LIT | BIN\_LIT) \symbol{91}'\symbol{92}''\symbol{93} FLOAT32\_SUFFIX
FLOAT64\_SUFFIX = ( ('f' | 'F') '64' ) | 'd' | 'D'
FLOAT64\_LIT = HEX\_LIT '\symbol{92}'' FLOAT64\_SUFFIX
            | (FLOAT\_LIT | DEC\_LIT | OCT\_LIT | BIN\_LIT) \symbol{91}'\symbol{92}''\symbol{93} FLOAT64\_SUFFIX
\end{rstpre}


As can be seen in the productions, numerical constants can contain underscores for readability. Integer and floating point literals may be given in decimal (no prefix), binary (prefix \texttt{0b}), octal (prefix \texttt{0o}) and hexadecimal (prefix \texttt{0x}) notation.

There exists a literal for each numerical type that is defined. The suffix starting with an apostrophe (''') is called a type suffix\label{type-suffix_1}. Literals without a type suffix are of an integer type, unless the literal contains a dot or \texttt{E|e} in which case it is of type \texttt{float}. This integer type is \texttt{int} if the literal is in the range \texttt{low(i32)..high(i32)}, otherwise it is \texttt{int64}. For notational convenience the apostrophe of a type suffix is optional if it is not ambiguous (only hexadecimal floating point literals with a type suffix can be ambiguous).

The type suffixes are:

\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|X|X|X|X|X|X|X|}
\hline
\textbf{Type Suffix} & \textbf{Resulting type of literal}\\
\hline
\texttt{'i8} & int8\\
\hline
\texttt{'i16} & int16\\
\hline
\texttt{'i32} & int32\\
\hline
\texttt{'i64} & int64\\
\hline
\texttt{'u} & uint\\
\hline
\texttt{'u8} & uint8\\
\hline
\texttt{'u16} & uint16\\
\hline
\texttt{'u32} & uint32\\
\hline
\texttt{'u64} & uint64\\
\hline
\texttt{'f} & float32\\
\hline
\texttt{'d} & float64\\
\hline
\texttt{'f32} & float32\\
\hline
\texttt{'f64} & float64\\
\hline
\end{rsttab}\end{table}Floating point literals may also be in binary, octal or hexadecimal notation: \texttt{0B0\_10001110100\_0000101001000111101011101111111011000101001101001001'f64} is approximately 1.72826e35 according to the IEEE floating point standard.

Literals are bounds checked so that they fit the datatype. Non base-10 literals are used mainly for flags and bit pattern representations, therefore bounds checking is done on bit width, not value range. If the literal fits in the bit width of the datatype, it is accepted. Hence: 0b10000000'u8 == 0x80'u8 == 128, but, 0b10000000'i8 == 0x80'i8 == -1 instead of causing an overflow error.

\rsthB{Operators}\label{lexical-analysis-operators}
Nim allows user defined operators. An operator is any combination of the following characters:\begin{rstpre}

=     +     -     *     /     <     >
\symbol{64}     \$     \symbol{126}     \&     \%     |
!     ?     \symbol{94}     .     :     \symbol{92}
\end{rstpre}


(The grammar uses the terminal OPR to refer to operator symbols as defined here.)

These keywords are also operators: \texttt{and or not xor shl shr div mod in notin is isnot of as from}.

\spantok{.} \spantok{=}, \spantok{:}, \spantok{::} are not available as general operators; they are used for other notational purposes.

\texttt{*:} is as a special case treated as the two tokens \spantok{*} and \spantok{:} (to support \texttt{var v*: T}).

The \texttt{not} keyword is always a unary operator, \texttt{a not b} is parsed as \texttt{a(not b)}, not as \texttt{(a) not (b)}.

\rsthB{Other tokens}\label{lexical-analysis-other-tokens}
The following strings denote other tokens:\begin{rstpre}

\symbol{96}   (    )     \symbol{123}    \symbol{125}     \symbol{91}    \symbol{93}    ,  ;   \symbol{91}.    .\symbol{93}  \symbol{123}.   .\symbol{125}  (.  .)  \symbol{91}:
\end{rstpre}


The slice\label{slice_1} operator \spantok{..} takes precedence over other tokens that contain a dot: \spantok{\symbol{123}..\symbol{125}} are the three tokens \spantok{\symbol{123}}, \spantok{..}, \spantok{\symbol{125}} and not the two tokens \spantok{\symbol{123}.}, \spantok{.\symbol{125}}.

\rsthA{Syntax}\label{syntax}
This section lists Nim's standard syntax. How the parser handles the indentation is already described in the Lexical Analysis\ref{lexical-analysis} section.

Nim allows user-definable operators. Binary operators have 11 different levels of precedence.

\rsthB{Associativity}\label{syntax-associativity}
Binary operators whose first character is \texttt{\symbol{94}} are right-associative, all other binary operators are left-associative.

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{\symbol{94}/}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{float}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{float} \spanOperator{=}
  \spanComment{\# a right-associative division operator}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{x} \spanOperator{/} \spanIdentifier{y}
\spanIdentifier{echo} \spanDecNumber{12} \spanOperator{\symbol{94}/} \spanDecNumber{4} \spanOperator{\symbol{94}/} \spanDecNumber{8} \spanComment{\# 24.0 (4 / 8 = 0.5, then 12 / 0.5 = 24.0)}
\spanIdentifier{echo} \spanDecNumber{12}  \spanOperator{/} \spanDecNumber{4}  \spanOperator{/} \spanDecNumber{8} \spanComment{\# 0.375 (12 / 4 = 3.0, then 3 / 8 = 0.375)}
\end{rstpre}
\rsthB{Precedence}\label{syntax-precedence}
Unary operators always bind stronger than any binary operator: \texttt{\$a + b} is \texttt{(\$a) + b} and not \texttt{\$(a + b)}.

If an unary operator's first character is \texttt{\symbol{64}} it is a sigil-like\label{sigilminuslike_1} operator which binds stronger than a \texttt{primarySuffix}: \texttt{\symbol{64}x.abc} is parsed as \texttt{(\symbol{64}x).abc} whereas \texttt{\$x.abc} is parsed as \texttt{\$(x.abc)}.

For binary operators that are not keywords the precedence is determined by the following rules:

Operators ending in either \texttt{->}, \texttt{\symbol{126}>} or \texttt{=>} are called arrow like\label{arrow-like_1}, and have the lowest precedence of all operators.

If the operator ends with \texttt{=} and its first character is none of \texttt{<}, \texttt{>}, \texttt{!}, \texttt{=}, \texttt{\symbol{126}}, \texttt{?}, it is an \emph{assignment operator} which has the second lowest precedence.

Otherwise precedence is determined by the first character.

\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|X|X|X|X|X|}
\hline
\textbf{Precedence level} & \textbf{Operators} & \textbf{First character} & \textbf{Terminal symbol}\\
\hline
10 (highest) &  & \texttt{\$ \symbol{94}} & OP10\\
\hline
9 & \texttt{* / div mod shl shr \%} & \texttt{* \% \symbol{92} /} & OP9\\
\hline
8 & \texttt{+ -} & \texttt{+ - \symbol{126} |} & OP8\\
\hline
7 & \texttt{\&} & \texttt{\&} & OP7\\
\hline
6 & \texttt{..} & \texttt{.} & OP6\\
\hline
5 & \texttt{== <= < >= > != in notin is isnot not of as from} & \texttt{= < > !} & OP5\\
\hline
4 & \texttt{and} &  & OP4\\
\hline
3 & \texttt{or xor} &  & OP3\\
\hline
2 &  & \texttt{\symbol{64} : ?} & OP2\\
\hline
1 & \emph{assignment operator} (like \texttt{+=}, \texttt{*=}) &  & OP1\\
\hline
0 (lowest) & \emph{arrow like operator} (like \texttt{->}, \texttt{=>}) &  & OP0\\
\hline
\end{rsttab}\end{table}Whether an operator is used a prefix operator is also affected by preceding whitespace (this parsing change was introduced with version 0.13.0):

\begin{rstpre}
\spanIdentifier{echo} \spanOperator{\$}\spanIdentifier{foo}
\spanComment{\# is parsed as}
\spanIdentifier{echo}\spanPunctuation{(}\spanOperator{\$}\spanIdentifier{foo}\spanPunctuation{)}
\end{rstpre}
Spacing also determines whether \texttt{(a, b)} is parsed as an the argument list of a call or whether it is parsed as a tuple constructor:

\begin{rstpre}
\spanIdentifier{echo}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{)} \spanComment{\# pass 1 and 2 to echo}
\end{rstpre}
\begin{rstpre}
\spanIdentifier{echo} \spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{)} \spanComment{\# pass the tuple (1, 2) to echo}
\end{rstpre}
\rsthB{Grammar}\label{syntax-grammar}
The grammar's start symbol is \texttt{module}.

\begin{rstpre}
\# This file is generated by compiler/parser.nim.
module = stmt \symbol{94}* (';' / IND\symbol{123}=\symbol{125})
comma = ',' COMMENT?
semicolon = ';' COMMENT?
colon = ':' COMMENT?
colcom = ':' COMMENT?
operator =  OP0 | OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9
         | 'or' | 'xor' | 'and'
         | 'is' | 'isnot' | 'in' | 'notin' | 'of' | 'as' | 'from' |
         | 'div' | 'mod' | 'shl' | 'shr' | 'not' | 'static' | '..'
prefixOperator = operator
optInd = COMMENT? IND?
optPar = (IND\symbol{123}>\symbol{125} | IND\symbol{123}=\symbol{125})?
simpleExpr = arrowExpr (OP0 optInd arrowExpr)* pragma?
arrowExpr = assignExpr (OP1 optInd assignExpr)*
assignExpr = orExpr (OP2 optInd orExpr)*
orExpr = andExpr (OP3 optInd andExpr)*
andExpr = cmpExpr (OP4 optInd cmpExpr)*
cmpExpr = sliceExpr (OP5 optInd sliceExpr)*
sliceExpr = ampExpr (OP6 optInd ampExpr)*
ampExpr = plusExpr (OP7 optInd plusExpr)*
plusExpr = mulExpr (OP8 optInd mulExpr)*
mulExpr = dollarExpr (OP9 optInd dollarExpr)*
dollarExpr = primary (OP10 optInd primary)*
symbol = '\symbol{96}' (KEYW|IDENT|literal|(operator|'('|')'|'\symbol{91}'|'\symbol{93}'|'\symbol{123}'|'\symbol{125}'|'=')+)+ '\symbol{96}'
       | IDENT | KEYW
exprColonEqExpr = expr (':'|'=' expr)?
exprList = expr \symbol{94}+ comma
exprColonEqExprList = exprColonEqExpr (comma exprColonEqExpr)* (comma)?
dotExpr = expr '.' optInd (symbol | '\symbol{91}:' exprList '\symbol{93}')
explicitGenericInstantiation = '\symbol{91}:' exprList '\symbol{93}' ( '(' exprColonEqExpr ')' )?
qualifiedIdent = symbol ('.' optInd symbol)?
setOrTableConstr = '\symbol{123}' ((exprColonEqExpr comma)* | ':' ) '\symbol{125}'
castExpr = 'cast' '\symbol{91}' optInd typeDesc optPar '\symbol{93}' '(' optInd expr optPar ')'
parKeyw = 'discard' | 'include' | 'if' | 'while' | 'case' | 'try'
        | 'finally' | 'except' | 'for' | 'block' | 'const' | 'let'
        | 'when' | 'var' | 'mixin'
par = '(' optInd
          ( \&parKeyw complexOrSimpleStmt \symbol{94}+ ';'
          | ';' complexOrSimpleStmt \symbol{94}+ ';'
          | pragmaStmt
          | simpleExpr ( ('=' expr (';' complexOrSimpleStmt \symbol{94}+ ';' )? )
                       | (':' expr (',' exprColonEqExpr     \symbol{94}+ ',' )? ) ) )
          optPar ')'
literal = | INT\_LIT | INT8\_LIT | INT16\_LIT | INT32\_LIT | INT64\_LIT
          | UINT\_LIT | UINT8\_LIT | UINT16\_LIT | UINT32\_LIT | UINT64\_LIT
          | FLOAT\_LIT | FLOAT32\_LIT | FLOAT64\_LIT
          | STR\_LIT | RSTR\_LIT | TRIPLESTR\_LIT
          | CHAR\_LIT
          | NIL
generalizedLit = GENERALIZED\_STR\_LIT | GENERALIZED\_TRIPLESTR\_LIT
identOrLiteral = generalizedLit | symbol | literal
               | par | arrayConstr | setOrTableConstr
               | castExpr
tupleConstr = '(' optInd (exprColonEqExpr comma?)* optPar ')'
arrayConstr = '\symbol{91}' optInd (exprColonEqExpr comma?)* optPar '\symbol{93}'
primarySuffix = '(' (exprColonEqExpr comma?)* ')'
      | '.' optInd symbol generalizedLit?
      | '\symbol{91}' optInd exprColonEqExprList optPar '\symbol{93}'
      | '\symbol{123}' optInd exprColonEqExprList optPar '\symbol{125}'
      | \&( '\symbol{96}'|IDENT|literal|'cast'|'addr'|'type') expr \# command syntax
condExpr = expr colcom expr optInd
        ('elif' expr colcom expr optInd)*
         'else' colcom expr
ifExpr = 'if' condExpr
whenExpr = 'when' condExpr
pragma = '\symbol{123}.' optInd (exprColonEqExpr comma?)* optPar ('.\symbol{125}' | '\symbol{125}')
identVis = symbol OPR?  \# postfix position
identVisDot = symbol '.' optInd symbol OPR?
identWithPragma = identVis pragma?
identWithPragmaDot = identVisDot pragma?
declColonEquals = identWithPragma (comma identWithPragma)* comma?
                  (':' optInd typeDesc)? ('=' optInd expr)?
identColonEquals = IDENT (comma IDENT)* comma?
     (':' optInd typeDesc)? ('=' optInd expr)?)
inlTupleDecl = 'tuple'
    '\symbol{91}' optInd  (identColonEquals (comma/semicolon)?)*  optPar '\symbol{93}'
extTupleDecl = 'tuple'
    COMMENT? (IND\symbol{123}>\symbol{125} identColonEquals (IND\symbol{123}=\symbol{125} identColonEquals)*)?
tupleClass = 'tuple'
paramList = '(' declColonEquals \symbol{94}* (comma/semicolon) ')'
paramListArrow = paramList? ('->' optInd typeDesc)?
paramListColon = paramList? (':' optInd typeDesc)?
doBlock = 'do' paramListArrow pragma? colcom stmt
procExpr = 'proc' paramListColon pragma? ('=' COMMENT? stmt)?
distinct = 'distinct' optInd typeDesc
forStmt = 'for' (identWithPragma \symbol{94}+ comma) 'in' expr colcom stmt
forExpr = forStmt
expr = (blockExpr
      | ifExpr
      | whenExpr
      | caseStmt
      | forExpr
      | tryExpr)
      / simpleExpr
typeKeyw = 'var' | 'out' | 'ref' | 'ptr' | 'shared' | 'tuple'
         | 'proc' | 'iterator' | 'distinct' | 'object' | 'enum'
primary = typeKeyw optInd typeDesc
        /  prefixOperator* identOrLiteral primarySuffix*
        / 'bind' primary
typeDesc = simpleExpr ('not' expr)?
typeDefAux = simpleExpr ('not' expr)?
           | 'concept' typeClass
postExprBlocks = ':' stmt? ( IND\symbol{123}=\symbol{125} doBlock
                           | IND\symbol{123}=\symbol{125} 'of' exprList ':' stmt
                           | IND\symbol{123}=\symbol{125} 'elif' expr ':' stmt
                           | IND\symbol{123}=\symbol{125} 'except' exprList ':' stmt
                           | IND\symbol{123}=\symbol{125} 'else' ':' stmt )*
exprStmt = simpleExpr
         (( '=' optInd expr colonBody? )
         / ( expr \symbol{94}+ comma
             postExprBlocks
           ))?
importStmt = 'import' optInd expr
              ((comma expr)*
              / 'except' optInd (expr \symbol{94}+ comma))
exportStmt = 'export' optInd expr
              ((comma expr)*
              / 'except' optInd (expr \symbol{94}+ comma))
includeStmt = 'include' optInd expr \symbol{94}+ comma
fromStmt = 'from' expr 'import' optInd expr (comma expr)*
returnStmt = 'return' optInd expr?
raiseStmt = 'raise' optInd expr?
yieldStmt = 'yield' optInd expr?
discardStmt = 'discard' optInd expr?
breakStmt = 'break' optInd expr?
continueStmt = 'break' optInd expr?
condStmt = expr colcom stmt COMMENT?
           (IND\symbol{123}=\symbol{125} 'elif' expr colcom stmt)*
           (IND\symbol{123}=\symbol{125} 'else' colcom stmt)?
ifStmt = 'if' condStmt
whenStmt = 'when' condStmt
whileStmt = 'while' expr colcom stmt
ofBranch = 'of' exprList colcom stmt
ofBranches = ofBranch (IND\symbol{123}=\symbol{125} ofBranch)*
                      (IND\symbol{123}=\symbol{125} 'elif' expr colcom stmt)*
                      (IND\symbol{123}=\symbol{125} 'else' colcom stmt)?
caseStmt = 'case' expr ':'? COMMENT?
            (IND\symbol{123}>\symbol{125} ofBranches DED
            | IND\symbol{123}=\symbol{125} ofBranches)
tryStmt = 'try' colcom stmt \&(IND\symbol{123}=\symbol{125}? 'except'|'finally')
           (IND\symbol{123}=\symbol{125}? 'except' exprList colcom stmt)*
           (IND\symbol{123}=\symbol{125}? 'finally' colcom stmt)?
tryExpr = 'try' colcom stmt \&(optInd 'except'|'finally')
           (optInd 'except' exprList colcom stmt)*
           (optInd 'finally' colcom stmt)?
exceptBlock = 'except' colcom stmt
blockStmt = 'block' symbol? colcom stmt
blockExpr = 'block' symbol? colcom stmt
staticStmt = 'static' colcom stmt
deferStmt = 'defer' colcom stmt
asmStmt = 'asm' pragma? (STR\_LIT | RSTR\_LIT | TRIPLESTR\_LIT)
genericParam = symbol (comma symbol)* (colon expr)? ('=' optInd expr)?
genericParamList = '\symbol{91}' optInd
  genericParam \symbol{94}* (comma/semicolon) optPar '\symbol{93}'
pattern = '\symbol{123}' stmt '\symbol{125}'
indAndComment = (IND\symbol{123}>\symbol{125} COMMENT)? | COMMENT?
routine = optInd identVis pattern? genericParamList?
  paramListColon pragma? ('=' COMMENT? stmt)? indAndComment
commentStmt = COMMENT
section(RULE) = COMMENT? RULE / (IND\symbol{123}>\symbol{125} (RULE / COMMENT)\symbol{94}+IND\symbol{123}=\symbol{125} DED)
enum = 'enum' optInd (symbol pragma? optInd ('=' optInd expr COMMENT?)? comma?)+
objectWhen = 'when' expr colcom objectPart COMMENT?
            ('elif' expr colcom objectPart COMMENT?)*
            ('else' colcom objectPart COMMENT?)?
objectBranch = 'of' exprList colcom objectPart
objectBranches = objectBranch (IND\symbol{123}=\symbol{125} objectBranch)*
                      (IND\symbol{123}=\symbol{125} 'elif' expr colcom objectPart)*
                      (IND\symbol{123}=\symbol{125} 'else' colcom objectPart)?
objectCase = 'case' identWithPragma ':' typeDesc ':'? COMMENT?
            (IND\symbol{123}>\symbol{125} objectBranches DED
            | IND\symbol{123}=\symbol{125} objectBranches)
objectPart = IND\symbol{123}>\symbol{125} objectPart\symbol{94}+IND\symbol{123}=\symbol{125} DED
           / objectWhen / objectCase / 'nil' / 'discard' / declColonEquals
object = 'object' pragma? ('of' typeDesc)? COMMENT? objectPart
typeClassParam = ('var' | 'out')? symbol
typeClass = typeClassParam \symbol{94}* ',' (pragma)? ('of' typeDesc \symbol{94}* ',')?
              \&IND\symbol{123}>\symbol{125} stmt
typeDef = identWithPragmaDot genericParamList? '=' optInd typeDefAux
            indAndComment? / identVisDot genericParamList? pragma '=' optInd typeDefAux
            indAndComment?
varTuple = '(' optInd identWithPragma \symbol{94}+ comma optPar ')' '=' optInd expr
colonBody = colcom stmt postExprBlocks?
variable = (varTuple / identColonEquals) colonBody? indAndComment
constant = (varTuple / identWithPragma) (colon typeDesc)? '=' optInd expr indAndComment
bindStmt = 'bind' optInd qualifiedIdent \symbol{94}+ comma
mixinStmt = 'mixin' optInd qualifiedIdent \symbol{94}+ comma
pragmaStmt = pragma (':' COMMENT? stmt)?
simpleStmt = ((returnStmt | raiseStmt | yieldStmt | discardStmt | breakStmt
           | continueStmt | pragmaStmt | importStmt | exportStmt | fromStmt
           | includeStmt | commentStmt) / exprStmt) COMMENT?
complexOrSimpleStmt = (ifStmt | whenStmt | whileStmt
                    | tryStmt | forStmt
                    | blockStmt | staticStmt | deferStmt | asmStmt
                    | 'proc' routine
                    | 'func' routine
                    | 'method' routine
                    | 'iterator' routine
                    | 'macro' routine
                    | 'template' routine
                    | 'converter' routine
                    | 'type' section(typeDef)
                    | 'const' section(constant)
                    | ('let' | 'var' | 'using') section(variable)
                    | bindStmt | mixinStmt)
                    / simpleStmt
stmt = (IND\symbol{123}>\symbol{125} complexOrSimpleStmt\symbol{94}+(IND\symbol{123}=\symbol{125} / ';') DED)
     / simpleStmt \symbol{94}+ ';'

\end{rstpre}
\rsthA{Order of evaluation}\label{order-of-evaluation}
Order of evaluation is strictly left-to-right, inside-out as it is typical for most others imperative programming languages:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{s} \spanOperator{=} \spanStringLit{""}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{arg}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{s}\spanOperator{.}\spanIdentifier{add} \spanOperator{\$}\spanIdentifier{arg}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{arg}

\spanKeyword{discard} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{p}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{)} \spanOperator{+} \spanIdentifier{p}\spanPunctuation{(}\spanDecNumber{2}\spanPunctuation{)}\spanPunctuation{)}

\spanIdentifier{doAssert} \spanIdentifier{s} \spanOperator{==} \spanStringLit{"123"}
\end{rstpre}
Assignments are not special, the left-hand-side expression is evaluated before the right-hand side:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{v} \spanOperator{=} \spanDecNumber{0}
\spanKeyword{proc} \spanIdentifier{getI}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{v}
  \spanIdentifier{inc} \spanIdentifier{v}

\spanKeyword{var} \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{2}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanIdentifier{someCopy}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{int}\spanPunctuation{;} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{a} \spanOperator{=} \spanIdentifier{b}

\spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{getI}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{getI}\spanPunctuation{(}\spanPunctuation{)}

\spanIdentifier{doAssert} \spanIdentifier{a} \spanOperator{==} \spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{0}\spanPunctuation{\symbol{93}}

\spanIdentifier{v} \spanOperator{=} \spanDecNumber{0}
\spanIdentifier{someCopy}\spanPunctuation{(}\spanIdentifier{b}\spanPunctuation{\symbol{91}}\spanIdentifier{getI}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{getI}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{)}

\spanIdentifier{doAssert} \spanIdentifier{b} \spanOperator{==} \spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{0}\spanPunctuation{\symbol{93}}
\end{rstpre}
Rationale: Consistency with overloaded assignment or assignment-like operations, \texttt{a = b} can be read as \texttt{performSomeCopy(a, b)}.

However, the concept of "order of evaluation" is only applicable after the code was normalized: The normalization involves template expansions and argument reorderings that have been passed to named parameters:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{s} \spanOperator{=} \spanStringLit{""}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{s}\spanOperator{.}\spanIdentifier{add} \spanStringLit{"p"}
  \spanIdentifier{result} \spanOperator{=} \spanDecNumber{5}

\spanKeyword{proc} \spanIdentifier{q}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{s}\spanOperator{.}\spanIdentifier{add} \spanStringLit{"q"}
  \spanIdentifier{result} \spanOperator{=} \spanDecNumber{3}

\spanComment{\# Evaluation order is 'b' before 'a' due to template}
\spanComment{\# expansion's semantics.}
\spanKeyword{template} \spanIdentifier{swapArgs}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanIdentifier{b} \spanOperator{+} \spanIdentifier{a}

\spanIdentifier{doAssert} \spanIdentifier{swapArgs}\spanPunctuation{(}\spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{+} \spanIdentifier{q}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{q}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{-} \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{)} \spanOperator{==} \spanDecNumber{6}
\spanIdentifier{doAssert} \spanIdentifier{s} \spanOperator{==} \spanStringLit{"qppq"}

\spanComment{\# Evaluation order is not influenced by named parameters:}
\spanKeyword{proc} \spanIdentifier{construct}\spanPunctuation{(}\spanIdentifier{first}\spanPunctuation{,} \spanIdentifier{second}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{discard}

\spanComment{\# 'p' is evaluated before 'q'!}
\spanIdentifier{construct}\spanPunctuation{(}\spanIdentifier{second} \spanOperator{=} \spanIdentifier{q}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{first} \spanOperator{=} \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{)}

\spanIdentifier{doAssert} \spanIdentifier{s} \spanOperator{==} \spanStringLit{"qppqpq"}
\end{rstpre}
Rationale: This is far easier to implement than hypothetical alternatives.

\rsthA{Constants and Constant Expressions}\label{constants-and-constant-expressions}
A constant\label{constant_1} is a symbol that is bound to the value of a constant expression. Constant expressions are restricted to depend only on the following categories of values and operations, because these are either built into the language or declared and evaluated before semantic analysis of the constant expression:

\begin{itemize}\item literals
\item built-in operators
\item previously declared constants and compile-time variables
\item previously declared macros and templates
\item previously declared procedures that have no side effects beyond possibly modifying compile-time variables
\end{itemize}
A constant expression can contain code blocks that may internally use all Nim features supported at compile time (as detailed in the next section below). Within such a code block, it is possible to declare variables and then later read and update them, or declare variables and pass them to procedures that modify them. However, the code in such a block must still adhere to the restrictions listed above for referencing values and operations outside the block.

The ability to access and modify compile-time variables adds flexibility to constant expressions that may be surprising to those coming from other statically typed languages. For example, the following code echoes the beginning of the Fibonacci series \textbf{at compile time}. (This is a demonstration of flexibility in defining constants, not a recommended style for solving this problem!)

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{strformat}

\spanKeyword{var} \spanIdentifier{fib\_n} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{compileTime}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int}
\spanKeyword{var} \spanIdentifier{fib\_prev} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{compileTime}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int}
\spanKeyword{var} \spanIdentifier{fib\_prev\_prev} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{compileTime}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int}

\spanKeyword{proc} \spanIdentifier{next\_fib}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanKeyword{if} \spanIdentifier{fib\_n} \spanOperator{<} \spanDecNumber{2}\spanPunctuation{:}
    \spanIdentifier{fib\_n}
  \spanKeyword{else}\spanPunctuation{:}
    \spanIdentifier{fib\_prev\_prev} \spanOperator{+} \spanIdentifier{fib\_prev}
  \spanIdentifier{inc}\spanPunctuation{(}\spanIdentifier{fib\_n}\spanPunctuation{)}
  \spanIdentifier{fib\_prev\_prev} \spanOperator{=} \spanIdentifier{fib\_prev}
  \spanIdentifier{fib\_prev} \spanOperator{=} \spanIdentifier{result}

\spanKeyword{const} \spanIdentifier{f0} \spanOperator{=} \spanIdentifier{next\_fib}\spanPunctuation{(}\spanPunctuation{)}
\spanKeyword{const} \spanIdentifier{f1} \spanOperator{=} \spanIdentifier{next\_fib}\spanPunctuation{(}\spanPunctuation{)}

\spanKeyword{const} \spanIdentifier{display\_fib} \spanOperator{=} \spanKeyword{block}\spanPunctuation{:}
  \spanKeyword{const} \spanIdentifier{f2} \spanOperator{=} \spanIdentifier{next\_fib}\spanPunctuation{(}\spanPunctuation{)}
  \spanKeyword{var} \spanIdentifier{result} \spanOperator{=} \spanRawData{fmt"Fibonacci sequence: \symbol{123}f0\symbol{125}, \symbol{123}f1\symbol{125}, \symbol{123}f2\symbol{125}"}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{3.}\spanOperator{.}\spanDecNumber{12}\spanPunctuation{:}
    \spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{,} \spanRawData{fmt", \symbol{123}next\_fib()\symbol{125}"}\spanPunctuation{)}
  \spanIdentifier{result}

\spanKeyword{static}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{display\_fib}
\end{rstpre}
\rsthA{Restrictions on Compile-Time Execution}\label{restrictions-on-compileminustime-execution}
Nim code that will be executed at compile time cannot use the following language features:

\begin{itemize}\item methods
\item closure iterators
\item the \texttt{cast} operator
\item reference (pointer) types
\item FFI
\end{itemize}
The use of wrappers that use FFI and/or \texttt{cast} is also disallowed. Note that these wrappers include the ones in the standard libraries.

Some or all of these restrictions are likely to be lifted over time.

\rsthA{Types}\label{types}
All expressions have a type which is known during semantic analysis. Nim is statically typed. One can declare new types, which is in essence defining an identifier that can be used to denote this custom type.

These are the major type classes:

\begin{itemize}\item ordinal types (consist of integer, bool, character, enumeration (and subranges thereof) types)
\item floating point types
\item string type
\item structured types
\item reference (pointer) type
\item procedural type
\item generic type
\end{itemize}
\rsthB{Ordinal types}\label{types-ordinal-types}
Ordinal types have the following characteristics:

\begin{itemize}\item Ordinal types are countable and ordered. This property allows the operation of functions as \texttt{inc}, \texttt{ord}, \texttt{dec} on ordinal types to be defined.
\item Ordinal values have a smallest possible value. Trying to count further down than the smallest value produces a panic or a static error.
\item Ordinal values have a largest possible value. Trying to count further than the largest value produces a panic or a static error.
\end{itemize}
Integers, bool, characters and enumeration types (and subranges of these types) belong to ordinal types. For reasons of simplicity of implementation the types \texttt{uint} and \texttt{uint64} are not ordinal types. (This will be changed in later versions of the language.)

A distinct type is an ordinal type if its base type is an ordinal type.

\rsthB{Pre-defined integer types}\label{types-preminusdefined-integer-types}
These integer types are pre-defined:

\begin{description}\item[\texttt{int}] the generic signed integer type; its size is platform dependent and has the same size as a pointer. This type should be used in general. An integer literal that has no type suffix is of this type if it is in the range \texttt{low(int32)..high(int32)} otherwise the literal's type is \texttt{int64}.
\item[intXX] additional signed integer types of XX bits use this naming scheme (example: int16 is a 16 bit wide integer). The current implementation supports \texttt{int8}, \texttt{int16}, \texttt{int32}, \texttt{int64}. Literals of these types have the suffix 'iXX.
\item[\texttt{uint}] the generic unsigned integer\label{unsigned-integer_1} type; its size is platform dependent and has the same size as a pointer. An integer literal with the type suffix \texttt{'u} is of this type.
\item[uintXX] additional unsigned integer types of XX bits use this naming scheme (example: uint16 is a 16 bit wide unsigned integer). The current implementation supports \texttt{uint8}, \texttt{uint16}, \texttt{uint32}, \texttt{uint64}. Literals of these types have the suffix 'uXX. Unsigned operations all wrap around; they cannot lead to over- or underflow errors.
\end{description}
In addition to the usual arithmetic operators for signed and unsigned integers (\texttt{+ - *} etc.) there are also operators that formally work on \emph{signed} integers but treat their arguments as \emph{unsigned}: They are mostly provided for backwards compatibility with older versions of the language that lacked unsigned integer types. These unsigned operations for signed integers use the \texttt{\%} suffix as convention:

\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|X|X|X|X|X|}
\hline
\textbf{operation} & \textbf{meaning}\\
\hline
\texttt{a +\% b} & unsigned integer addition\\
\hline
\texttt{a -\% b} & unsigned integer subtraction\\
\hline
\texttt{a *\% b} & unsigned integer multiplication\\
\hline
\texttt{a /\% b} & unsigned integer division\\
\hline
\texttt{a \%\% b} & unsigned integer modulo operation\\
\hline
\texttt{a <\% b} & treat \texttt{a} and \texttt{b} as unsigned and compare\\
\hline
\texttt{a <=\% b} & treat \texttt{a} and \texttt{b} as unsigned and compare\\
\hline
\texttt{ze(a)} & extends the bits of \texttt{a} with zeros until it has the width of the \texttt{int} type\\
\hline
\texttt{toU8(a)} & treats \texttt{a} as unsigned and converts it to an unsigned integer of 8 bits (but still the \texttt{int8} type)\\
\hline
\texttt{toU16(a)} & treats \texttt{a} as unsigned and converts it to an unsigned integer of 16 bits (but still the \texttt{int16} type)\\
\hline
\texttt{toU32(a)} & treats \texttt{a} as unsigned and converts it to an unsigned integer of 32 bits (but still the \texttt{int32} type)\\
\hline
\end{rsttab}\end{table}Automatic type conversion\label{automatic-type-conversion_1} is performed in expressions where different kinds of integer types are used: the smaller type is converted to the larger.

A narrowing type conversion\label{narrowing-type-conversion_1} converts a larger to a smaller type (for example \texttt{int32 -> int16}. A widening type conversion\label{widening-type-conversion_1} converts a smaller type to a larger type (for example \texttt{int16 -> int32}). In Nim only widening type conversions are \emph{implicit}:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{myInt16} \spanOperator{=} \spanDecNumber{5}\spanIdentifier{i16}
\spanKeyword{var} \spanIdentifier{myInt}\spanPunctuation{:} \spanIdentifier{int}
\spanIdentifier{myInt16} \spanOperator{+} \spanDecNumber{34}     \spanComment{\# of type \symbol{96}\symbol{96}int16\symbol{96}\symbol{96}}
\spanIdentifier{myInt16} \spanOperator{+} \spanIdentifier{myInt}  \spanComment{\# of type \symbol{96}\symbol{96}int\symbol{96}\symbol{96}}
\spanIdentifier{myInt16} \spanOperator{+} \spanDecNumber{2}\spanIdentifier{i32}   \spanComment{\# of type \symbol{96}\symbol{96}int32\symbol{96}\symbol{96}}
\end{rstpre}
However, \texttt{int} literals are implicitly convertible to a smaller integer type if the literal's value fits this smaller type and such a conversion is less expensive than other implicit conversions, so \texttt{myInt16 + 34} produces an \texttt{int16} result.

For further details, see \href{\#type-relations-convertible-relation}{Convertible relation}.

\rsthB{Subrange types}\label{types-subrange-types}
A subrange type is a range of values from an ordinal or floating point type (the base type). To define a subrange type, one must specify its limiting values -- the lowest and highest value of the type. For example:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Subrange} \spanOperator{=} \spanIdentifier{range}\spanPunctuation{\symbol{91}}\spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{5}\spanPunctuation{\symbol{93}}
  \spanIdentifier{PositiveFloat} \spanOperator{=} \spanIdentifier{range}\spanPunctuation{\symbol{91}}\spanFloatNumber{0.0}\spanOperator{..}\spanIdentifier{Inf}\spanPunctuation{\symbol{93}}
\end{rstpre}
\texttt{Subrange} is a subrange of an integer which can only hold the values 0 to 5. \texttt{PositiveFloat} defines a subrange of all positive floating point values. NaN does not belong to any subrange of floating point types. Assigning any other value to a variable of type \texttt{Subrange} is a panic (or a static error if it can be determined during semantic analysis). Assignments from the base type to one of its subrange types (and vice versa) are allowed.

A subrange type has the same size as its base type (\texttt{int} in the Subrange example).

\rsthB{Pre-defined floating point types}\label{types-preminusdefined-floating-point-types}
The following floating point types are pre-defined:

\begin{description}\item[\texttt{float}] the generic floating point type; its size used to be platform dependent, but now it is always mapped to \texttt{float64}. This type should be used in general.
\item[floatXX] an implementation may define additional floating point types of XX bits using this naming scheme (example: float64 is a 64 bit wide float). The current implementation supports \texttt{float32} and \texttt{float64}. Literals of these types have the suffix 'fXX.
\end{description}
Automatic type conversion in expressions with different kinds of floating point types is performed: See \href{\#type-relations-convertible-relation}{Convertible relation} for further details. Arithmetic performed on floating point types follows the IEEE standard. Integer types are not converted to floating point types automatically and vice versa.

The IEEE standard defines five types of floating-point exceptions:

\begin{itemize}\item Invalid: operations with mathematically invalid operands, for example 0.0/0.0, sqrt(-1.0), and log(-37.8).
\item Division by zero: divisor is zero and dividend is a finite nonzero number, for example 1.0/0.0.
\item Overflow: operation produces a result that exceeds the range of the exponent, for example MAXDOUBLE+0.0000000000001e308.
\item Underflow: operation produces a result that is too small to be represented as a normal number, for example, MINDOUBLE * MINDOUBLE.
\item Inexact: operation produces a result that cannot be represented with infinite precision, for example, 2.0 / 3.0, log(1.1) and 0.1 in input.
\end{itemize}
The IEEE exceptions are either ignored during execution or mapped to the Nim exceptions: FloatInvalidOpDefect\label{floatinvalidopdefect_1}, FloatDivByZeroDefect\label{floatdivbyzerodefect_1}, FloatOverflowDefect\label{floatoverflowdefect_1}, FloatUnderflowDefect\label{floatunderflowdefect_1}, and FloatInexactDefect\label{floatinexactdefect_1}. These exceptions inherit from the FloatingPointDefect\label{floatingpointdefect_1} base class.

Nim provides the pragmas nanChecks\label{nanchecks_1} and infChecks\label{infchecks_1} to control whether the IEEE exceptions are ignored or trap a Nim exception:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{nanChecks}\spanPunctuation{:} \spanIdentifier{on}\spanPunctuation{,} \spanIdentifier{infChecks}\spanPunctuation{:} \spanIdentifier{on}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{var} \spanIdentifier{a} \spanOperator{=} \spanFloatNumber{1.0}
\spanKeyword{var} \spanIdentifier{b} \spanOperator{=} \spanFloatNumber{0.0}
\spanIdentifier{echo} \spanIdentifier{b} \spanOperator{/} \spanIdentifier{b} \spanComment{\# raises FloatInvalidOpDefect}
\spanIdentifier{echo} \spanIdentifier{a} \spanOperator{/} \spanIdentifier{b} \spanComment{\# raises FloatOverflowDefect}
\end{rstpre}
In the current implementation \texttt{FloatDivByZeroDefect} and \texttt{FloatInexactDefect} are never raised. \texttt{FloatOverflowDefect} is raised instead of \texttt{FloatDivByZeroDefect}. There is also a floatChecks\label{floatchecks_1} pragma that is a short-cut for the combination of \texttt{nanChecks} and \texttt{infChecks} pragmas. \texttt{floatChecks} are turned off as default.

The only operations that are affected by the \texttt{floatChecks} pragma are the \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/} operators for floating point types.

An implementation should always use the maximum precision available to evaluate floating pointer values during semantic analysis; this means expressions like \texttt{0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64} that are evaluating during constant folding are true.

\rsthB{Boolean type}\label{types-boolean-type}
The boolean type is named bool\label{bool_1} in Nim and can be one of the two pre-defined values \texttt{true} and \texttt{false}. Conditions in \texttt{while}, \texttt{if}, \texttt{elif}, \texttt{when}-statements need to be of type \texttt{bool}.

This condition holds:\begin{rstpre}

ord(false) == 0 and ord(true) == 1
\end{rstpre}


The operators \texttt{not, and, or, xor, <, <=, >, >=, !=, ==} are defined for the bool type. The \texttt{and} and \texttt{or} operators perform short-cut evaluation. Example:

\begin{rstpre}
\spanKeyword{while} \spanIdentifier{p} \spanOperator{!=} \spanKeyword{nil} \spanKeyword{and} \spanIdentifier{p}\spanOperator{.}\spanIdentifier{name} \spanOperator{!=} \spanStringLit{"xyz"}\spanPunctuation{:}
  \spanComment{\# p.name is not evaluated if p == nil}
  \spanIdentifier{p} \spanOperator{=} \spanIdentifier{p}\spanOperator{.}\spanIdentifier{next}
\end{rstpre}
The size of the bool type is one byte.

\rsthB{Character type}\label{types-character-type}
The character type is named \texttt{char} in Nim. Its size is one byte. Thus it cannot represent an UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can support \texttt{array\symbol{91}char, int\symbol{93}} or \texttt{set\symbol{91}char\symbol{93}} efficiently as many algorithms rely on this feature. The \texttt{Rune} type is used for Unicode characters, it can represent any Unicode character. \texttt{Rune} is declared in the \href{unicode.html}{unicode module}.

\rsthB{Enumeration types}\label{types-enumeration-types}
Enumeration types define a new type whose values consist of the ones specified. The values are ordered. Example:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Direction} \spanOperator{=} \spanKeyword{enum}
    \spanIdentifier{north}\spanPunctuation{,} \spanIdentifier{east}\spanPunctuation{,} \spanIdentifier{south}\spanPunctuation{,} \spanIdentifier{west}
\end{rstpre}
Now the following holds:\begin{rstpre}

ord(north) == 0
ord(east) == 1
ord(south) == 2
ord(west) == 3

\# Also allowed:
ord(Direction.west) == 3
\end{rstpre}


Thus, north < east < south < west. The comparison operators can be used with enumeration types. Instead of \texttt{north} etc, the enum value can also be qualified with the enum type that it resides in, \texttt{Direction.north}.

For better interfacing to other programming languages, the fields of enum types can be assigned an explicit ordinal value. However, the ordinal values have to be in ascending order. A field whose ordinal value is not explicitly given is assigned the value of the previous field + 1.

An explicit ordered enum can have \emph{holes}:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{TokenType} \spanOperator{=} \spanKeyword{enum}
    \spanIdentifier{a} \spanOperator{=} \spanDecNumber{2}\spanPunctuation{,} \spanIdentifier{b} \spanOperator{=} \spanDecNumber{4}\spanPunctuation{,} \spanIdentifier{c} \spanOperator{=} \spanDecNumber{89} \spanComment{\# holes are valid}
\end{rstpre}
However, it is then not an ordinal anymore, so it is not possible to use these enums as an index type for arrays. The procedures \texttt{inc}, \texttt{dec}, \texttt{succ} and \texttt{pred} are not available for them either.

The compiler supports the built-in stringify operator \texttt{\$} for enumerations. The stringify's result can be controlled by explicitly giving the string values to use:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{MyEnum} \spanOperator{=} \spanKeyword{enum}
    \spanIdentifier{valueA} \spanOperator{=} \spanPunctuation{(}\spanDecNumber{0}\spanPunctuation{,} \spanStringLit{"my value A"}\spanPunctuation{)}\spanPunctuation{,}
    \spanIdentifier{valueB} \spanOperator{=} \spanStringLit{"value B"}\spanPunctuation{,}
    \spanIdentifier{valueC} \spanOperator{=} \spanDecNumber{2}\spanPunctuation{,}
    \spanIdentifier{valueD} \spanOperator{=} \spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{,} \spanStringLit{"abc"}\spanPunctuation{)}
\end{rstpre}
As can be seen from the example, it is possible to both specify a field's ordinal value and its string value by using a tuple. It is also possible to only specify one of them.

An enum can be marked with the \texttt{pure} pragma so that it's fields are added to a special module specific hidden scope that is only queried as the last attempt. Only non-ambiguous symbols are added to this scope. But one can always access these via type qualification written as \texttt{MyEnum.value}:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{MyEnum} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pure}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{enum}
    \spanIdentifier{valueA}\spanPunctuation{,} \spanIdentifier{valueB}\spanPunctuation{,} \spanIdentifier{valueC}\spanPunctuation{,} \spanIdentifier{valueD}\spanPunctuation{,} \spanIdentifier{amb}
  
  \spanIdentifier{OtherEnum} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pure}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{enum}
    \spanIdentifier{valueX}\spanPunctuation{,} \spanIdentifier{valueY}\spanPunctuation{,} \spanIdentifier{valueZ}\spanPunctuation{,} \spanIdentifier{amb}


\spanIdentifier{echo} \spanIdentifier{valueA} \spanComment{\# MyEnum.valueA}
\spanIdentifier{echo} \spanIdentifier{amb}    \spanComment{\# Error: Unclear whether it's MyEnum.amb or OtherEnum.amb}
\spanIdentifier{echo} \spanIdentifier{MyEnum}\spanOperator{.}\spanIdentifier{amb} \spanComment{\# OK.}
\end{rstpre}
To implement bit fields with enums see \href{\#set-type-bit-fields}{Bit fields}

\rsthB{String type}\label{types-string-type}
All string literals are of the type \texttt{string}. A string in Nim is very similar to a sequence of characters. However, strings in Nim are both zero-terminated and have a length field. One can retrieve the length with the builtin \texttt{len} procedure; the length never counts the terminating zero.

The terminating zero cannot be accessed unless the string is converted to the \texttt{cstring} type first. The terminating zero assures that this conversion can be done in O(1) and without any allocations.

The assignment operator for strings always copies the string. The \texttt{\&} operator concatenates strings.

Most native Nim types support conversion to strings with the special \texttt{\$} proc. When calling the \texttt{echo} proc, for example, the built-in stringify operation for the parameter is called:

\begin{rstpre}
\spanIdentifier{echo} \spanDecNumber{3} \spanComment{\# calls \symbol{96}\$\symbol{96} for \symbol{96}int\symbol{96}}
\end{rstpre}
Whenever a user creates a specialized object, implementation of this procedure provides for \texttt{string} representation.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Person} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{string}
    \spanIdentifier{age}\spanPunctuation{:} \spanIdentifier{int}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{\$}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{p}\spanPunctuation{:} \spanIdentifier{Person}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanComment{\# \symbol{96}\$\symbol{96} always returns a string}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{p}\spanOperator{.}\spanIdentifier{name} \spanOperator{\&} \spanStringLit{" is "} \spanOperator{\&}
          \spanOperator{\$}\spanIdentifier{p}\spanOperator{.}\spanIdentifier{age} \spanOperator{\&} \spanComment{\# we *need* the \symbol{96}\$\symbol{96} in front of p.age which}
                   \spanComment{\# is natively an integer to convert it to}
                   \spanComment{\# a string}
          \spanStringLit{" years old."}
\end{rstpre}
While \texttt{\$p.name} can also be used, the \texttt{\$} operation on a string does nothing. Note that we cannot rely on automatic conversion from an \texttt{int} to a \texttt{string} like we can for the \texttt{echo} proc.

Strings are compared by their lexicographical order. All comparison operators are available. Strings can be indexed like arrays (lower bound is 0). Unlike arrays, they can be used in case statements:

\begin{rstpre}
\spanKeyword{case} \spanIdentifier{paramStr}\spanPunctuation{(}\spanIdentifier{i}\spanPunctuation{)}
\spanKeyword{of} \spanStringLit{"-v"}\spanPunctuation{:} \spanIdentifier{incl}\spanPunctuation{(}\spanIdentifier{options}\spanPunctuation{,} \spanIdentifier{optVerbose}\spanPunctuation{)}
\spanKeyword{of} \spanStringLit{"-h"}\spanPunctuation{,} \spanStringLit{"-?"}\spanPunctuation{:} \spanIdentifier{incl}\spanPunctuation{(}\spanIdentifier{options}\spanPunctuation{,} \spanIdentifier{optHelp}\spanPunctuation{)}
\spanKeyword{else}\spanPunctuation{:} \spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{"invalid command line option!}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"}\spanPunctuation{)}
\end{rstpre}
Per convention, all strings are UTF-8 strings, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation \texttt{s\symbol{91}i\symbol{93}} means the i-th \emph{char} of \texttt{s}, not the i-th \emph{unichar}. The iterator \texttt{runes} from the \href{unicode.html}{unicode module} can be used for iteration over all Unicode characters.

\rsthB{cstring type}\label{types-cstring-type}
The \texttt{cstring} type meaning \texttt{compatible string} is the native representation of a string for the compilation backend. For the C backend the \texttt{cstring} type represents a pointer to a zero-terminated char array compatible to the type \texttt{char*} in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation \texttt{s\symbol{91}i\symbol{93}} means the i-th \emph{char} of \texttt{s}; however no bounds checking for \texttt{cstring} is performed making the index operation unsafe.

A Nim \texttt{string} is implicitly convertible to \texttt{cstring} for convenience. If a Nim string is passed to a C-style variadic proc, it is implicitly converted to \texttt{cstring} too:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{printf}\spanPunctuation{(}\spanIdentifier{formatstr}\spanPunctuation{:} \spanIdentifier{cstring}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importc}\spanPunctuation{:} \spanStringLit{"printf"}\spanPunctuation{,} \spanIdentifier{varargs}\spanPunctuation{,}
                                  \spanIdentifier{header}\spanPunctuation{:} \spanStringLit{"<stdio.h>"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanIdentifier{printf}\spanPunctuation{(}\spanStringLit{"This works \%s"}\spanPunctuation{,} \spanStringLit{"as expected"}\spanPunctuation{)}
\end{rstpre}
Even though the conversion is implicit, it is not \emph{safe}: The garbage collector does not consider a \texttt{cstring} to be a root and may collect the underlying memory. However in practice this almost never happens as the GC considers stack roots conservatively. One can use the builtin procs \texttt{GC\_ref} and \texttt{GC\_unref} to keep the string data alive for the rare cases where it does not work.

A \texttt{\$} proc is defined for cstrings that returns a string. Thus to get a nim string from a cstring:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{str}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanStringLit{"Hello!"}
\spanKeyword{var} \spanIdentifier{cstr}\spanPunctuation{:} \spanIdentifier{cstring} \spanOperator{=} \spanIdentifier{str}
\spanKeyword{var} \spanIdentifier{newstr}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanOperator{\$}\spanIdentifier{cstr}
\end{rstpre}
\rsthB{Structured types}\label{types-structured-types}
A variable of a structured type can hold multiple values at the same time. Structured types can be nested to unlimited levels. Arrays, sequences, tuples, objects and sets belong to the structured types.

\rsthB{Array and sequence types}\label{types-array-and-sequence-types}
Arrays are a homogeneous type, meaning that each element in the array has the same type. Arrays always have a fixed length specified as a constant expression (except for open arrays). They can be indexed by any ordinal type. A parameter \texttt{A} may be an \emph{open array}, in which case it is indexed by integers from 0 to \texttt{len(A)-1}. An array expression may be constructed by the array constructor \texttt{\symbol{91}\symbol{93}}. The element type of this array expression is inferred from the type of the first element. All other elements need to be implicitly convertible to this type.

An array type can be defined using the \texttt{array\symbol{91}size, T\symbol{93}} syntax, or using \texttt{array\symbol{91}lo..hi, T\symbol{93}} for arrays that start at an index other than zero.

Sequences are similar to arrays but of dynamic length which may change during runtime (like strings). Sequences are implemented as growable arrays, allocating pieces of memory as items are added. A sequence \texttt{S} is always indexed by integers from 0 to \texttt{len(S)-1} and its bounds are checked. Sequences can be constructed by the array constructor \texttt{\symbol{91}\symbol{93}} in conjunction with the array to sequence operator \texttt{\symbol{64}}. Another way to allocate space for a sequence is to call the built-in \texttt{newSeq} procedure.

A sequence may be passed to a parameter that is of type \emph{open array}.

Example:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{IntArray} \spanOperator{=} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{5}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{\symbol{93}} \spanComment{\# an array that is indexed with 0..5}
  \spanIdentifier{IntSeq} \spanOperator{=} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}} \spanComment{\# a sequence of integers}
\spanKeyword{var}
  \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{IntArray}
  \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{IntSeq}
\spanIdentifier{x} \spanOperator{=} \spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{,} \spanDecNumber{5}\spanPunctuation{,} \spanDecNumber{6}\spanPunctuation{\symbol{93}}  \spanComment{\# \symbol{91}\symbol{93} is the array constructor}
\spanIdentifier{y} \spanOperator{=} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{,} \spanDecNumber{5}\spanPunctuation{,} \spanDecNumber{6}\spanPunctuation{\symbol{93}} \spanComment{\# the \symbol{64} turns the array into a sequence}

\spanKeyword{let} \spanIdentifier{z} \spanOperator{=} \spanPunctuation{\symbol{91}}\spanFloatNumber{1.0}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{\symbol{93}} \spanComment{\# the type of z is array\symbol{91}0..3, float\symbol{93}}
\end{rstpre}
The lower bound of an array or sequence may be received by the built-in proc \texttt{low()}, the higher bound by \texttt{high()}. The length may be received by \texttt{len()}. \texttt{low()} for a sequence or an open array always returns 0, as this is the first valid index. One can append elements to a sequence with the \texttt{add()} proc or the \texttt{\&} operator, and remove (and get) the last element of a sequence with the \texttt{pop()} proc.

The notation \texttt{x\symbol{91}i\symbol{93}} can be used to access the i-th element of \texttt{x}.

Arrays are always bounds checked (statically or at runtime). These checks can be disabled via pragmas or invoking the compiler with the \texttt{--boundChecks:off} command line switch.

An array constructor can have explicit indexes for readability:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Values} \spanOperator{=} \spanKeyword{enum}
    \spanIdentifier{valA}\spanPunctuation{,} \spanIdentifier{valB}\spanPunctuation{,} \spanIdentifier{valC}

\spanKeyword{const}
  \spanIdentifier{lookupTable} \spanOperator{=} \spanPunctuation{\symbol{91}}
    \spanIdentifier{valA}\spanPunctuation{:} \spanStringLit{"A"}\spanPunctuation{,}
    \spanIdentifier{valB}\spanPunctuation{:} \spanStringLit{"B"}\spanPunctuation{,}
    \spanIdentifier{valC}\spanPunctuation{:} \spanStringLit{"C"}
  \spanPunctuation{\symbol{93}}
\end{rstpre}
If an index is left out, \texttt{succ(lastIndex)} is used as the index value:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Values} \spanOperator{=} \spanKeyword{enum}
    \spanIdentifier{valA}\spanPunctuation{,} \spanIdentifier{valB}\spanPunctuation{,} \spanIdentifier{valC}\spanPunctuation{,} \spanIdentifier{valD}\spanPunctuation{,} \spanIdentifier{valE}

\spanKeyword{const}
  \spanIdentifier{lookupTable} \spanOperator{=} \spanPunctuation{\symbol{91}}
    \spanIdentifier{valA}\spanPunctuation{:} \spanStringLit{"A"}\spanPunctuation{,}
    \spanStringLit{"B"}\spanPunctuation{,}
    \spanIdentifier{valC}\spanPunctuation{:} \spanStringLit{"C"}\spanPunctuation{,}
    \spanStringLit{"D"}\spanPunctuation{,} \spanStringLit{"e"}
  \spanPunctuation{\symbol{93}}
\end{rstpre}
\rsthB{Open arrays}\label{types-open-arrays}
Often fixed size arrays turn out to be too inflexible; procedures should be able to deal with arrays of different sizes. The openarray\label{openarray_1} type allows this; it can only be used for parameters. Openarrays are always indexed with an \texttt{int} starting at position 0. The \texttt{len}, \texttt{low} and \texttt{high} operations are available for open arrays too. Any array with a compatible base type can be passed to an openarray parameter, the index type does not matter. In addition to arrays sequences can also be passed to an open array parameter.

The openarray type cannot be nested: multidimensional openarrays are not supported because this is seldom needed and cannot be done efficiently.

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{testOpenArray}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{openArray}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanIdentifier{repr}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}

\spanIdentifier{testOpenArray}\spanPunctuation{(}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,}\spanDecNumber{2}\spanPunctuation{,}\spanDecNumber{3}\spanPunctuation{\symbol{93}}\spanPunctuation{)}  \spanComment{\# array\symbol{91}\symbol{93}}
\spanIdentifier{testOpenArray}\spanPunctuation{(}\spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,}\spanDecNumber{2}\spanPunctuation{,}\spanDecNumber{3}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanComment{\# seq\symbol{91}\symbol{93}}
\end{rstpre}
\rsthB{Varargs}\label{types-varargs}
A \texttt{varargs} parameter is an openarray parameter that additionally allows to pass a variable number of arguments to a procedure. The compiler converts the list of arguments to an array implicitly:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{myWriteln}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{File}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{s} \spanKeyword{in} \spanIdentifier{items}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}\spanPunctuation{:}
    \spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{)}
  \spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanStringLit{"}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"}\spanPunctuation{)}

\spanIdentifier{myWriteln}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{"abc"}\spanPunctuation{,} \spanStringLit{"def"}\spanPunctuation{,} \spanStringLit{"xyz"}\spanPunctuation{)}
\spanComment{\# is transformed to:}
\spanIdentifier{myWriteln}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanPunctuation{\symbol{91}}\spanStringLit{"abc"}\spanPunctuation{,} \spanStringLit{"def"}\spanPunctuation{,} \spanStringLit{"xyz"}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
This transformation is only done if the varargs parameter is the last parameter in the procedure header. It is also possible to perform type conversions in this context:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{myWriteln}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{File}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{,} \spanPunctuation{\symbol{96}}\spanOperator{\$}\spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{s} \spanKeyword{in} \spanIdentifier{items}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}\spanPunctuation{:}
    \spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{)}
  \spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanStringLit{"}\spanEscapeSequence{\symbol{92}n}\spanStringLit{"}\spanPunctuation{)}

\spanIdentifier{myWriteln}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanDecNumber{123}\spanPunctuation{,} \spanStringLit{"abc"}\spanPunctuation{,} \spanFloatNumber{4.0}\spanPunctuation{)}
\spanComment{\# is transformed to:}
\spanIdentifier{myWriteln}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanPunctuation{\symbol{91}}\spanOperator{\$}\spanDecNumber{123}\spanPunctuation{,} \spanOperator{\$}\spanStringLit{"def"}\spanPunctuation{,} \spanOperator{\$}\spanFloatNumber{4.0}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
In this example \texttt{\$} is applied to any argument that is passed to the parameter \texttt{a}. (Note that \texttt{\$} applied to strings is a nop.)

Note that an explicit array constructor passed to a \texttt{varargs} parameter is not wrapped in another implicit array construction:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{takeV}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}

\spanIdentifier{takeV}\spanPunctuation{(}\spanPunctuation{\symbol{91}}\spanDecNumber{123}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{1}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanComment{\# takeV's T is "int", not "array of int"}
\end{rstpre}
\texttt{varargs\symbol{91}typed\symbol{93}} is treated specially: It matches a variable list of arguments of arbitrary type but \emph{always} constructs an implicit array. This is required so that the builtin \texttt{echo} proc does what is expected:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{echo}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{typed}\spanPunctuation{,} \spanPunctuation{\symbol{96}}\spanOperator{\$}\spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{...}\spanPunctuation{\symbol{125}}

\spanIdentifier{echo} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{\symbol{93}}
\spanComment{\# prints "\symbol{64}\symbol{91}1, 2, 3\symbol{93}" and not "123"}
\end{rstpre}
\rsthB{Unchecked arrays}\label{types-unchecked-arrays}
The \texttt{UncheckedArray\symbol{91}T\symbol{93}} type is a special kind of \texttt{array} where its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally an unchecked array is translated into a C array of undetermined size:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{MySeq} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{len}\spanPunctuation{,} \spanIdentifier{cap}\spanPunctuation{:} \spanIdentifier{int}
    \spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{UncheckedArray}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}
\end{rstpre}
Produces roughly this C code:

\begin{rstpre}
\spanKeyword{typedef} \spanKeyword{struct} \spanPunctuation{\symbol{123}}
  \spanIdentifier{NI} \spanIdentifier{len}\spanPunctuation{;}
  \spanIdentifier{NI} \spanIdentifier{cap}\spanPunctuation{;}
  \spanIdentifier{NI} \spanIdentifier{data}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanPunctuation{;}
\spanPunctuation{\symbol{125}} \spanIdentifier{MySeq}\spanPunctuation{;}
\end{rstpre}
The base type of the unchecked array may not contain any GC'ed memory but this is currently not checked.

\textbf{Future directions}: GC'ed memory should be allowed in unchecked arrays and there should be an explicit annotation of how the GC is to determine the runtime size of the array.

\rsthB{Tuples and object types}\label{types-tuples-and-object-types}
A variable of a tuple or object type is a heterogeneous storage container. A tuple or object defines various named \emph{fields} of a type. A tuple also defines a lexicographic \emph{order} of the fields. Tuples are meant to be heterogeneous storage types with few abstractions. The \texttt{()} syntax can be used to construct tuples. The order of the fields in the constructor must match the order of the tuple's definition. Different tuple-types are \emph{equivalent} if they specify the same fields of the same type in the same order. The \emph{names} of the fields also have to be identical.

The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described \href{manual\_experimental.html\#type-bound-operations}{here}.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Person} \spanOperator{=} \spanKeyword{tuple}\spanPunctuation{\symbol{91}}\spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{age}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{\symbol{93}} \spanComment{\# type representing a person:}
                                         \spanComment{\# a person consists of a name}
                                         \spanComment{\# and an age}
\spanKeyword{var}
  \spanIdentifier{person}\spanPunctuation{:} \spanIdentifier{Person}
\spanIdentifier{person} \spanOperator{=} \spanPunctuation{(}\spanIdentifier{name}\spanPunctuation{:} \spanStringLit{"Peter"}\spanPunctuation{,} \spanIdentifier{age}\spanPunctuation{:} \spanDecNumber{30}\spanPunctuation{)}
\spanIdentifier{echo} \spanIdentifier{person}\spanOperator{.}\spanIdentifier{name}
\spanComment{\# the same, but less readable:}
\spanIdentifier{person} \spanOperator{=} \spanPunctuation{(}\spanStringLit{"Peter"}\spanPunctuation{,} \spanDecNumber{30}\spanPunctuation{)}
\spanIdentifier{echo} \spanIdentifier{person}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}
\end{rstpre}
A tuple with one unnamed field can be constructed with the parentheses and a trailing comma:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{echoUnaryTuple}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanPunctuation{(}\spanIdentifier{int}\spanPunctuation{,}\spanPunctuation{)}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}

\spanIdentifier{echoUnaryTuple} \spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{,}\spanPunctuation{)}
\end{rstpre}
In fact, a trailing comma is allowed for every tuple construction.

The implementation aligns the fields for best access performance. The alignment is compatible with the way the C compiler does it.

For consistency  with \texttt{object} declarations, tuples in a \texttt{type} section can also be defined with indentation instead of \texttt{\symbol{91}\symbol{93}}:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Person} \spanOperator{=} \spanKeyword{tuple}   \spanComment{\# type representing a person}
    \spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{string}   \spanComment{\# a person consists of a name}
    \spanIdentifier{age}\spanPunctuation{:} \spanIdentifier{Natural}   \spanComment{\# and an age}
\end{rstpre}
Objects provide many features that tuples do not. Object provide inheritance and the ability to hide fields from other modules. Objects with inheritance enabled have information about their type at runtime, so that the \texttt{of} operator can be used to determine the object's type. The \texttt{of} operator is similar to the \texttt{instanceof} operator in Java.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Person} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{RootObj}
    \spanIdentifier{name}\spanOperator{*:} \spanIdentifier{string}   \spanComment{\# the * means that \symbol{96}name\symbol{96} is accessible from other modules}
    \spanIdentifier{age}\spanPunctuation{:} \spanIdentifier{int}        \spanComment{\# no * means that the field is hidden}
  
  \spanIdentifier{Student} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Person} \spanComment{\# a student is a person}
    \spanIdentifier{id}\spanPunctuation{:} \spanIdentifier{int}                      \spanComment{\# with an id field}

\spanKeyword{var}
  \spanIdentifier{student}\spanPunctuation{:} \spanIdentifier{Student}
  \spanIdentifier{person}\spanPunctuation{:} \spanIdentifier{Person}
\spanIdentifier{assert}\spanPunctuation{(}\spanIdentifier{student} \spanKeyword{of} \spanIdentifier{Student}\spanPunctuation{)} \spanComment{\# is true}
\spanIdentifier{assert}\spanPunctuation{(}\spanIdentifier{student} \spanKeyword{of} \spanIdentifier{Person}\spanPunctuation{)} \spanComment{\# also true}
\end{rstpre}
Object fields that should be visible from outside the defining module, have to be marked by \texttt{*}. In contrast to tuples, different object types are never \emph{equivalent}, they are nominal types whereas tuples are structural. Objects that have no ancestor are implicitly \texttt{final} and thus have no hidden type information. One can use the \texttt{inheritable} pragma to introduce new object roots apart from \texttt{system.RootObj}.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Person} \spanOperator{=} \spanKeyword{object} \spanComment{\# example of a final object}
    \spanIdentifier{name}\spanOperator{*:} \spanIdentifier{string}
    \spanIdentifier{age}\spanPunctuation{:} \spanIdentifier{int}
  
  \spanIdentifier{Student} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Person} \spanComment{\# Error: inheritance only works with non-final objects}
    \spanIdentifier{id}\spanPunctuation{:} \spanIdentifier{int}
\end{rstpre}
\rsthB{Object construction}\label{types-object-construction}
Objects can also be created with an object construction expression\label{object-construction-expression_1} that has the syntax \texttt{T(fieldA: valueA, fieldB: valueB, ...)} where \texttt{T} is an \texttt{object} type or a \texttt{ref object} type:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{student} \spanOperator{=} \spanIdentifier{Student}\spanPunctuation{(}\spanIdentifier{name}\spanPunctuation{:} \spanStringLit{"Anton"}\spanPunctuation{,} \spanIdentifier{age}\spanPunctuation{:} \spanDecNumber{5}\spanPunctuation{,} \spanIdentifier{id}\spanPunctuation{:} \spanDecNumber{3}\spanPunctuation{)}
\end{rstpre}
Note that, unlike tuples, objects require the field names along with their values. For a \texttt{ref object} type \texttt{system.new} is invoked implicitly.

\rsthB{Object variants}\label{types-object-variants}
Often an object hierarchy is overkill in certain situations where simple variant types are needed. Object variants are tagged unions discriminated via a enumerated type used for runtime type flexibility, mirroring the concepts of \emph{sum types} and \emph{algebraic data types (ADTs)} as found in other languages.

An example:

\begin{rstpre}
\spanComment{\# This is an example how an abstract syntax tree could be modelled in Nim}
\spanKeyword{type}
  \spanIdentifier{NodeKind} \spanOperator{=} \spanKeyword{enum}  \spanComment{\# the different node types}
    \spanIdentifier{nkInt}\spanPunctuation{,}          \spanComment{\# a leaf with an integer value}
    \spanIdentifier{nkFloat}\spanPunctuation{,}        \spanComment{\# a leaf with a float value}
    \spanIdentifier{nkString}\spanPunctuation{,}       \spanComment{\# a leaf with a string value}
    \spanIdentifier{nkAdd}\spanPunctuation{,}          \spanComment{\# an addition}
    \spanIdentifier{nkSub}\spanPunctuation{,}          \spanComment{\# a subtraction}
    \spanIdentifier{nkIf}            \spanComment{\# an if statement}
  \spanIdentifier{Node} \spanOperator{=} \spanKeyword{ref} \spanIdentifier{NodeObj}
  \spanIdentifier{NodeObj} \spanOperator{=} \spanKeyword{object}
    \spanKeyword{case} \spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{NodeKind}  \spanComment{\# the \symbol{96}\symbol{96}kind\symbol{96}\symbol{96} field is the discriminator}
    \spanKeyword{of} \spanIdentifier{nkInt}\spanPunctuation{:} \spanIdentifier{intVal}\spanPunctuation{:} \spanIdentifier{int}
    \spanKeyword{of} \spanIdentifier{nkFloat}\spanPunctuation{:} \spanIdentifier{floatVal}\spanPunctuation{:} \spanIdentifier{float}
    \spanKeyword{of} \spanIdentifier{nkString}\spanPunctuation{:} \spanIdentifier{strVal}\spanPunctuation{:} \spanIdentifier{string}
    \spanKeyword{of} \spanIdentifier{nkAdd}\spanPunctuation{,} \spanIdentifier{nkSub}\spanPunctuation{:}
      \spanIdentifier{leftOp}\spanPunctuation{,} \spanIdentifier{rightOp}\spanPunctuation{:} \spanIdentifier{Node}
    \spanKeyword{of} \spanIdentifier{nkIf}\spanPunctuation{:}
      \spanIdentifier{condition}\spanPunctuation{,} \spanIdentifier{thenPart}\spanPunctuation{,} \spanIdentifier{elsePart}\spanPunctuation{:} \spanIdentifier{Node}

\spanComment{\# create a new case object:}
\spanKeyword{var} \spanIdentifier{n} \spanOperator{=} \spanIdentifier{Node}\spanPunctuation{(}\spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{nkIf}\spanPunctuation{,} \spanIdentifier{condition}\spanPunctuation{:} \spanKeyword{nil}\spanPunctuation{)}
\spanComment{\# accessing n.thenPart is valid because the \symbol{96}\symbol{96}nkIf\symbol{96}\symbol{96} branch is active:}
\spanIdentifier{n}\spanOperator{.}\spanIdentifier{thenPart} \spanOperator{=} \spanIdentifier{Node}\spanPunctuation{(}\spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{nkFloat}\spanPunctuation{,} \spanIdentifier{floatVal}\spanPunctuation{:} \spanFloatNumber{2.0}\spanPunctuation{)}

\spanComment{\# the following statement raises an \symbol{96}FieldDefect\symbol{96} exception, because}
\spanComment{\# n.kind's value does not fit and the \symbol{96}\symbol{96}nkString\symbol{96}\symbol{96} branch is not active:}
\spanIdentifier{n}\spanOperator{.}\spanIdentifier{strVal} \spanOperator{=} \spanStringLit{""}

\spanComment{\# invalid: would change the active object branch:}
\spanIdentifier{n}\spanOperator{.}\spanIdentifier{kind} \spanOperator{=} \spanIdentifier{nkInt}

\spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{Node}\spanPunctuation{(}\spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{nkAdd}\spanPunctuation{,} \spanIdentifier{leftOp}\spanPunctuation{:} \spanIdentifier{Node}\spanPunctuation{(}\spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{nkInt}\spanPunctuation{,} \spanIdentifier{intVal}\spanPunctuation{:} \spanDecNumber{4}\spanPunctuation{)}\spanPunctuation{,}
                          \spanIdentifier{rightOp}\spanPunctuation{:} \spanIdentifier{Node}\spanPunctuation{(}\spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{nkInt}\spanPunctuation{,} \spanIdentifier{intVal}\spanPunctuation{:} \spanDecNumber{2}\spanPunctuation{)}\spanPunctuation{)}
\spanComment{\# valid: does not change the active object branch:}
\spanIdentifier{x}\spanOperator{.}\spanIdentifier{kind} \spanOperator{=} \spanIdentifier{nkSub}
\end{rstpre}
As can been seen from the example, an advantage to an object hierarchy is that no casting between different object types is needed. Yet, access to invalid object fields raises an exception.

The syntax of \texttt{case} in an object declaration follows closely the syntax of the \texttt{case} statement: The branches in a \texttt{case} section may be indented too.

In the example the \texttt{kind} field is called the discriminator\label{discriminator_1}: For safety its address cannot be taken and assignments to it are restricted: The new value must not lead to a change of the active object branch. Also, when the fields of a particular branch are specified during object construction, the corresponding discriminator value must be specified as a constant expression.

Instead of changing the active object branch, replace the old object in memory with a new one completely:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{Node}\spanPunctuation{(}\spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{nkAdd}\spanPunctuation{,} \spanIdentifier{leftOp}\spanPunctuation{:} \spanIdentifier{Node}\spanPunctuation{(}\spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{nkInt}\spanPunctuation{,} \spanIdentifier{intVal}\spanPunctuation{:} \spanDecNumber{4}\spanPunctuation{)}\spanPunctuation{,}
                          \spanIdentifier{rightOp}\spanPunctuation{:} \spanIdentifier{Node}\spanPunctuation{(}\spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{nkInt}\spanPunctuation{,} \spanIdentifier{intVal}\spanPunctuation{:} \spanDecNumber{2}\spanPunctuation{)}\spanPunctuation{)}
\spanComment{\# change the node's contents:}
\spanIdentifier{x}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{NodeObj}\spanPunctuation{(}\spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{nkString}\spanPunctuation{,} \spanIdentifier{strVal}\spanPunctuation{:} \spanStringLit{"abc"}\spanPunctuation{)}
\end{rstpre}
Starting with version 0.20 \texttt{system.reset} cannot be used anymore to support object branch changes as this never was completely memory safe.

As a special rule, the discriminator kind can also be bounded using a \texttt{case} statement. If possible values of the discriminator variable in a \texttt{case} statement branch are a subset of discriminator values for the selected object branch, the initialization is considered valid. This analysis only works for immutable discriminators of an ordinal type and disregards \texttt{elif} branches. For discriminator values with a \texttt{range} type, the compiler checks if the entire range of possible values for the discriminator value is valid for the chosen object branch.

A small example:

\begin{rstpre}
\spanKeyword{let} \spanIdentifier{unknownKind} \spanOperator{=} \spanIdentifier{nkSub}

\spanComment{\# invalid: unsafe initialization because the kind field is not statically known:}
\spanKeyword{var} \spanIdentifier{y} \spanOperator{=} \spanIdentifier{Node}\spanPunctuation{(}\spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{unknownKind}\spanPunctuation{,} \spanIdentifier{strVal}\spanPunctuation{:} \spanStringLit{"y"}\spanPunctuation{)}

\spanKeyword{var} \spanIdentifier{z} \spanOperator{=} \spanIdentifier{Node}\spanPunctuation{(}\spanPunctuation{)}
\spanKeyword{case} \spanIdentifier{unknownKind}
\spanKeyword{of} \spanIdentifier{nkAdd}\spanPunctuation{,} \spanIdentifier{nkSub}\spanPunctuation{:}
  \spanComment{\# valid: possible values of this branch are a subset of nkAdd/nkSub object branch:}
  \spanIdentifier{z} \spanOperator{=} \spanIdentifier{Node}\spanPunctuation{(}\spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{unknownKind}\spanPunctuation{,} \spanIdentifier{leftOp}\spanPunctuation{:} \spanIdentifier{Node}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{rightOp}\spanPunctuation{:} \spanIdentifier{Node}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{)}
\spanKeyword{else}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"ignoring: "}\spanPunctuation{,} \spanIdentifier{unknownKind}

\spanComment{\# also valid, since unknownKindBounded can only contain the values nkAdd or nkSub}
\spanKeyword{let} \spanIdentifier{unknownKindBounded} \spanOperator{=} \spanIdentifier{range}\spanPunctuation{\symbol{91}}\spanIdentifier{nkAdd}\spanOperator{..}\spanIdentifier{nkSub}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{unknownKind}\spanPunctuation{)}
\spanIdentifier{z} \spanOperator{=} \spanIdentifier{Node}\spanPunctuation{(}\spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{unknownKindBounded}\spanPunctuation{,} \spanIdentifier{leftOp}\spanPunctuation{:} \spanIdentifier{Node}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{rightOp}\spanPunctuation{:} \spanIdentifier{Node}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{)}
\end{rstpre}
\rsthB{Set type}\label{types-set-type}
The set type models the mathematical notion of a set. The set's basetype can only be an ordinal type of a certain size, namely:\begin{itemize}\item \texttt{int8}-\texttt{int16}
\item \texttt{uint8}/\texttt{byte}-\texttt{uint16}
\item \texttt{char}
\item \texttt{enum}
\end{itemize}
or equivalent. For signed integers the set's base type is defined to be in the range \texttt{0 .. MaxSetElements-1} where \texttt{MaxSetElements} is currently always 2\symbol{94}16.

The reason is that sets are implemented as high performance bit vectors. Attempting to declare a set with a larger type will result in an error:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{set}\spanPunctuation{\symbol{91}}\spanIdentifier{int64}\spanPunctuation{\symbol{93}} \spanComment{\# Error: set is too large}
\end{rstpre}
Sets can be constructed via the set constructor: \texttt{\symbol{123}\symbol{125}} is the empty set. The empty set is type compatible with any concrete set type. The constructor can also be used to include elements (and ranges of elements):

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{CharSet} \spanOperator{=} \spanIdentifier{set}\spanPunctuation{\symbol{91}}\spanIdentifier{char}\spanPunctuation{\symbol{93}}
\spanKeyword{var}
  \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{CharSet}
\spanIdentifier{x} \spanOperator{=} \spanPunctuation{\symbol{123}}\spanCharLit{'a'}\spanOperator{..}\spanCharLit{'z'}\spanPunctuation{,} \spanCharLit{'0'}\spanOperator{..}\spanCharLit{'9'}\spanPunctuation{\symbol{125}} \spanComment{\# This constructs a set that contains the}
                         \spanComment{\# letters from 'a' to 'z' and the digits}
                         \spanComment{\# from '0' to '9'}
\end{rstpre}
These operations are supported by sets:

\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|X|X|X|X|X|X|}
\hline
\textbf{operation} & \textbf{meaning}\\
\hline
\texttt{A + B} & union of two sets\\
\hline
\texttt{A * B} & intersection of two sets\\
\hline
\texttt{A - B} & difference of two sets (A without B's elements)\\
\hline
\texttt{A == B} & set equality\\
\hline
\texttt{A <= B} & subset relation (A is subset of B or equal to B)\\
\hline
\texttt{A < B} & strict subset relation (A is a proper subset of B)\\
\hline
\texttt{e in A} & set membership (A contains element e)\\
\hline
\texttt{e notin A} & A does not contain element e\\
\hline
\texttt{contains(A, e)} & A contains element e\\
\hline
\texttt{card(A)} & the cardinality of A (number of elements in A)\\
\hline
\texttt{incl(A, elem)} & same as \texttt{A = A + \symbol{123}elem\symbol{125}}\\
\hline
\texttt{excl(A, elem)} & same as \texttt{A = A - \symbol{123}elem\symbol{125}}\\
\hline
\end{rsttab}\end{table}\rsthC{Bit fields}\label{set-type-bit-fields}
Sets are often used to define a type for the \emph{flags} of a procedure. This is a cleaner (and type safe) solution than defining integer constants that have to be \texttt{or}'ed together.

Enum, sets and casting can be used together as in:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{MyFlag}\spanOperator{*} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{size}\spanPunctuation{:} \spanIdentifier{sizeof}\spanPunctuation{(}\spanIdentifier{cint}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{enum}
    \spanIdentifier{A}
    \spanIdentifier{B}
    \spanIdentifier{C}
    \spanIdentifier{D}
  \spanIdentifier{MyFlags} \spanOperator{=} \spanIdentifier{set}\spanPunctuation{\symbol{91}}\spanIdentifier{MyFlag}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanIdentifier{toNum}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{MyFlags}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanKeyword{cast}\spanPunctuation{\symbol{91}}\spanIdentifier{cint}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{)}
\spanKeyword{proc} \spanIdentifier{toFlags}\spanPunctuation{(}\spanIdentifier{v}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{MyFlags} \spanOperator{=} \spanKeyword{cast}\spanPunctuation{\symbol{91}}\spanIdentifier{MyFlags}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{v}\spanPunctuation{)}

\spanIdentifier{assert} \spanIdentifier{toNum}\spanPunctuation{(}\spanPunctuation{\symbol{123}}\spanPunctuation{\symbol{125}}\spanPunctuation{)} \spanOperator{==} \spanDecNumber{0}
\spanIdentifier{assert} \spanIdentifier{toNum}\spanPunctuation{(}\spanPunctuation{\symbol{123}}\spanIdentifier{A}\spanPunctuation{\symbol{125}}\spanPunctuation{)} \spanOperator{==} \spanDecNumber{1}
\spanIdentifier{assert} \spanIdentifier{toNum}\spanPunctuation{(}\spanPunctuation{\symbol{123}}\spanIdentifier{D}\spanPunctuation{\symbol{125}}\spanPunctuation{)} \spanOperator{==} \spanDecNumber{8}
\spanIdentifier{assert} \spanIdentifier{toNum}\spanPunctuation{(}\spanPunctuation{\symbol{123}}\spanIdentifier{A}\spanPunctuation{,} \spanIdentifier{C}\spanPunctuation{\symbol{125}}\spanPunctuation{)} \spanOperator{==} \spanDecNumber{5}
\spanIdentifier{assert} \spanIdentifier{toFlags}\spanPunctuation{(}\spanDecNumber{0}\spanPunctuation{)} \spanOperator{==} \spanPunctuation{\symbol{123}}\spanPunctuation{\symbol{125}}
\spanIdentifier{assert} \spanIdentifier{toFlags}\spanPunctuation{(}\spanDecNumber{7}\spanPunctuation{)} \spanOperator{==} \spanPunctuation{\symbol{123}}\spanIdentifier{A}\spanPunctuation{,} \spanIdentifier{B}\spanPunctuation{,} \spanIdentifier{C}\spanPunctuation{\symbol{125}}
\end{rstpre}
Note how the set turns enum values into powers of 2.

If using enums and sets with C, use distinct cint.

For interoperability with C see also the \href{manual.html\#implementation-specific-pragmas-bitsize-pragma}{bitsize pragma}.

\rsthB{Reference and pointer types}\label{types-reference-and-pointer-types}
References (similar to pointers in other programming languages) are a way to introduce many-to-one relationships. This means different references can point to and modify the same location in memory (also called aliasing\label{aliasing_1}).

Nim distinguishes between traced\label{traced_1} and untraced\label{untraced_1} references. Untraced references are also called \emph{pointers}. Traced references point to objects of a garbage collected heap, untraced references point to manually allocated objects or to objects somewhere else in memory. Thus untraced references are \emph{unsafe}. However for certain low-level operations (accessing the hardware) untraced references are unavoidable.

Traced references are declared with the \textbf{ref} keyword, untraced references are declared with the \textbf{ptr} keyword.  In general, a \texttt{ptr T} is implicitly convertible to the \texttt{pointer} type.

An empty subscript \texttt{\symbol{91}\symbol{93}} notation can be used to derefer a reference, the \texttt{addr} procedure returns the address of an item. An address is always an untraced reference. Thus the usage of \texttt{addr} is an \emph{unsafe} feature.

The \texttt{.} (access a tuple/object field operator) and \texttt{\symbol{91}\symbol{93}} (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Node} \spanOperator{=} \spanKeyword{ref} \spanIdentifier{NodeObj}
  \spanIdentifier{NodeObj} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{le}\spanPunctuation{,} \spanIdentifier{ri}\spanPunctuation{:} \spanIdentifier{Node}
    \spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{int}

\spanKeyword{var}
  \spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{Node}
\spanIdentifier{new}\spanPunctuation{(}\spanIdentifier{n}\spanPunctuation{)}
\spanIdentifier{n}\spanOperator{.}\spanIdentifier{data} \spanOperator{=} \spanDecNumber{9}
\spanComment{\# no need to write n\symbol{91}\symbol{93}.data; in fact n\symbol{91}\symbol{93}.data is highly discouraged!}
\end{rstpre}
Automatic dereferencing can be performed for the first argument of a routine call, but this is an experimental feature and is described \href{manual\_experimental.html\#type-bound-operations}{here}.

In order to simplify structural type checking, recursive tuples are not valid:

\begin{rstpre}
\spanComment{\# invalid recursion}
\spanKeyword{type} \spanIdentifier{MyTuple} \spanOperator{=} \spanKeyword{tuple}\spanPunctuation{\symbol{91}}\spanIdentifier{a}\spanPunctuation{:} \spanKeyword{ref} \spanIdentifier{MyTuple}\spanPunctuation{\symbol{93}}
\end{rstpre}
Likewise \texttt{T = ref T} is an invalid type.

As a syntactical extension \texttt{object} types can be anonymous if declared in a type section via the \texttt{ref object} or \texttt{ptr object} notations. This feature is useful if an object should only gain reference semantics:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Node} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object}
    \spanIdentifier{le}\spanPunctuation{,} \spanIdentifier{ri}\spanPunctuation{:} \spanIdentifier{Node}
    \spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{int}
\end{rstpre}
To allocate a new traced object, the built-in procedure \texttt{new} has to be used. To deal with untraced memory, the procedures \texttt{alloc}, \texttt{dealloc} and \texttt{realloc} can be used. The documentation of the system module contains further information.

Nil ---

If a reference points to \emph{nothing}, it has the value \texttt{nil}. \texttt{nil} is the default value for all \texttt{ref} and \texttt{ptr} types. The \texttt{nil} value can also be used like any other literal value. For example, it can be used in an assignment like \texttt{myRef = nil}.

Dereferencing \texttt{nil} is an unrecoverable fatal runtime error (and not a panic).

A successful dereferencing operation \texttt{p\symbol{91}\symbol{93}} implies that \texttt{p} is not nil. This can be exploited by the implementation to optimize code like:

\begin{rstpre}
\spanIdentifier{p}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanIdentifier{field} \spanOperator{=} \spanDecNumber{3}
\spanKeyword{if} \spanIdentifier{p} \spanOperator{!=} \spanKeyword{nil}\spanPunctuation{:}
  \spanComment{\# if p were nil, \symbol{96}\symbol{96}p\symbol{91}\symbol{93}\symbol{96}\symbol{96} would have caused a crash already,}
  \spanComment{\# so we know \symbol{96}\symbol{96}p\symbol{96}\symbol{96} is always not nil here.}
  \spanIdentifier{action}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
Into:

\begin{rstpre}
\spanIdentifier{p}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanIdentifier{field} \spanOperator{=} \spanDecNumber{3}
\spanIdentifier{action}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
\emph{Note}: This is not comparable to C's "undefined behavior" for dereferencing NULL pointers.

\rsthB{Mixing GC'ed memory with \texttt{ptr}}\label{types-mixing-gc-ed-memory-with-ptr}
Special care has to be taken if an untraced object contains traced objects like traced references, strings or sequences: in order to free everything properly, the built-in procedure \texttt{reset} has to be called before freeing the untraced memory manually:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Data} \spanOperator{=} \spanKeyword{tuple}\spanPunctuation{\symbol{91}}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{\symbol{93}}

\spanComment{\# allocate memory for Data on the heap:}
\spanKeyword{var} \spanIdentifier{d} \spanOperator{=} \spanKeyword{cast}\spanPunctuation{\symbol{91}}\spanKeyword{ptr} \spanIdentifier{Data}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{alloc0}\spanPunctuation{(}\spanIdentifier{sizeof}\spanPunctuation{(}\spanIdentifier{Data}\spanPunctuation{)}\spanPunctuation{)}\spanPunctuation{)}

\spanComment{\# create a new string on the garbage collected heap:}
\spanIdentifier{d}\spanOperator{.}\spanIdentifier{s} \spanOperator{=} \spanStringLit{"abc"}

\spanComment{\# tell the GC that the string is not needed anymore:}
\spanIdentifier{reset}\spanPunctuation{(}\spanIdentifier{d}\spanOperator{.}\spanIdentifier{s}\spanPunctuation{)}

\spanComment{\# free the memory:}
\spanIdentifier{dealloc}\spanPunctuation{(}\spanIdentifier{d}\spanPunctuation{)}
\end{rstpre}
Without the \texttt{reset} call the memory allocated for the \texttt{d.s} string would never be freed. The example also demonstrates two important features for low level programming: the \texttt{sizeof} proc returns the size of a type or value in bytes. The \texttt{cast} operator can circumvent the type system: the compiler is forced to treat the result of the \texttt{alloc0} call (which returns an untyped pointer) as if it would have the type \texttt{ptr Data}. Casting should only be done if it is unavoidable: it breaks type safety and bugs can lead to mysterious crashes.

\textbf{Note}: The example only works because the memory is initialized to zero (\texttt{alloc0} instead of \texttt{alloc} does this): \texttt{d.s} is thus initialized to binary zero which the string assignment can handle. One needs to know low level details like this when mixing garbage collected data with unmanaged memory.

\rsthB{Procedural type}\label{types-procedural-type}
A procedural type is internally a pointer to a procedure. \texttt{nil} is an allowed value for variables of a procedural type. Nim uses procedural types to achieve functional\label{functional_1} programming techniques.

Examples:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{printItem}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}

\spanKeyword{proc} \spanIdentifier{forEach}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{:} \spanKeyword{proc} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{cdecl}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{)} \spanOperator{=}
  \spanOperator{...}

\spanIdentifier{forEach}\spanPunctuation{(}\spanIdentifier{printItem}\spanPunctuation{)}  \spanComment{\# this will NOT compile because calling conventions differ}
\end{rstpre}
\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{OnMouseMove} \spanOperator{=} \spanKeyword{proc} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{closure}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{proc} \spanIdentifier{onMouseMove}\spanPunctuation{(}\spanIdentifier{mouseX}\spanPunctuation{,} \spanIdentifier{mouseY}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# has default calling convention}
  \spanIdentifier{echo} \spanStringLit{"x: "}\spanPunctuation{,} \spanIdentifier{mouseX}\spanPunctuation{,} \spanStringLit{" y: "}\spanPunctuation{,} \spanIdentifier{mouseY}

\spanKeyword{proc} \spanIdentifier{setOnMouseMove}\spanPunctuation{(}\spanIdentifier{mouseMoveEvent}\spanPunctuation{:} \spanIdentifier{OnMouseMove}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}

\spanComment{\# ok, 'onMouseMove' has the default calling convention, which is compatible}
\spanComment{\# to 'closure':}
\spanIdentifier{setOnMouseMove}\spanPunctuation{(}\spanIdentifier{onMouseMove}\spanPunctuation{)}
\end{rstpre}
A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. As a special extension, a procedure of the calling convention \texttt{nimcall} can be passed to a parameter that expects a proc of the calling convention \texttt{closure}.

Nim supports these calling conventions\label{calling-conventions_1}:

\begin{description}\item[nimcall\label{nimcall_1}] is the default convention used for a Nim \textbf{proc}. It is the same as \texttt{fastcall}, but only for C compilers that support \texttt{fastcall}.
\item[closure\label{closure_1}] is the default calling convention for a \textbf{procedural type} that lacks any pragma annotations. It indicates that the procedure has a hidden implicit parameter (an \emph{environment}). Proc vars that have the calling convention \texttt{closure} take up two machine words: One for the proc pointer and another one for the pointer to implicitly passed environment.
\item[stdcall\label{stdcall_1}] This is the stdcall convention as specified by Microsoft. The generated C procedure is declared with the \texttt{\_\_stdcall} keyword.
\item[cdecl\label{cdecl_1}] The cdecl convention means that a procedure shall use the same convention as the C compiler. Under Windows the generated C procedure is declared with the \texttt{\_\_cdecl} keyword.
\item[safecall\label{safecall_1}] This is the safecall convention as specified by Microsoft. The generated C procedure is declared with the \texttt{\_\_safecall} keyword. The word \emph{safe} refers to the fact that all hardware registers shall be pushed to the hardware stack.
\item[inline\label{inline_1}] The inline convention means the the caller should not call the procedure, but inline its code directly. Note that Nim does not inline, but leaves this to the C compiler; it generates \texttt{\_\_inline} procedures. This is only a hint for the compiler: it may completely ignore it and it may inline procedures that are not marked as \texttt{inline}.
\item[fastcall\label{fastcall_1}] Fastcall means different things to different C compilers. One gets whatever the C \texttt{\_\_fastcall} means.
\item[thiscall\label{thiscall_1}] This is thiscall calling convention as specified by Microsoft, used on C++ class member functions on the x86 architecture
\item[syscall\label{syscall_1}] The syscall convention is the same as \texttt{\_\_syscall} in C. It is used for interrupts.
\item[noconv\label{noconv_1}] The generated C code will not have any explicit calling convention and thus use the C compiler's default calling convention. This is needed because Nim's default calling convention for procedures is \texttt{fastcall} to improve speed.
\end{description}
Most calling conventions exist only for the Windows 32-bit platform.

The default calling convention is \texttt{nimcall}, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention \texttt{closure}, otherwise it has the calling convention \texttt{nimcall}.

\rsthB{Distinct type}\label{types-distinct-type}
A \texttt{distinct} type is new type derived from a base type\label{base-type_1} that is incompatible with its base type. In particular, it is an essential property of a distinct type that it \textbf{does not} imply a subtype relation between it and its base type. Explicit type conversions from a distinct type to its base type and vice versa are allowed. See also \texttt{distinctBase} to get the reverse operation.

A distinct type is an ordinal type if its base type is an ordinal type.

\rsthC{Modelling currencies}\label{distinct-type-modelling-currencies}
A distinct type can be used to model different physical units\label{units_1} with a numerical base type, for example. The following example models currencies.

Different currencies should not be mixed in monetary calculations. Distinct types are a perfect tool to model different currencies:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Dollar} \spanOperator{=} \spanKeyword{distinct} \spanIdentifier{int}
  \spanIdentifier{Euro} \spanOperator{=} \spanKeyword{distinct} \spanIdentifier{int}

\spanKeyword{var}
  \spanIdentifier{d}\spanPunctuation{:} \spanIdentifier{Dollar}
  \spanIdentifier{e}\spanPunctuation{:} \spanIdentifier{Euro}

\spanIdentifier{echo} \spanIdentifier{d} \spanOperator{+} \spanDecNumber{12}
\spanComment{\# Error: cannot add a number with no unit and a \symbol{96}\symbol{96}Dollar\symbol{96}\symbol{96}}
\end{rstpre}
Unfortunately, \texttt{d + 12.Dollar} is not allowed either, because \texttt{+} is defined for \texttt{int} (among others), not for \texttt{Dollar}. So a \texttt{+} for dollars needs to be defined:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{+}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{Dollar}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Dollar} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{Dollar}\spanPunctuation{(}\spanIdentifier{int}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)} \spanOperator{+} \spanIdentifier{int}\spanPunctuation{(}\spanIdentifier{y}\spanPunctuation{)}\spanPunctuation{)}
\end{rstpre}
It does not make sense to multiply a dollar with a dollar, but with a number without unit; and the same holds for division:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{Dollar}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Dollar} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{Dollar}\spanPunctuation{(}\spanIdentifier{int}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)} \spanOperator{*} \spanIdentifier{y}\spanPunctuation{)}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{Dollar}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Dollar} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{Dollar}\spanPunctuation{(}\spanIdentifier{x} \spanOperator{*} \spanIdentifier{int}\spanPunctuation{(}\spanIdentifier{y}\spanPunctuation{)}\spanPunctuation{)}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanKeyword{div}\spanPunctuation{\symbol{96}} \spanOperator{...}
\end{rstpre}
This quickly gets tedious. The implementations are trivial and the compiler should not generate all this code only to optimize it away later - after all \texttt{+} for dollars should produce the same binary code as \texttt{+} for ints. The pragma borrow\label{borrow_1} has been designed to solve this problem; in principle it generates the above trivial implementations:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{Dollar}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Dollar} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{Dollar}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Dollar} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanKeyword{div}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{Dollar}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Dollar} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
The \texttt{borrow} pragma makes the compiler use the same implementation as the proc that deals with the distinct type's base type, so no code is generated.

But it seems all this boilerplate code needs to be repeated for the \texttt{Euro} currency. This can be solved with templates\ref{templates}.

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{additive}\spanPunctuation{(}\spanIdentifier{typ}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{+}\spanPunctuation{\symbol{96}} \spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{typ}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{typ} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}
  \spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{-}\spanPunctuation{\symbol{96}} \spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{typ}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{typ} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}
  
  \spanComment{\# unary operators:}
  \spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{+}\spanPunctuation{\symbol{96}} \spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{typ}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{typ} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}
  \spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{-}\spanPunctuation{\symbol{96}} \spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{typ}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{typ} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{template} \spanIdentifier{multiplicative}\spanPunctuation{(}\spanIdentifier{typ}\spanPunctuation{,} \spanIdentifier{base}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}} \spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{typ}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{base}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{typ} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}
  \spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}} \spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{base}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{typ}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{typ} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}
  \spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanKeyword{div}\spanPunctuation{\symbol{96}} \spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{typ}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{base}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{typ} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}
  \spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanKeyword{mod}\spanPunctuation{\symbol{96}} \spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{typ}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{base}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{typ} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{template} \spanIdentifier{comparable}\spanPunctuation{(}\spanIdentifier{typ}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{<}\spanPunctuation{\symbol{96}} \spanOperator{*} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{typ}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}
  \spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{<=}\spanPunctuation{\symbol{96}} \spanOperator{*} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{typ}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}
  \spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{==}\spanPunctuation{\symbol{96}} \spanOperator{*} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{typ}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{template} \spanIdentifier{defineCurrency}\spanPunctuation{(}\spanIdentifier{typ}\spanPunctuation{,} \spanIdentifier{base}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{type}
    \spanIdentifier{typ}\spanOperator{*} \spanOperator{=} \spanKeyword{distinct} \spanIdentifier{base}
  \spanIdentifier{additive}\spanPunctuation{(}\spanIdentifier{typ}\spanPunctuation{)}
  \spanIdentifier{multiplicative}\spanPunctuation{(}\spanIdentifier{typ}\spanPunctuation{,} \spanIdentifier{base}\spanPunctuation{)}
  \spanIdentifier{comparable}\spanPunctuation{(}\spanIdentifier{typ}\spanPunctuation{)}

\spanIdentifier{defineCurrency}\spanPunctuation{(}\spanIdentifier{Dollar}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{)}
\spanIdentifier{defineCurrency}\spanPunctuation{(}\spanIdentifier{Euro}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{)}
\end{rstpre}
The borrow pragma can also be used to annotate the distinct type to allow certain builtin operations to be lifted:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Foo} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}
    \spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}
  
  \spanIdentifier{Bar} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanPunctuation{:} \spanPunctuation{\symbol{96}}\spanOperator{.}\spanPunctuation{\symbol{96}}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{distinct} \spanIdentifier{Foo}

\spanKeyword{var} \spanIdentifier{bb}\spanPunctuation{:} \spanKeyword{ref} \spanIdentifier{Bar}
\spanIdentifier{new} \spanIdentifier{bb}
\spanComment{\# field access now valid}
\spanIdentifier{bb}\spanOperator{.}\spanIdentifier{a} \spanOperator{=} \spanDecNumber{90}
\spanIdentifier{bb}\spanOperator{.}\spanIdentifier{s} \spanOperator{=} \spanStringLit{"abc"}
\end{rstpre}
Currently only the dot accessor can be borrowed in this way.

\rsthC{Avoiding SQL injection attacks}\label{distinct-type-avoiding-sql-injection-attacks}
An SQL statement that is passed from Nim to an SQL database might be modelled as a string. However, using string templates and filling in the values is vulnerable to the famous SQL injection attack\label{sql-injection-attack_1}:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{strutils}

\spanKeyword{proc} \spanIdentifier{query}\spanPunctuation{(}\spanIdentifier{db}\spanPunctuation{:} \spanIdentifier{DbHandle}\spanPunctuation{,} \spanIdentifier{statement}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}

\spanKeyword{var}
  \spanIdentifier{username}\spanPunctuation{:} \spanIdentifier{string}

\spanIdentifier{db}\spanOperator{.}\spanIdentifier{query}\spanPunctuation{(}\spanStringLit{"SELECT FROM users WHERE name = '\$1'"} \spanOperator{\%} \spanIdentifier{username}\spanPunctuation{)}
\spanComment{\# Horrible security hole, but the compiler does not mind!}
\end{rstpre}
This can be avoided by distinguishing strings that contain SQL from strings that don't. Distinct types provide a means to introduce a new string type \texttt{SQL} that is incompatible with \texttt{string}:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{SQL} \spanOperator{=} \spanKeyword{distinct} \spanIdentifier{string}

\spanKeyword{proc} \spanIdentifier{query}\spanPunctuation{(}\spanIdentifier{db}\spanPunctuation{:} \spanIdentifier{DbHandle}\spanPunctuation{,} \spanIdentifier{statement}\spanPunctuation{:} \spanIdentifier{SQL}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}

\spanKeyword{var}
  \spanIdentifier{username}\spanPunctuation{:} \spanIdentifier{string}

\spanIdentifier{db}\spanOperator{.}\spanIdentifier{query}\spanPunctuation{(}\spanStringLit{"SELECT FROM users WHERE name = '\$1'"} \spanOperator{\%} \spanIdentifier{username}\spanPunctuation{)}
\spanComment{\# Static error: \symbol{96}query\symbol{96} expects an SQL string!}
\end{rstpre}
It is an essential property of abstract types that they \textbf{do not} imply a subtype relation between the abstract type and its base type. Explicit type conversions from \texttt{string} to \texttt{SQL} are allowed:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{strutils}\spanPunctuation{,} \spanIdentifier{sequtils}

\spanKeyword{proc} \spanIdentifier{properQuote}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{SQL} \spanOperator{=}
  \spanComment{\# quotes a string properly for an SQL statement}
  \spanKeyword{return} \spanIdentifier{SQL}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{)}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{\%}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{frmt}\spanPunctuation{:} \spanIdentifier{SQL}\spanPunctuation{,} \spanIdentifier{values}\spanPunctuation{:} \spanIdentifier{openarray}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{SQL} \spanOperator{=}
  \spanComment{\# quote each argument:}
  \spanKeyword{let} \spanIdentifier{v} \spanOperator{=} \spanIdentifier{values}\spanOperator{.}\spanIdentifier{mapIt}\spanPunctuation{(}\spanIdentifier{SQL}\spanPunctuation{,} \spanIdentifier{properQuote}\spanPunctuation{(}\spanIdentifier{it}\spanPunctuation{)}\spanPunctuation{)}
  \spanComment{\# we need a temporary type for the type conversion :-(}
  \spanKeyword{type} \spanIdentifier{StrSeq} \spanOperator{=} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}
  \spanComment{\# call strutils.\symbol{96}\%\symbol{96}:}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{SQL}\spanPunctuation{(}\spanIdentifier{string}\spanPunctuation{(}\spanIdentifier{frmt}\spanPunctuation{)} \spanOperator{\%} \spanIdentifier{StrSeq}\spanPunctuation{(}\spanIdentifier{v}\spanPunctuation{)}\spanPunctuation{)}

\spanIdentifier{db}\spanOperator{.}\spanIdentifier{query}\spanPunctuation{(}\spanStringLit{"SELECT FROM users WHERE name = '\$1'"}\spanOperator{.}\spanIdentifier{SQL} \spanOperator{\%} \spanPunctuation{\symbol{91}}\spanIdentifier{username}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
Now we have compile-time checking against SQL injection attacks.  Since \texttt{"".SQL} is transformed to \texttt{SQL("")} no new syntax is needed for nice looking \texttt{SQL} string literals. The hypothetical \texttt{SQL} type actually exists in the library as the \href{db\_common.html\#SqlQuery}{SqlQuery type} of modules like \href{db\_sqlite.html}{db\_sqlite}.

\rsthB{Auto type}\label{types-auto-type}
The \texttt{auto} type can only be used for return types and parameters. For return types it causes the compiler to infer the type from the routine body:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{returnsInt}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{auto} \spanOperator{=} \spanDecNumber{1984}
\end{rstpre}
For parameters it currently creates implicitly generic routines:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{auto}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}
\end{rstpre}
Is the same as:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{\symbol{91}}\spanIdentifier{T1}\spanPunctuation{,} \spanIdentifier{T2}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{T1}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{T2}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}
\end{rstpre}
However later versions of the language might change this to mean "infer the parameters' types from the body". Then the above \texttt{foo} would be rejected as the parameters' types can not be inferred from an empty \texttt{discard} statement.

\rsthA{Type relations}\label{type-relations}
The following section defines several relations on types that are needed to describe the type checking done by the compiler.

\rsthB{Type equality}\label{type-relations-type-equality}
Nim uses structural type equivalence for most types. Only for objects, enumerations and distinct types name equivalence is used. The following algorithm, \emph{in pseudo-code}, determines type equality:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{typeEqualsAux}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{PType}\spanPunctuation{,}
                   \spanIdentifier{s}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{HashSet}\spanPunctuation{\symbol{91}}\spanPunctuation{(}\spanIdentifier{PType}\spanPunctuation{,} \spanIdentifier{PType}\spanPunctuation{)}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanKeyword{if} \spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,}\spanIdentifier{b}\spanPunctuation{)} \spanKeyword{in} \spanIdentifier{s}\spanPunctuation{:} \spanKeyword{return} \spanIdentifier{true}
  \spanIdentifier{incl}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{,} \spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,}\spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{)}
  \spanKeyword{if} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{kind} \spanOperator{==} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{kind}\spanPunctuation{:}
    \spanKeyword{case} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{kind}
    \spanKeyword{of} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{intXX}\spanPunctuation{,} \spanIdentifier{float}\spanPunctuation{,} \spanIdentifier{floatXX}\spanPunctuation{,} \spanIdentifier{char}\spanPunctuation{,} \spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{cstring}\spanPunctuation{,} \spanIdentifier{pointer}\spanPunctuation{,}
        \spanIdentifier{bool}\spanPunctuation{,} \spanKeyword{nil}\spanPunctuation{,} \spanIdentifier{void}\spanPunctuation{:}
      \spanComment{\# leaf type: kinds identical; nothing more to check}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{true}
    \spanKeyword{of} \spanKeyword{ref}\spanPunctuation{,} \spanKeyword{ptr}\spanPunctuation{,} \spanKeyword{var}\spanPunctuation{,} \spanIdentifier{set}\spanPunctuation{,} \spanIdentifier{seq}\spanPunctuation{,} \spanIdentifier{openarray}\spanPunctuation{:}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{typeEqualsAux}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{)}
    \spanKeyword{of} \spanIdentifier{range}\spanPunctuation{:}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{typeEqualsAux}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{)} \spanKeyword{and}
        \spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{rangeA} \spanOperator{==} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{rangeA}\spanPunctuation{)} \spanKeyword{and} \spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{rangeB} \spanOperator{==} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{rangeB}\spanPunctuation{)}
    \spanKeyword{of} \spanIdentifier{array}\spanPunctuation{:}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{typeEqualsAux}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{)} \spanKeyword{and}
               \spanIdentifier{typeEqualsAux}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{indexType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{indexType}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{)}
    \spanKeyword{of} \spanKeyword{tuple}\spanPunctuation{:}
      \spanKeyword{if} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{tupleLen} \spanOperator{==} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{tupleLen}\spanPunctuation{:}
        \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{tupleLen}\spanOperator{-}\spanDecNumber{1}\spanPunctuation{:}
          \spanKeyword{if} \spanKeyword{not} \spanIdentifier{typeEqualsAux}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{return} \spanIdentifier{false}
        \spanIdentifier{result} \spanOperator{=} \spanIdentifier{true}
    \spanKeyword{of} \spanKeyword{object}\spanPunctuation{,} \spanKeyword{enum}\spanPunctuation{,} \spanKeyword{distinct}\spanPunctuation{:}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{a} \spanOperator{==} \spanIdentifier{b}
    \spanKeyword{of} \spanKeyword{proc}\spanPunctuation{:}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{typeEqualsAux}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{parameterTuple}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{parameterTuple}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{)} \spanKeyword{and}
               \spanIdentifier{typeEqualsAux}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{resultType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{resultType}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{)} \spanKeyword{and}
               \spanIdentifier{a}\spanOperator{.}\spanIdentifier{callingConvention} \spanOperator{==} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{callingConvention}

\spanKeyword{proc} \spanIdentifier{typeEquals}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{PType}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{HashSet}\spanPunctuation{\symbol{91}}\spanPunctuation{(}\spanIdentifier{PType}\spanPunctuation{,} \spanIdentifier{PType}\spanPunctuation{)}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanPunctuation{\symbol{123}}\spanPunctuation{\symbol{125}}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{typeEqualsAux}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{)}
\end{rstpre}
Since types are graphs which can have cycles, the above algorithm needs an auxiliary set \texttt{s} to detect this case.

\rsthB{Type equality modulo type distinction}\label{type-relations-type-equality-modulo-type-distinction}
The following algorithm (in pseudo-code) determines whether two types are equal with no respect to \texttt{distinct} types. For brevity the cycle check with an auxiliary set \texttt{s} is omitted:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{typeEqualsOrDistinct}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{PType}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanKeyword{if} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{kind} \spanOperator{==} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{kind}\spanPunctuation{:}
    \spanKeyword{case} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{kind}
    \spanKeyword{of} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{intXX}\spanPunctuation{,} \spanIdentifier{float}\spanPunctuation{,} \spanIdentifier{floatXX}\spanPunctuation{,} \spanIdentifier{char}\spanPunctuation{,} \spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{cstring}\spanPunctuation{,} \spanIdentifier{pointer}\spanPunctuation{,}
        \spanIdentifier{bool}\spanPunctuation{,} \spanKeyword{nil}\spanPunctuation{,} \spanIdentifier{void}\spanPunctuation{:}
      \spanComment{\# leaf type: kinds identical; nothing more to check}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{true}
    \spanKeyword{of} \spanKeyword{ref}\spanPunctuation{,} \spanKeyword{ptr}\spanPunctuation{,} \spanKeyword{var}\spanPunctuation{,} \spanIdentifier{set}\spanPunctuation{,} \spanIdentifier{seq}\spanPunctuation{,} \spanIdentifier{openarray}\spanPunctuation{:}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{typeEqualsOrDistinct}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{)}
    \spanKeyword{of} \spanIdentifier{range}\spanPunctuation{:}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{typeEqualsOrDistinct}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{)} \spanKeyword{and}
        \spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{rangeA} \spanOperator{==} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{rangeA}\spanPunctuation{)} \spanKeyword{and} \spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{rangeB} \spanOperator{==} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{rangeB}\spanPunctuation{)}
    \spanKeyword{of} \spanIdentifier{array}\spanPunctuation{:}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{typeEqualsOrDistinct}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{)} \spanKeyword{and}
               \spanIdentifier{typeEqualsOrDistinct}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{indexType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{indexType}\spanPunctuation{)}
    \spanKeyword{of} \spanKeyword{tuple}\spanPunctuation{:}
      \spanKeyword{if} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{tupleLen} \spanOperator{==} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{tupleLen}\spanPunctuation{:}
        \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{tupleLen}\spanOperator{-}\spanDecNumber{1}\spanPunctuation{:}
          \spanKeyword{if} \spanKeyword{not} \spanIdentifier{typeEqualsOrDistinct}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{return} \spanIdentifier{false}
        \spanIdentifier{result} \spanOperator{=} \spanIdentifier{true}
    \spanKeyword{of} \spanKeyword{distinct}\spanPunctuation{:}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{typeEqualsOrDistinct}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{)}
    \spanKeyword{of} \spanKeyword{object}\spanPunctuation{,} \spanKeyword{enum}\spanPunctuation{:}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{a} \spanOperator{==} \spanIdentifier{b}
    \spanKeyword{of} \spanKeyword{proc}\spanPunctuation{:}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{typeEqualsOrDistinct}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{parameterTuple}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{parameterTuple}\spanPunctuation{)} \spanKeyword{and}
               \spanIdentifier{typeEqualsOrDistinct}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{resultType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{resultType}\spanPunctuation{)} \spanKeyword{and}
               \spanIdentifier{a}\spanOperator{.}\spanIdentifier{callingConvention} \spanOperator{==} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{callingConvention}
  \spanKeyword{elif} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{kind} \spanOperator{==} \spanKeyword{distinct}\spanPunctuation{:}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{typeEqualsOrDistinct}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)}
  \spanKeyword{elif} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{kind} \spanOperator{==} \spanKeyword{distinct}\spanPunctuation{:}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{typeEqualsOrDistinct}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{)}
\end{rstpre}
\rsthB{Subtype relation}\label{type-relations-subtype-relation}
If object \texttt{a} inherits from \texttt{b}, \texttt{a} is a subtype of \texttt{b}. This subtype relation is extended to the types \texttt{var}, \texttt{ref}, \texttt{ptr}:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{isSubtype}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{PType}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanKeyword{if} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{kind} \spanOperator{==} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{kind}\spanPunctuation{:}
    \spanKeyword{case} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{kind}
    \spanKeyword{of} \spanKeyword{object}\spanPunctuation{:}
      \spanKeyword{var} \spanIdentifier{aa} \spanOperator{=} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{baseType}
      \spanKeyword{while} \spanIdentifier{aa} \spanOperator{!=} \spanKeyword{nil} \spanKeyword{and} \spanIdentifier{aa} \spanOperator{!=} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{aa} \spanOperator{=} \spanIdentifier{aa}\spanOperator{.}\spanIdentifier{baseType}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{aa} \spanOperator{==} \spanIdentifier{b}
    \spanKeyword{of} \spanKeyword{var}\spanPunctuation{,} \spanKeyword{ref}\spanPunctuation{,} \spanKeyword{ptr}\spanPunctuation{:}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{isSubtype}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{)}
\end{rstpre}
\rsthB{Convertible relation}\label{type-relations-convertible-relation}
A type \texttt{a} is \textbf{implicitly} convertible to type \texttt{b} iff the following algorithm returns true:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{isImplicitlyConvertible}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{PType}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanKeyword{if} \spanIdentifier{isSubtype}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)} \spanKeyword{or} \spanIdentifier{isCovariant}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{:}
    \spanKeyword{return} \spanIdentifier{true}
  \spanKeyword{if} \spanIdentifier{isIntLiteral}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}\spanPunctuation{:}
    \spanKeyword{return} \spanIdentifier{b} \spanKeyword{in} \spanPunctuation{\symbol{123}}\spanIdentifier{int8}\spanPunctuation{,} \spanIdentifier{int16}\spanPunctuation{,} \spanIdentifier{int32}\spanPunctuation{,} \spanIdentifier{int64}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{uint}\spanPunctuation{,} \spanIdentifier{uint8}\spanPunctuation{,} \spanIdentifier{uint16}\spanPunctuation{,}
                 \spanIdentifier{uint32}\spanPunctuation{,} \spanIdentifier{uint64}\spanPunctuation{,} \spanIdentifier{float32}\spanPunctuation{,} \spanIdentifier{float64}\spanPunctuation{\symbol{125}}
  \spanKeyword{case} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{kind}
  \spanKeyword{of} \spanIdentifier{int}\spanPunctuation{:}     \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanKeyword{in} \spanPunctuation{\symbol{123}}\spanIdentifier{int32}\spanPunctuation{,} \spanIdentifier{int64}\spanPunctuation{\symbol{125}}
  \spanKeyword{of} \spanIdentifier{int8}\spanPunctuation{:}    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanKeyword{in} \spanPunctuation{\symbol{123}}\spanIdentifier{int16}\spanPunctuation{,} \spanIdentifier{int32}\spanPunctuation{,} \spanIdentifier{int64}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{\symbol{125}}
  \spanKeyword{of} \spanIdentifier{int16}\spanPunctuation{:}   \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanKeyword{in} \spanPunctuation{\symbol{123}}\spanIdentifier{int32}\spanPunctuation{,} \spanIdentifier{int64}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{\symbol{125}}
  \spanKeyword{of} \spanIdentifier{int32}\spanPunctuation{:}   \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanKeyword{in} \spanPunctuation{\symbol{123}}\spanIdentifier{int64}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{\symbol{125}}
  \spanKeyword{of} \spanIdentifier{uint}\spanPunctuation{:}    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanKeyword{in} \spanPunctuation{\symbol{123}}\spanIdentifier{uint32}\spanPunctuation{,} \spanIdentifier{uint64}\spanPunctuation{\symbol{125}}
  \spanKeyword{of} \spanIdentifier{uint8}\spanPunctuation{:}   \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanKeyword{in} \spanPunctuation{\symbol{123}}\spanIdentifier{uint16}\spanPunctuation{,} \spanIdentifier{uint32}\spanPunctuation{,} \spanIdentifier{uint64}\spanPunctuation{\symbol{125}}
  \spanKeyword{of} \spanIdentifier{uint16}\spanPunctuation{:}  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanKeyword{in} \spanPunctuation{\symbol{123}}\spanIdentifier{uint32}\spanPunctuation{,} \spanIdentifier{uint64}\spanPunctuation{\symbol{125}}
  \spanKeyword{of} \spanIdentifier{uint32}\spanPunctuation{:}  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanKeyword{in} \spanPunctuation{\symbol{123}}\spanIdentifier{uint64}\spanPunctuation{\symbol{125}}
  \spanKeyword{of} \spanIdentifier{float32}\spanPunctuation{:} \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanKeyword{in} \spanPunctuation{\symbol{123}}\spanIdentifier{float64}\spanPunctuation{\symbol{125}}
  \spanKeyword{of} \spanIdentifier{float64}\spanPunctuation{:} \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanKeyword{in} \spanPunctuation{\symbol{123}}\spanIdentifier{float32}\spanPunctuation{\symbol{125}}
  \spanKeyword{of} \spanIdentifier{seq}\spanPunctuation{:}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanOperator{==} \spanIdentifier{openArray} \spanKeyword{and} \spanIdentifier{typeEquals}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{)}
  \spanKeyword{of} \spanIdentifier{array}\spanPunctuation{:}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanOperator{==} \spanIdentifier{openArray} \spanKeyword{and} \spanIdentifier{typeEquals}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{,} \spanIdentifier{b}\spanOperator{.}\spanIdentifier{baseType}\spanPunctuation{)}
    \spanKeyword{if} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{baseType} \spanOperator{==} \spanIdentifier{char} \spanKeyword{and} \spanIdentifier{a}\spanOperator{.}\spanIdentifier{indexType}\spanOperator{.}\spanIdentifier{rangeA} \spanOperator{==} \spanDecNumber{0}\spanPunctuation{:}
      \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanOperator{==} \spanIdentifier{cstring}
  \spanKeyword{of} \spanIdentifier{cstring}\spanPunctuation{,} \spanKeyword{ptr}\spanPunctuation{:}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanOperator{==} \spanIdentifier{pointer}
  \spanKeyword{of} \spanIdentifier{string}\spanPunctuation{:}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{b} \spanOperator{==} \spanIdentifier{cstring}
\end{rstpre}
Implicit conversions are also performed for Nim's \texttt{range} type constructor.

Let \texttt{a0}, \texttt{b0} of type \texttt{T}.

Let \texttt{A = range\symbol{91}a0..b0\symbol{93}} be the argument's type, \texttt{F} the formal parameter's type. Then an implicit conversion from \texttt{A} to \texttt{F} exists if \texttt{a0 >= low(F) and b0 <= high(F)} and both \texttt{T} and \texttt{F} are signed integers or if both are unsigned integers.

A type \texttt{a} is \textbf{explicitly} convertible to type \texttt{b} iff the following algorithm returns true:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{isIntegralType}\spanPunctuation{(}\spanIdentifier{t}\spanPunctuation{:} \spanIdentifier{PType}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{isOrdinal}\spanPunctuation{(}\spanIdentifier{t}\spanPunctuation{)} \spanKeyword{or} \spanIdentifier{t}\spanOperator{.}\spanIdentifier{kind} \spanKeyword{in} \spanPunctuation{\symbol{123}}\spanIdentifier{float}\spanPunctuation{,} \spanIdentifier{float32}\spanPunctuation{,} \spanIdentifier{float64}\spanPunctuation{\symbol{125}}

\spanKeyword{proc} \spanIdentifier{isExplicitlyConvertible}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{PType}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{false}
  \spanKeyword{if} \spanIdentifier{isImplicitlyConvertible}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{return} \spanIdentifier{true}
  \spanKeyword{if} \spanIdentifier{typeEqualsOrDistinct}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{return} \spanIdentifier{true}
  \spanKeyword{if} \spanIdentifier{isIntegralType}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)} \spanKeyword{and} \spanIdentifier{isIntegralType}\spanPunctuation{(}\spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{return} \spanIdentifier{true}
  \spanKeyword{if} \spanIdentifier{isSubtype}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)} \spanKeyword{or} \spanIdentifier{isSubtype}\spanPunctuation{(}\spanIdentifier{b}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{return} \spanIdentifier{true}
\end{rstpre}
The convertible relation can be relaxed by a user-defined type converter\label{converter_1}.

\begin{rstpre}
\spanKeyword{converter} \spanIdentifier{toInt}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{char}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanIdentifier{result} \spanOperator{=} \spanIdentifier{ord}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}

\spanKeyword{var}
  \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}
  \spanIdentifier{chr}\spanPunctuation{:} \spanIdentifier{char} \spanOperator{=} \spanCharLit{'a'}

\spanComment{\# implicit conversion magic happens here}
\spanIdentifier{x} \spanOperator{=} \spanIdentifier{chr}
\spanIdentifier{echo} \spanIdentifier{x} \spanComment{\# => 97}
\spanComment{\# one can use the explicit form too}
\spanIdentifier{x} \spanOperator{=} \spanIdentifier{chr}\spanOperator{.}\spanIdentifier{toInt}
\spanIdentifier{echo} \spanIdentifier{x} \spanComment{\# => 97}
\end{rstpre}
The type conversion \texttt{T(a)} is an L-value if \texttt{a} is an L-value and \texttt{typeEqualsOrDistinct(T, typeof(a))} holds.

\rsthB{Assignment compatibility}\label{type-relations-assignment-compatibility}
An expression \texttt{b} can be assigned to an expression \texttt{a} iff \texttt{a} is an \texttt{l-value} and \texttt{isImplicitlyConvertible(b.typ, a.typ)} holds.

\rsthA{Overloading resolution}\label{overloading-resolution}
In a call \texttt{p(args)} the routine \texttt{p} that matches best is selected. If multiple routines match equally well, the ambiguity is reported during semantic analysis.

Every arg in args needs to match. There are multiple different categories how an argument can match. Let \texttt{f} be the formal parameter's type and \texttt{a} the type of the argument.

\begin{enumerate}\item Exact match: \texttt{a} and \texttt{f} are of the same type.
\item Literal match: \texttt{a} is an integer literal of value \texttt{v} and \texttt{f} is a signed or unsigned integer type and \texttt{v} is in \texttt{f}'s range. Or:  \texttt{a} is a floating point literal of value \texttt{v} and \texttt{f} is a floating point type and \texttt{v} is in \texttt{f}'s range.
\item Generic match: \texttt{f} is a generic type and \texttt{a} matches, for instance \texttt{a} is \texttt{int} and \texttt{f} is a generic (constrained) parameter type (like in \texttt{\symbol{91}T\symbol{93}} or \texttt{\symbol{91}T: int|char\symbol{93}}.
\item Subrange or subtype match: \texttt{a} is a \texttt{range\symbol{91}T\symbol{93}} and \texttt{T} matches \texttt{f} exactly. Or: \texttt{a} is a subtype of \texttt{f}.
\item Integral conversion match: \texttt{a} is convertible to \texttt{f} and \texttt{f} and \texttt{a} is some integer or floating point type.
\item Conversion match: \texttt{a} is convertible to \texttt{f}, possibly via a user defined \texttt{converter}.
\end{enumerate}
These matching categories have a priority: An exact match is better than a literal match and that is better than a generic match etc. In the following \texttt{count(p, m)} counts the number of matches of the matching category \texttt{m} for the routine \texttt{p}.

A routine \texttt{p} matches better than a routine \texttt{q} if the following algorithm returns true:\begin{rstpre}

for each matching category m in \symbol{91}"exact match", "literal match",
                                "generic match", "subtype match",
                                "integral match", "conversion match"\symbol{93}:
  if count(p, m) > count(q, m): return true
  elif count(p, m) == count(q, m):
    discard "continue with next category m"
  else:
    return false
return "ambiguous"
\end{rstpre}


Some examples:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{takesInt}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanStringLit{"int"}
\spanKeyword{proc} \spanIdentifier{takesInt}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanStringLit{"T"}
\spanKeyword{proc} \spanIdentifier{takesInt}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int16}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanStringLit{"int16"}

\spanIdentifier{takesInt}\spanPunctuation{(}\spanDecNumber{4}\spanPunctuation{)} \spanComment{\# "int"}
\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int32}
\spanIdentifier{takesInt}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)} \spanComment{\# "T"}
\spanKeyword{var} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int16}
\spanIdentifier{takesInt}\spanPunctuation{(}\spanIdentifier{y}\spanPunctuation{)} \spanComment{\# "int16"}
\spanKeyword{var} \spanIdentifier{z}\spanPunctuation{:} \spanIdentifier{range}\spanPunctuation{\symbol{91}}\spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{4}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanDecNumber{0}
\spanIdentifier{takesInt}\spanPunctuation{(}\spanIdentifier{z}\spanPunctuation{)} \spanComment{\# "T"}
\end{rstpre}
If this algorithm returns "ambiguous" further disambiguation is performed: If the argument \texttt{a} matches both the parameter type \texttt{f} of \texttt{p} and \texttt{g} of \texttt{q} via a subtyping relation, the inheritance depth is taken into account:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{A} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{RootObj}
  \spanIdentifier{B} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{A}
  \spanIdentifier{C} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{B}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{obj}\spanPunctuation{:} \spanIdentifier{A}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"A"}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{obj}\spanPunctuation{:} \spanIdentifier{B}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"B"}

\spanKeyword{var} \spanIdentifier{c} \spanOperator{=} \spanIdentifier{C}\spanPunctuation{(}\spanPunctuation{)}
\spanComment{\# not ambiguous, calls 'B', not 'A' since B is a subtype of A}
\spanComment{\# but not vice versa:}
\spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{pp}\spanPunctuation{(}\spanIdentifier{obj}\spanPunctuation{:} \spanIdentifier{A}\spanPunctuation{,} \spanIdentifier{obj2}\spanPunctuation{:} \spanIdentifier{B}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanStringLit{"A B"}
\spanKeyword{proc} \spanIdentifier{pp}\spanPunctuation{(}\spanIdentifier{obj}\spanPunctuation{:} \spanIdentifier{B}\spanPunctuation{,} \spanIdentifier{obj2}\spanPunctuation{:} \spanIdentifier{A}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanStringLit{"B A"}

\spanComment{\# but this is ambiguous:}
\spanIdentifier{pp}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{,} \spanIdentifier{c}\spanPunctuation{)}
\end{rstpre}
Likewise for generic matches the most specialized generic type (that still matches) is preferred:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{gen}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanKeyword{ref} \spanKeyword{ref} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanStringLit{"ref ref T"}
\spanKeyword{proc} \spanIdentifier{gen}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanKeyword{ref} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanStringLit{"ref T"}
\spanKeyword{proc} \spanIdentifier{gen}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanStringLit{"T"}

\spanKeyword{var} \spanIdentifier{ri}\spanPunctuation{:} \spanKeyword{ref} \spanIdentifier{int}
\spanIdentifier{gen}\spanPunctuation{(}\spanIdentifier{ri}\spanPunctuation{)} \spanComment{\# "ref T"}
\end{rstpre}
\rsthB{Overloading based on 'var T' / 'out T'}\label{overloading-resolution-overloading-based-on-var-t-slash-out-t}
If the formal parameter \texttt{f} is of type \texttt{var T} (or \texttt{out T}) in addition to the ordinary type checking, the argument is checked to be an l-value\label{lminusvalue_1}. \texttt{var T} (or \texttt{out T}) matches better than just \texttt{T} then.

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{sayHi}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanComment{\# matches a non-var int}
  \spanIdentifier{result} \spanOperator{=} \spanOperator{\$}\spanIdentifier{x}
\spanKeyword{proc} \spanIdentifier{sayHi}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanComment{\# matches a var int}
  \spanIdentifier{result} \spanOperator{=} \spanOperator{\$}\spanPunctuation{(}\spanIdentifier{x} \spanOperator{+} \spanDecNumber{10}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{sayHello}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{m} \spanOperator{=} \spanIdentifier{x} \spanComment{\# a mutable version of x}
  \spanIdentifier{echo} \spanIdentifier{sayHi}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)} \spanComment{\# matches the non-var version of sayHi}
  \spanIdentifier{echo} \spanIdentifier{sayHi}\spanPunctuation{(}\spanIdentifier{m}\spanPunctuation{)} \spanComment{\# matches the var version of sayHi}

\spanIdentifier{sayHello}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{)} \spanComment{\# 3}
            \spanComment{\# 13}
\end{rstpre}
An l-value matches \texttt{var T} and \texttt{out T} equally well, hence the following is ambiguous:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanKeyword{out} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{x} \spanOperator{=} \spanStringLit{""}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{x} \spanOperator{=} \spanStringLit{""}
\spanKeyword{var} \spanIdentifier{v}\spanPunctuation{:} \spanIdentifier{string}
\spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{v}\spanPunctuation{)} \spanComment{\# ambiguous}
\end{rstpre}
\rsthB{Lazy type resolution for untyped}\label{overloading-resolution-lazy-type-resolution-for-untyped}
\textbf{Note}: An unresolved\label{unresolved_1} expression is an expression for which no symbol lookups and no type checking have been performed.

Since templates and macros that are not declared as \texttt{immediate} participate in overloading resolution it's essential to have a way to pass unresolved expressions to a template or macro. This is what the meta-type \texttt{untyped} accomplishes:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{rem}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}

\spanIdentifier{rem} \spanIdentifier{unresolvedExpression}\spanPunctuation{(}\spanIdentifier{undeclaredIdentifier}\spanPunctuation{)}
\end{rstpre}
A parameter of type \texttt{untyped} always matches any argument (as long as there is any argument passed to it).

But one has to watch out because other overloads might trigger the argument's resolution:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{rem}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}
\spanKeyword{proc} \spanIdentifier{rem}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}

\spanComment{\# undeclared identifier: 'unresolvedExpression'}
\spanIdentifier{rem} \spanIdentifier{unresolvedExpression}\spanPunctuation{(}\spanIdentifier{undeclaredIdentifier}\spanPunctuation{)}
\end{rstpre}
\texttt{untyped} and \texttt{varargs\symbol{91}untyped\symbol{93}} are the only metatype that are lazy in this sense, the other metatypes \texttt{typed} and \texttt{typedesc} are not lazy.

\rsthB{Varargs matching}\label{overloading-resolution-varargs-matching}
See \href{\#types-varargs}{Varargs}.

\rsthA{Statements and expressions}\label{statements-and-expressions}
Nim uses the common statement/expression paradigm: Statements do not produce a value in contrast to expressions. However, some expressions are statements.

Statements are separated into simple statements\label{simple-statements_1} and complex statements\label{complex-statements_1}. Simple statements are statements that cannot contain other statements like assignments, calls or the \texttt{return} statement; complex statements can contain other statements. To avoid the dangling else problem\label{dangling-else-problem_1}, complex statements always have to be indented. The details can be found in the grammar.

\rsthB{Statement list expression}\label{statements-and-expressions-statement-list-expression}
Statements can also occur in an expression context that looks like \texttt{(stmt1; stmt2; ...; ex)}. This is called an statement list expression or \texttt{(;)}. The type of \texttt{(stmt1; stmt2; ...; ex)} is the type of \texttt{ex}. All the other statements must be of type \texttt{void}. (One can use \texttt{discard} to produce a \texttt{void} type.) \texttt{(;)} does not introduce a new scope.

\rsthB{Discard statement}\label{statements-and-expressions-discard-statement}
Example:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{x} \spanOperator{+} \spanIdentifier{y}

\spanKeyword{discard} \spanIdentifier{p}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{)} \spanComment{\# discard the return value of \symbol{96}p\symbol{96}}
\end{rstpre}
The \texttt{discard} statement evaluates its expression for side-effects and throws the expression's resulting value away, and should only be used when ignoring this value is known not to cause problems.

Ignoring the return value of a procedure without using a discard statement is a static error.

The return value can be ignored implicitly if the called proc/iterator has been declared with the discardable\label{discardable_1} pragma:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{discardable}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{x} \spanOperator{+} \spanIdentifier{y}

\spanIdentifier{p}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{)} \spanComment{\# now valid}
\end{rstpre}
An empty \texttt{discard} statement is often used as a null statement:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{classify}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{case} \spanIdentifier{s}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}
  \spanKeyword{of} \spanIdentifier{SymChars}\spanPunctuation{,} \spanCharLit{'\_'}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"an identifier"}
  \spanKeyword{of} \spanCharLit{'0'}\spanOperator{..}\spanCharLit{'9'}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"a number"}
  \spanKeyword{else}\spanPunctuation{:} \spanKeyword{discard}
\end{rstpre}
\rsthB{Void context}\label{statements-and-expressions-void-context}
In a list of statements every expression except the last one needs to have the type \texttt{void}. In addition to this rule an assignment to the builtin \texttt{result} symbol also triggers a mandatory \texttt{void} context for the subsequent expressions:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{invalid}\spanOperator{*}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanStringLit{"foo"}
  \spanStringLit{"invalid"}  \spanComment{\# Error: value of type 'string' has to be discarded}
\end{rstpre}
\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{valid}\spanOperator{*}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanKeyword{let} \spanIdentifier{x} \spanOperator{=} \spanDecNumber{317}
  \spanStringLit{"valid"}
\end{rstpre}
\rsthB{Var statement}\label{statements-and-expressions-var-statement}
Var statements declare new local and global variables and initialize them. A comma separated list of variables can be used to specify variables of the same type:

\begin{rstpre}
\spanKeyword{var}
  \spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanDecNumber{0}
  \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanIdentifier{z}\spanPunctuation{:} \spanIdentifier{int}
\end{rstpre}
If an initializer is given the type can be omitted: the variable is then of the same type as the initializing expression. Variables are always initialized with a default value if there is no initializing expression. The default value depends on the type and is always a zero in binary.

\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|X|X|X|X|X|X|}
\hline
\textbf{Type} & \textbf{default value}\\
\hline
any integer type & 0\\
\hline
any float & 0.0\\
\hline
char & '\symbol{92}0'\\
\hline
bool & false\\
\hline
ref or pointer type & nil\\
\hline
procedural type & nil\\
\hline
sequence & \texttt{\symbol{64}\symbol{91}\symbol{93}}\\
\hline
string & \texttt{""}\\
\hline
tuple\symbol{91}x: A, y: B, ...\symbol{93} & (default(A), default(B), ...) (analogous for objects)\\
\hline
array\symbol{91}0..., T\symbol{93} & \symbol{91}default(T), ...\symbol{93}\\
\hline
range\symbol{91}T\symbol{93} & default(T); this may be out of the valid range\\
\hline
T = enum & cast\symbol{91}T\symbol{93}(0); this may be an invalid value\\
\hline
\end{rsttab}\end{table}The implicit initialization can be avoided for optimization reasons with the noinit\label{noinit_1} pragma:

\begin{rstpre}
\spanKeyword{var}
  \spanIdentifier{a} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{noInit}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{1023}\spanPunctuation{,} \spanIdentifier{char}\spanPunctuation{\symbol{93}}
\end{rstpre}
If a proc is annotated with the \texttt{noinit} pragma this refers to its implicit \texttt{result} variable:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{returnUndefinedValue}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{noinit}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{discard}
\end{rstpre}
The implicit initialization can be also prevented by the requiresInit\label{requiresinit_1} type pragma. The compiler requires an explicit initialization for the object and all of its fields. However it does a control flow analysis\label{control-flow-analysis_1} to prove the variable has been initialized and does not rely on syntactic properties:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{MyObject} \spanOperator{=} \spanKeyword{object} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{requiresInit}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# the following is valid:}
  \spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{MyObject}
  \spanKeyword{if} \spanIdentifier{someCondition}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:}
    \spanIdentifier{x} \spanOperator{=} \spanIdentifier{a}\spanPunctuation{(}\spanPunctuation{)}
  \spanKeyword{else}\spanPunctuation{:}
    \spanIdentifier{x} \spanOperator{=} \spanIdentifier{a}\spanPunctuation{(}\spanPunctuation{)}
  \spanComment{\# use x}
\end{rstpre}
\rsthB{Let statement}\label{statements-and-expressions-let-statement}
A \texttt{let} statement declares new local and global single assignment\label{single-assignment_1} variables and binds a value to them. The syntax is the same as that of the \texttt{var} statement, except that the keyword \texttt{var} is replaced by the keyword \texttt{let}. Let variables are not l-values and can thus not be passed to \texttt{var} parameters nor can their address be taken. They cannot be assigned new values.

For let variables the same pragmas are available as for ordinary variables.

As \texttt{let} statements are immutable after creation they need to define a value when they are declared. The only exception to this is if the \texttt{\symbol{123}.importc.\symbol{125}} pragma (or any of the other \texttt{importX} pragmas) is applied, in this case the value is expected to come from native code, typically a C/C++ \texttt{const}.

\rsthB{Tuple unpacking}\label{statements-and-expressions-tuple-unpacking}
In a \texttt{var} or \texttt{let} statement tuple unpacking can be performed. The special identifier \texttt{\_} can be used to ignore some parts of the tuple:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{returnsTuple}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanPunctuation{(}\spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=} \spanPunctuation{(}\spanDecNumber{4}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{)}

\spanKeyword{let} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{\_}\spanPunctuation{,} \spanIdentifier{z}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{returnsTuple}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
\rsthB{Const section}\label{statements-and-expressions-const-section}
A const section declares constants whose values are constant expressions:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{strutils}
\spanKeyword{const}
  \spanIdentifier{roundPi} \spanOperator{=} \spanFloatNumber{3.1415}
  \spanIdentifier{constEval} \spanOperator{=} \spanIdentifier{contains}\spanPunctuation{(}\spanStringLit{"abc"}\spanPunctuation{,} \spanCharLit{'b'}\spanPunctuation{)} \spanComment{\# computed at compile time!}
\end{rstpre}
Once declared, a constant's symbol can be used as a constant expression.

See \href{\#constants-and-constant-expressions}{Constants and Constant Expressions} for details.

\rsthB{Static statement/expression}\label{statements-and-expressions-static-statementslashexpression}
A static statement/expression explicitly requires compile-time execution. Even some code that has side effects is permitted in a static block:

\begin{rstpre}
\spanKeyword{static}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"echo at compile time"}
\end{rstpre}
There are limitations on what Nim code can be executed at compile time; see \href{\#restrictions-on-compileminustime-execution}{Restrictions on Compile-Time Execution} for details. It's a static error if the compiler cannot execute the block at compile time.

\rsthB{If statement}\label{statements-and-expressions-if-statement}
Example:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{name} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}

\spanKeyword{if} \spanIdentifier{name} \spanOperator{==} \spanStringLit{"Andreas"}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"What a nice name!"}
\spanKeyword{elif} \spanIdentifier{name} \spanOperator{==} \spanStringLit{""}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Don't you have a name?"}
\spanKeyword{else}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Boring name..."}
\end{rstpre}
The \texttt{if} statement is a simple way to make a branch in the control flow: The expression after the keyword \texttt{if} is evaluated, if it is true the corresponding statements after the \texttt{:} are executed. Otherwise the expression after the \texttt{elif} is evaluated (if there is an \texttt{elif} branch), if it is true the corresponding statements after the \texttt{:} are executed. This goes on until the last \texttt{elif}. If all conditions fail, the \texttt{else} part is executed. If there is no \texttt{else} part, execution continues with the next statement.

In \texttt{if} statements new scopes begin immediately after the \texttt{if}/\texttt{elif}/\texttt{else} keywords and ends after the corresponding \emph{then} block. For visualization purposes the scopes have been enclosed in \texttt{\symbol{123}| |\symbol{125}} in the following example:

\begin{rstpre}
\spanKeyword{if} \spanPunctuation{\symbol{123}}\spanOperator{|} \spanPunctuation{(}\spanKeyword{let} \spanIdentifier{m} \spanOperator{=} \spanIdentifier{input} \spanOperator{=\symbol{126}} \spanRawData{re"(\symbol{92}w+)=\symbol{92}w+"}\spanPunctuation{;} \spanIdentifier{m}\spanOperator{.}\spanIdentifier{isMatch}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"key "}\spanPunctuation{,} \spanIdentifier{m}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanStringLit{" value "}\spanPunctuation{,} \spanIdentifier{m}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}}  \spanOperator{|}\spanPunctuation{\symbol{125}}
\spanKeyword{elif} \spanPunctuation{\symbol{123}}\spanOperator{|} \spanPunctuation{(}\spanKeyword{let} \spanIdentifier{m} \spanOperator{=} \spanIdentifier{input} \spanOperator{=\symbol{126}} \spanRawData{re""}\spanPunctuation{;} \spanIdentifier{m}\spanOperator{.}\spanIdentifier{isMatch}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"new m in this scope"}  \spanOperator{|}\spanPunctuation{\symbol{125}}
\spanKeyword{else}\spanPunctuation{:} \spanPunctuation{\symbol{123}}\spanOperator{|}
  \spanIdentifier{echo} \spanStringLit{"m not declared here"}  \spanOperator{|}\spanPunctuation{\symbol{125}}
\end{rstpre}
\rsthB{Case statement}\label{statements-and-expressions-case-statement}
Example:

\begin{rstpre}
\spanKeyword{case} \spanIdentifier{readline}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}
\spanKeyword{of} \spanStringLit{"delete-everything"}\spanPunctuation{,} \spanStringLit{"restart-computer"}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"permission denied"}
\spanKeyword{of} \spanStringLit{"go-for-a-walk"}\spanPunctuation{:}     \spanIdentifier{echo} \spanStringLit{"please yourself"}
\spanKeyword{else}\spanPunctuation{:}                   \spanIdentifier{echo} \spanStringLit{"unknown command"}

\spanComment{\# indentation of the branches is also allowed; and so is an optional colon}
\spanComment{\# after the selecting expression:}
\spanKeyword{case} \spanIdentifier{readline}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}\spanPunctuation{:}
  \spanKeyword{of} \spanStringLit{"delete-everything"}\spanPunctuation{,} \spanStringLit{"restart-computer"}\spanPunctuation{:}
    \spanIdentifier{echo} \spanStringLit{"permission denied"}
  \spanKeyword{of} \spanStringLit{"go-for-a-walk"}\spanPunctuation{:}     \spanIdentifier{echo} \spanStringLit{"please yourself"}
  \spanKeyword{else}\spanPunctuation{:}                   \spanIdentifier{echo} \spanStringLit{"unknown command"}
\end{rstpre}
The \texttt{case} statement is similar to the if statement, but it represents a multi-branch selection. The expression after the keyword \texttt{case} is evaluated and if its value is in a \emph{slicelist} the corresponding statements (after the \texttt{of} keyword) are executed. If the value is not in any given \emph{slicelist} the \texttt{else} part is executed. If there is no \texttt{else} part and not all possible values that \texttt{expr} can hold occur in a \texttt{slicelist}, a static error occurs. This holds only for expressions of ordinal types. "All possible values" of \texttt{expr} are determined by \texttt{expr}'s type. To suppress the static error an \texttt{else} part with an empty \texttt{discard} statement should be used.

For non ordinal types it is not possible to list every possible value and so these always require an \texttt{else} part.

Because case statements are checked for exhaustiveness during semantic analysis, the value in every \texttt{of} branch must be a constant expression. This restriction also allows the compiler to generate more performant code.

As a special semantic extension, an expression in an \texttt{of} branch of a case statement may evaluate to a set or array constructor; the set or array is then expanded into a list of its elements:

\begin{rstpre}
\spanKeyword{const}
  \spanIdentifier{SymChars}\spanPunctuation{:} \spanIdentifier{set}\spanPunctuation{\symbol{91}}\spanIdentifier{char}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanPunctuation{\symbol{123}}\spanCharLit{'a'}\spanOperator{..}\spanCharLit{'z'}\spanPunctuation{,} \spanCharLit{'A'}\spanOperator{..}\spanCharLit{'Z'}\spanPunctuation{,} \spanCharLit{'\symbol{92}x80'}\spanOperator{..}\spanCharLit{'\symbol{92}xFF'}\spanPunctuation{\symbol{125}}

\spanKeyword{proc} \spanIdentifier{classify}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{case} \spanIdentifier{s}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}
  \spanKeyword{of} \spanIdentifier{SymChars}\spanPunctuation{,} \spanCharLit{'\_'}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"an identifier"}
  \spanKeyword{of} \spanCharLit{'0'}\spanOperator{..}\spanCharLit{'9'}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"a number"}
  \spanKeyword{else}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"other"}

\spanComment{\# is equivalent to:}
\spanKeyword{proc} \spanIdentifier{classify}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{case} \spanIdentifier{s}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}
  \spanKeyword{of} \spanCharLit{'a'}\spanOperator{..}\spanCharLit{'z'}\spanPunctuation{,} \spanCharLit{'A'}\spanOperator{..}\spanCharLit{'Z'}\spanPunctuation{,} \spanCharLit{'\symbol{92}x80'}\spanOperator{..}\spanCharLit{'\symbol{92}xFF'}\spanPunctuation{,} \spanCharLit{'\_'}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"an identifier"}
  \spanKeyword{of} \spanCharLit{'0'}\spanOperator{..}\spanCharLit{'9'}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"a number"}
  \spanKeyword{else}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"other"}
\end{rstpre}
The \texttt{case} statement doesn't produce an l-value, so the following example won't work:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Foo} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object}
    \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanIdentifier{get\_x}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{Foo}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}} \spanOperator{=}
  \spanComment{\# doesn't work}
  \spanKeyword{case} \spanIdentifier{true}
  \spanKeyword{of} \spanIdentifier{true}\spanPunctuation{:}
    \spanIdentifier{x}\spanOperator{.}\spanIdentifier{x}
  \spanKeyword{else}\spanPunctuation{:}
    \spanIdentifier{x}\spanOperator{.}\spanIdentifier{x}

\spanKeyword{var} \spanIdentifier{foo} \spanOperator{=} \spanIdentifier{Foo}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\spanIdentifier{foo}\spanOperator{.}\spanIdentifier{get\_x}\spanPunctuation{(}\spanPunctuation{)}\spanOperator{.}\spanIdentifier{add}\spanPunctuation{(}\spanStringLit{"asd"}\spanPunctuation{)}
\end{rstpre}
This can be fixed by explicitly using \texttt{return}:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{get\_x}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{Foo}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}} \spanOperator{=}
  \spanKeyword{case} \spanIdentifier{true}
  \spanKeyword{of} \spanIdentifier{true}\spanPunctuation{:}
    \spanKeyword{return} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{x}
  \spanKeyword{else}\spanPunctuation{:}
    \spanKeyword{return} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{x}
\end{rstpre}
\rsthB{When statement}\label{statements-and-expressions-when-statement}
Example:

\begin{rstpre}
\spanKeyword{when} \spanIdentifier{sizeof}\spanPunctuation{(}\spanIdentifier{int}\spanPunctuation{)} \spanOperator{==} \spanDecNumber{2}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"running on a 16 bit system!"}
\spanKeyword{elif} \spanIdentifier{sizeof}\spanPunctuation{(}\spanIdentifier{int}\spanPunctuation{)} \spanOperator{==} \spanDecNumber{4}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"running on a 32 bit system!"}
\spanKeyword{elif} \spanIdentifier{sizeof}\spanPunctuation{(}\spanIdentifier{int}\spanPunctuation{)} \spanOperator{==} \spanDecNumber{8}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"running on a 64 bit system!"}
\spanKeyword{else}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"cannot happen!"}
\end{rstpre}
The \texttt{when} statement is almost identical to the \texttt{if} statement with some exceptions:

\begin{itemize}\item Each condition (\texttt{expr}) has to be a constant expression (of type \texttt{bool}).
\item The statements do not open a new scope.
\item The statements that belong to the expression that evaluated to true are translated by the compiler, the other statements are not checked for semantics! However, each condition is checked for semantics.
\end{itemize}
The \texttt{when} statement enables conditional compilation techniques. As a special syntactic extension, the \texttt{when} construct is also available within \texttt{object} definitions.

\rsthB{When nimvm statement}\label{statements-and-expressions-when-nimvm-statement}
\texttt{nimvm} is a special symbol, that may be used as expression of \texttt{when nimvm} statement to differentiate execution path between compile time and the executable.

Example:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{someProcThatMayRunInCompileTime}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanKeyword{when} \spanIdentifier{nimvm}\spanPunctuation{:}
    \spanComment{\# This branch is taken at compile time.}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{true}
  \spanKeyword{else}\spanPunctuation{:}
    \spanComment{\# This branch is taken in the executable.}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{false}
\spanKeyword{const} \spanIdentifier{ctValue} \spanOperator{=} \spanIdentifier{someProcThatMayRunInCompileTime}\spanPunctuation{(}\spanPunctuation{)}
\spanKeyword{let} \spanIdentifier{rtValue} \spanOperator{=} \spanIdentifier{someProcThatMayRunInCompileTime}\spanPunctuation{(}\spanPunctuation{)}
\spanIdentifier{assert}\spanPunctuation{(}\spanIdentifier{ctValue} \spanOperator{==} \spanIdentifier{true}\spanPunctuation{)}
\spanIdentifier{assert}\spanPunctuation{(}\spanIdentifier{rtValue} \spanOperator{==} \spanIdentifier{false}\spanPunctuation{)}
\end{rstpre}
\texttt{when nimvm} statement must meet the following requirements:

\begin{itemize}\item Its expression must always be \texttt{nimvm}. More complex expressions are not allowed.
\item It must not contain \texttt{elif} branches.
\item It must contain \texttt{else} branch.
\item Code in branches must not affect semantics of the code that follows the \texttt{when nimvm} statement. E.g. it must not define symbols that are used in the following code.
\end{itemize}
\rsthB{Return statement}\label{statements-and-expressions-return-statement}
Example:

\begin{rstpre}
\spanKeyword{return} \spanDecNumber{40}\spanOperator{+}\spanDecNumber{2}
\end{rstpre}
The \texttt{return} statement ends the execution of the current procedure. It is only allowed in procedures. If there is an \texttt{expr}, this is syntactic sugar for:

\begin{rstpre}
\spanIdentifier{result} \spanOperator{=} \spanIdentifier{expr}
\spanKeyword{return} \spanIdentifier{result}
\end{rstpre}
\texttt{return} without an expression is a short notation for \texttt{return result} if the proc has a return type. The result\label{result_1} variable is always the return value of the procedure. It is automatically declared by the compiler. As all variables, \texttt{result} is initialized to (binary) zero:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{returnZero}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanComment{\# implicitly returns 0}
\end{rstpre}
\rsthB{Yield statement}\label{statements-and-expressions-yield-statement}
Example:

\begin{rstpre}
\spanKeyword{yield} \spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{)}
\end{rstpre}
The \texttt{yield} statement is used instead of the \texttt{return} statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but execution is passed back to the iterator if the next iteration starts. See the section about iterators (Iterators and the for statement\ref{iterators-and-the-for-statement}) for further information.

\rsthB{Block statement}\label{statements-and-expressions-block-statement}
Example:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{found} \spanOperator{=} \spanIdentifier{false}
\spanKeyword{block} \spanIdentifier{myblock}\spanPunctuation{:}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{3}\spanPunctuation{:}
    \spanKeyword{for} \spanIdentifier{j} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{3}\spanPunctuation{:}
      \spanKeyword{if} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{j}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{==} \spanDecNumber{7}\spanPunctuation{:}
        \spanIdentifier{found} \spanOperator{=} \spanIdentifier{true}
        \spanKeyword{break} \spanIdentifier{myblock} \spanComment{\# leave the block, in this case both for-loops}
\spanIdentifier{echo} \spanIdentifier{found}
\end{rstpre}
The block statement is a means to group statements to a (named) \texttt{block}. Inside the block, the \texttt{break} statement is allowed to leave the block immediately. A \texttt{break} statement can contain a name of a surrounding block to specify which block is to leave.

\rsthB{Break statement}\label{statements-and-expressions-break-statement}
Example:

\begin{rstpre}
\spanKeyword{break}
\end{rstpre}
The \texttt{break} statement is used to leave a block immediately. If \texttt{symbol} is given, it is the name of the enclosing block that is to leave. If it is absent, the innermost block is left.

\rsthB{While statement}\label{statements-and-expressions-while-statement}
Example:

\begin{rstpre}
\spanIdentifier{echo} \spanStringLit{"Please tell me your password:"}
\spanKeyword{var} \spanIdentifier{pw} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}
\spanKeyword{while} \spanIdentifier{pw} \spanOperator{!=} \spanStringLit{"12345"}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"Wrong password! Next try:"}
  \spanIdentifier{pw} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{stdin}\spanPunctuation{)}
\end{rstpre}
The \texttt{while} statement is executed until the \texttt{expr} evaluates to false. Endless loops are no error. \texttt{while} statements open an \texttt{implicit block}, so that they can be left with a \texttt{break} statement.

\rsthB{Continue statement}\label{statements-and-expressions-continue-statement}
A \texttt{continue} statement leads to the immediate next iteration of the surrounding loop construct. It is only allowed within a loop. A continue statement is syntactic sugar for a nested block:

\begin{rstpre}
\spanKeyword{while} \spanIdentifier{expr1}\spanPunctuation{:}
  \spanIdentifier{stmt1}
  \spanKeyword{continue}
  \spanIdentifier{stmt2}
\end{rstpre}
Is equivalent to:

\begin{rstpre}
\spanKeyword{while} \spanIdentifier{expr1}\spanPunctuation{:}
  \spanKeyword{block} \spanIdentifier{myBlockName}\spanPunctuation{:}
    \spanIdentifier{stmt1}
    \spanKeyword{break} \spanIdentifier{myBlockName}
    \spanIdentifier{stmt2}
\end{rstpre}
\rsthB{Assembler statement}\label{statements-and-expressions-assembler-statement}
The direct embedding of assembler code into Nim code is supported by the unsafe \texttt{asm} statement. Identifiers in the assembler code that refer to Nim identifiers shall be enclosed in a special character which can be specified in the statement's pragmas. The default special character is \texttt{'\symbol{96}'}:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{push} \spanIdentifier{stackTrace}\spanPunctuation{:}\spanIdentifier{off}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanIdentifier{addInt}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanComment{\# a in eax, and b in edx}
  \spanKeyword{asm} \spanLongStringLit{"""
      mov eax, \symbol{96}a\symbol{96}
      add eax, \symbol{96}b\symbol{96}
      jno theEnd
      call \symbol{96}raiseOverflow\symbol{96}
    theEnd:
  """}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pop}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
If the GNU assembler is used, quotes and newlines are inserted automatically:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{addInt}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanKeyword{asm} \spanLongStringLit{"""
    addl \%\%ecx, \%\%eax
    jno 1
    call \symbol{96}raiseOverflow\symbol{96}
    1:
    :"=a"(\symbol{96}result\symbol{96})
    :"a"(\symbol{96}a\symbol{96}), "c"(\symbol{96}b\symbol{96})
  """}
\end{rstpre}
Instead of:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{addInt}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanKeyword{asm} \spanLongStringLit{"""
    "addl \%\%ecx, \%\%eax\symbol{92}n"
    "jno 1\symbol{92}n"
    "call \symbol{96}raiseOverflow\symbol{96}\symbol{92}n"
    "1: \symbol{92}n"
    :"=a"(\symbol{96}result\symbol{96})
    :"a"(\symbol{96}a\symbol{96}), "c"(\symbol{96}b\symbol{96})
  """}
\end{rstpre}
\rsthB{Using statement}\label{statements-and-expressions-using-statement}
The using statement provides syntactic convenience in modules where the same parameter names and types are used over and over. Instead of:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{:} \spanIdentifier{Context}\spanPunctuation{;} \spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{Node}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}
\spanKeyword{proc} \spanIdentifier{bar}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{:} \spanIdentifier{Context}\spanPunctuation{;} \spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{Node}\spanPunctuation{,} \spanIdentifier{counter}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}
\spanKeyword{proc} \spanIdentifier{baz}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{:} \spanIdentifier{Context}\spanPunctuation{;} \spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{Node}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}
\end{rstpre}
One can tell the compiler about the convention that a parameter of name \texttt{c} should default to type \texttt{Context}, \texttt{n} should default to \texttt{Node} etc.:

\begin{rstpre}
\spanKeyword{using}
  \spanIdentifier{c}\spanPunctuation{:} \spanIdentifier{Context}
  \spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{Node}
  \spanIdentifier{counter}\spanPunctuation{:} \spanIdentifier{int}

\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{,} \spanIdentifier{n}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}
\spanKeyword{proc} \spanIdentifier{bar}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{,} \spanIdentifier{n}\spanPunctuation{,} \spanIdentifier{counter}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}
\spanKeyword{proc} \spanIdentifier{baz}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{,} \spanIdentifier{n}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}

\spanKeyword{proc} \spanIdentifier{mixedMode}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{,} \spanIdentifier{n}\spanPunctuation{;} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# 'c' is inferred to be of the type 'Context'}
  \spanComment{\# 'n' is inferred to be of the type 'Node'}
  \spanComment{\# But 'x' and 'y' are of type 'int'.}
\end{rstpre}
The \texttt{using} section uses the same indentation based grouping syntax as a \texttt{var} or \texttt{let} section.

Note that \texttt{using} is not applied for \texttt{template} since untyped template parameters default to the type \texttt{system.untyped}.

Mixing parameters that should use the \texttt{using} declaration with parameters that are explicitly typed is possible and requires a semicolon between them.

\rsthB{If expression}\label{statements-and-expressions-if-expression}
An \texttt{if expression} is almost like an if statement, but it is an expression. This feature is similar to \texttt{ternary operators} in other languages. Example:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{y} \spanOperator{=} \spanKeyword{if} \spanIdentifier{x} \spanOperator{>} \spanDecNumber{8}\spanPunctuation{:} \spanDecNumber{9} \spanKeyword{else}\spanPunctuation{:} \spanDecNumber{10}
\end{rstpre}
An if expression always results in a value, so the \texttt{else} part is required. \texttt{Elif} parts are also allowed.

\rsthB{When expression}\label{statements-and-expressions-when-expression}
Just like an \texttt{if expression}, but corresponding to the when statement.

\rsthB{Case expression}\label{statements-and-expressions-case-expression}
The \texttt{case expression} is again very similar to the case statement:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{favoriteFood} \spanOperator{=} \spanKeyword{case} \spanIdentifier{animal}
  \spanKeyword{of} \spanStringLit{"dog"}\spanPunctuation{:} \spanStringLit{"bones"}
  \spanKeyword{of} \spanStringLit{"cat"}\spanPunctuation{:} \spanStringLit{"mice"}
  \spanKeyword{elif} \spanIdentifier{animal}\spanOperator{.}\spanRawData{endsWith"whale"}\spanPunctuation{:} \spanStringLit{"plankton"}
  \spanKeyword{else}\spanPunctuation{:}
    \spanIdentifier{echo} \spanStringLit{"I'm not sure what to serve, but everybody loves ice cream"}
    \spanStringLit{"ice cream"}
\end{rstpre}
As seen in the above example, the case expression can also introduce side effects. When multiple statements are given for a branch, Nim will use the last expression as the result value.

\rsthB{Block expression}\label{statements-and-expressions-block-expression}
A \texttt{block expression} is almost like a block statement, but it is an expression that uses last expression under the block as the value. It is similar to the statement list expression, but the statement list expression does not open new block scope.

\begin{rstpre}
\spanKeyword{let} \spanIdentifier{a} \spanOperator{=} \spanKeyword{block}\spanPunctuation{:}
  \spanKeyword{var} \spanIdentifier{fib} \spanOperator{=} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{1}\spanPunctuation{\symbol{93}}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{10}\spanPunctuation{:}
    \spanIdentifier{fib}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{fib}\spanPunctuation{\symbol{91}}\spanOperator{\symbol{94}}\spanDecNumber{1}\spanPunctuation{\symbol{93}} \spanOperator{+} \spanIdentifier{fib}\spanPunctuation{\symbol{91}}\spanOperator{\symbol{94}}\spanDecNumber{2}\spanPunctuation{\symbol{93}}
  \spanIdentifier{fib}
\end{rstpre}
\rsthB{Table constructor}\label{statements-and-expressions-table-constructor}
A table constructor is syntactic sugar for an array constructor:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanStringLit{"key1"}\spanPunctuation{:} \spanStringLit{"value1"}\spanPunctuation{,} \spanStringLit{"key2"}\spanPunctuation{,} \spanStringLit{"key3"}\spanPunctuation{:} \spanStringLit{"value2"}\spanPunctuation{\symbol{125}}

\spanComment{\# is the same as:}
\spanPunctuation{\symbol{91}}\spanPunctuation{(}\spanStringLit{"key1"}\spanPunctuation{,} \spanStringLit{"value1"}\spanPunctuation{)}\spanPunctuation{,} \spanPunctuation{(}\spanStringLit{"key2"}\spanPunctuation{,} \spanStringLit{"value2"}\spanPunctuation{)}\spanPunctuation{,} \spanPunctuation{(}\spanStringLit{"key3"}\spanPunctuation{,} \spanStringLit{"value2"}\spanPunctuation{)}\spanPunctuation{\symbol{93}}
\end{rstpre}
The empty table can be written \texttt{\symbol{123}:\symbol{125}} (in contrast to the empty set which is \texttt{\symbol{123}\symbol{125}}) which is thus another way to write as the empty array constructor \texttt{\symbol{91}\symbol{93}}. This slightly unusual way of supporting tables has lots of advantages:

\begin{itemize}\item The order of the (key,value)-pairs is preserved, thus it is easy to support ordered dicts with for example \texttt{\symbol{123}key: val\symbol{125}.newOrderedTable}.
\item A table literal can be put into a \texttt{const} section and the compiler can easily put it into the executable's data section just like it can for arrays and the generated data section requires a minimal amount of memory.
\item Every table implementation is treated equal syntactically.
\item Apart from the minimal syntactic sugar the language core does not need to know about tables.
\end{itemize}
\rsthB{Type conversions}\label{statements-and-expressions-type-conversions}
Syntactically a \emph{type conversion} is like a procedure call, but a type name replaces the procedure name. A type conversion is always safe in the sense that a failure to convert a type to another results in an exception (if it cannot be determined statically).

Ordinary procs are often preferred over type conversions in Nim: For instance, \texttt{\$} is the \texttt{toString} operator by convention and \texttt{toFloat} and \texttt{toInt} can be used to convert from floating point to integer or vice versa.

A type conversion can also be used to disambiguate overloaded routines:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanStringLit{"int"}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanStringLit{"string"}

\spanKeyword{let} \spanIdentifier{procVar} \spanOperator{=} \spanPunctuation{(}\spanKeyword{proc}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{)}\spanPunctuation{(}\spanIdentifier{p}\spanPunctuation{)}
\spanIdentifier{procVar}\spanPunctuation{(}\spanStringLit{"a"}\spanPunctuation{)}
\end{rstpre}
Since operations on unsigned numbers wrap around and are unchecked so are type conversion to unsigned integers and between unsigned integers. The rationale for this is mostly better interoperability with the C Programming language when algorithms are ported from C to Nim.

Exception: Values that are converted to an unsigned type at compile time are checked so that code like \texttt{byte(-1)} does not compile.

\textbf{Note}: Historically the operations were unchecked and the conversions were sometimes checked but starting with the revision 1.0.4 of this document and the language implementation the conversions too are now \emph{always unchecked}.

\rsthB{Type casts}\label{statements-and-expressions-type-casts}
\emph{Type casts} are a crude mechanism to interpret the bit pattern of an expression as if it would be of another type. Type casts are only needed for low-level programming and are inherently unsafe.

\begin{rstpre}
\spanKeyword{cast}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}
\end{rstpre}
The target type of a cast must be a concrete type, for instance, a target type that is a type class (which is non-concrete) would be invalid:

\begin{rstpre}
\spanKeyword{type} \spanIdentifier{Foo} \spanOperator{=} \spanIdentifier{int} \spanKeyword{or} \spanIdentifier{float}
\spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanKeyword{cast}\spanPunctuation{\symbol{91}}\spanIdentifier{Foo}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{)} \spanComment{\# Error: cannot cast to a non concrete type: 'Foo'}
\end{rstpre}
Type casts should not be confused with \emph{type conversions,} as mentioned in the prior section. Unlike type conversions, a type cast cannot change the underlying bit pattern of the data being casted (aside from that the size of the target type may differ from the source type). Casting resembles \emph{type punning} in other languages or C++'s \texttt{reinterpret\_cast} and \texttt{bit\_cast} features.

\rsthB{The addr operator}\label{statements-and-expressions-the-addr-operator}
The \texttt{addr} operator returns the address of an l-value. If the type of the location is \texttt{T}, the \texttt{addr} operator result is of the type \texttt{ptr T}. An address is always an untraced reference. Taking the address of an object that resides on the stack is \textbf{unsafe}, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through \texttt{let} statements:

\begin{rstpre}
\spanKeyword{let} \spanIdentifier{t1} \spanOperator{=} \spanStringLit{"Hello"}
\spanKeyword{var}
  \spanIdentifier{t2} \spanOperator{=} \spanIdentifier{t1}
  \spanIdentifier{t3} \spanPunctuation{:} \spanIdentifier{pointer} \spanOperator{=} \spanKeyword{addr}\spanPunctuation{(}\spanIdentifier{t2}\spanPunctuation{)}
\spanIdentifier{echo} \spanIdentifier{repr}\spanPunctuation{(}\spanKeyword{addr}\spanPunctuation{(}\spanIdentifier{t2}\spanPunctuation{)}\spanPunctuation{)}
\spanComment{\# --> ref 0x7fff6b71b670 --> 0x10bb81050"Hello"}
\spanIdentifier{echo} \spanKeyword{cast}\spanPunctuation{\symbol{91}}\spanKeyword{ptr} \spanIdentifier{string}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{t3}\spanPunctuation{)}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}
\spanComment{\# --> Hello}
\spanComment{\# The following line doesn't compile:}
\spanIdentifier{echo} \spanIdentifier{repr}\spanPunctuation{(}\spanKeyword{addr}\spanPunctuation{(}\spanIdentifier{t1}\spanPunctuation{)}\spanPunctuation{)}
\spanComment{\# Error: expression has no address}
\end{rstpre}
\rsthB{The unsafeAddr operator}\label{statements-and-expressions-the-unsafeaddr-operator}
For easier interoperability with other compiled languages such as C, retrieving the address of a \texttt{let} variable, a parameter or a \texttt{for} loop variable, the \texttt{unsafeAddr} operation can be used:

\begin{rstpre}
\spanKeyword{let} \spanIdentifier{myArray} \spanOperator{=} \spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{\symbol{93}}
\spanIdentifier{foreignProcThatTakesAnAddr}\spanPunctuation{(}\spanIdentifier{unsafeAddr} \spanIdentifier{myArray}\spanPunctuation{)}
\end{rstpre}
\rsthA{Procedures}\label{procedures}
What most programming languages call methods\label{methods_1} or functions\label{functions_1} are called procedures\label{procedures_1} in Nim. A procedure declaration consists of an identifier, zero or more formal parameters, a return value type and a block of code. Formal parameters are declared as a list of identifiers separated by either comma or semicolon. A parameter is given a type by \texttt{: typename}. The type applies to all parameters immediately before it, until either the beginning of the parameter list, a semicolon separator or an already typed parameter, is reached. The semicolon can be used to make separation of types and subsequent identifiers more distinct.

\begin{rstpre}
\spanComment{\# Using only commas}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{c}\spanPunctuation{,} \spanIdentifier{d}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int}

\spanComment{\# Using semicolon for visual distinction}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{;} \spanIdentifier{c}\spanPunctuation{,} \spanIdentifier{d}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int}

\spanComment{\# Will fail: a is untyped since ';' stops type propagation.}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{;} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{;} \spanIdentifier{c}\spanPunctuation{,} \spanIdentifier{d}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int}
\end{rstpre}
A parameter may be declared with a default value which is used if the caller does not provide a value for the argument.

\begin{rstpre}
\spanComment{\# b is optional with 47 as its default value}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanDecNumber{47}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int}
\end{rstpre}
Parameters can be declared mutable and so allow the proc to modify those arguments, by using the type modifier \texttt{var}.

\begin{rstpre}
\spanComment{\# "returning" a value to the caller through the 2nd argument}
\spanComment{\# Notice that the function uses no actual return value at all (ie void)}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{inp}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{outp}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{outp} \spanOperator{=} \spanIdentifier{inp} \spanOperator{+} \spanDecNumber{47}
\end{rstpre}
If the proc declaration has no body, it is a forward\label{forward_1} declaration. If the proc returns a value, the procedure body can access an implicitly declared variable named result\label{result_2} that represents the return value. Procs can be overloaded. The overloading resolution algorithm determines which proc is the best match for the arguments. Example:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{toLower}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{:} \spanIdentifier{char}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{char} \spanOperator{=} \spanComment{\# toLower for characters}
  \spanKeyword{if} \spanIdentifier{c} \spanKeyword{in} \spanPunctuation{\symbol{123}}\spanCharLit{'A'}\spanOperator{..}\spanCharLit{'Z'}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{chr}\spanPunctuation{(}\spanIdentifier{ord}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{)} \spanOperator{+} \spanPunctuation{(}\spanIdentifier{ord}\spanPunctuation{(}\spanCharLit{'a'}\spanPunctuation{)} \spanOperator{-} \spanIdentifier{ord}\spanPunctuation{(}\spanCharLit{'A'}\spanPunctuation{)}\spanPunctuation{)}\spanPunctuation{)}
  \spanKeyword{else}\spanPunctuation{:}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{c}

\spanKeyword{proc} \spanIdentifier{toLower}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanComment{\# toLower for strings}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{newString}\spanPunctuation{(}\spanIdentifier{len}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{)}\spanPunctuation{)}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{)} \spanOperator{-} \spanDecNumber{1}\spanPunctuation{:}
    \spanIdentifier{result}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{toLower}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanComment{\# calls toLower for characters; no recursion!}
\end{rstpre}
Calling a procedure can be done in many different ways:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{callme}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanStringLit{""}\spanPunctuation{,} \spanIdentifier{c}\spanPunctuation{:} \spanIdentifier{char}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=} \spanIdentifier{false}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}

\spanComment{\# call with positional arguments      \# parameter bindings:}
\spanIdentifier{callme}\spanPunctuation{(}\spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{1}\spanPunctuation{,} \spanStringLit{"abc"}\spanPunctuation{,} \spanCharLit{'\symbol{92}t'}\spanPunctuation{,} \spanIdentifier{true}\spanPunctuation{)}       \spanComment{\# (x=0, y=1, s="abc", c='\symbol{92}t', b=true)}
\spanComment{\# call with named and positional arguments:}
\spanIdentifier{callme}\spanPunctuation{(}\spanIdentifier{y}\spanOperator{=}\spanDecNumber{1}\spanPunctuation{,} \spanIdentifier{x}\spanOperator{=}\spanDecNumber{0}\spanPunctuation{,} \spanStringLit{"abd"}\spanPunctuation{,} \spanCharLit{'\symbol{92}t'}\spanPunctuation{)}         \spanComment{\# (x=0, y=1, s="abd", c='\symbol{92}t', b=false)}
\spanComment{\# call with named arguments (order is not relevant):}
\spanIdentifier{callme}\spanPunctuation{(}\spanIdentifier{c}\spanOperator{=}\spanCharLit{'\symbol{92}t'}\spanPunctuation{,} \spanIdentifier{y}\spanOperator{=}\spanDecNumber{1}\spanPunctuation{,} \spanIdentifier{x}\spanOperator{=}\spanDecNumber{0}\spanPunctuation{)}              \spanComment{\# (x=0, y=1, s="", c='\symbol{92}t', b=false)}
\spanComment{\# call as a command statement: no () needed:}
\spanIdentifier{callme} \spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{1}\spanPunctuation{,} \spanStringLit{"abc"}\spanPunctuation{,} \spanCharLit{'\symbol{92}t'}              \spanComment{\# (x=0, y=1, s="abc", c='\symbol{92}t', b=false)}
\end{rstpre}
A procedure may call itself recursively.

Operators\label{operators_1} are procedures with a special operator symbol as identifier:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{\$}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanComment{\# converts an integer to a string; this is a prefix operator.}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{intToStr}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}
\end{rstpre}
Operators with one parameter are prefix operators, operators with two parameters are infix operators. (However, the parser distinguishes these from the operator's position within an expression.) There is no way to declare postfix operators: all postfix operators are built-in and handled by the grammar explicitly.

Any operator can be called like an ordinary proc with the '\texttt{opr}' notation. (Thus an operator can have more than two parameters):

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{*+}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{,} \spanIdentifier{c}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanComment{\# Multiply and add}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{a} \spanOperator{*} \spanIdentifier{b} \spanOperator{+} \spanIdentifier{c}

\spanIdentifier{assert} \spanPunctuation{\symbol{96}}\spanOperator{*+}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{,} \spanDecNumber{6}\spanPunctuation{)} \spanOperator{==} \spanPunctuation{\symbol{96}}\spanOperator{+}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{c}\spanPunctuation{)}
\end{rstpre}
\rsthB{Export marker}\label{procedures-export-marker}
If a declared symbol is marked with an asterisk\label{asterisk_1} it is exported from the current module:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{exportedEcho}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanIdentifier{s}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{;} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{newStringOfCap}\spanPunctuation{(}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{len} \spanOperator{*} \spanIdentifier{b}\spanPunctuation{)}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{1.}\spanOperator{.}\spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{a}

\spanKeyword{var} \spanIdentifier{exportedVar}\spanOperator{*:} \spanIdentifier{int}
\spanKeyword{const} \spanIdentifier{exportedConst}\spanOperator{*} \spanOperator{=} \spanDecNumber{78}
\spanKeyword{type}
  \spanIdentifier{ExportedType}\spanOperator{*} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{exportedField}\spanOperator{*:} \spanIdentifier{int}
\end{rstpre}
\rsthB{Method call syntax}\label{procedures-method-call-syntax}
For object oriented programming, the syntax \texttt{obj.method(args)} can be used instead of \texttt{method(obj, args)}. The parentheses can be omitted if there are no remaining arguments: \texttt{obj.len} (instead of \texttt{len(obj)}).

This method call syntax is not restricted to objects, it can be used to supply any type of first argument for procedures:

\begin{rstpre}
\spanIdentifier{echo} \spanStringLit{"abc"}\spanOperator{.}\spanIdentifier{len} \spanComment{\# is the same as echo len "abc"}
\spanIdentifier{echo} \spanStringLit{"abc"}\spanOperator{.}\spanIdentifier{toUpper}\spanPunctuation{(}\spanPunctuation{)}
\spanIdentifier{echo} \spanPunctuation{\symbol{123}}\spanCharLit{'a'}\spanPunctuation{,} \spanCharLit{'b'}\spanPunctuation{,} \spanCharLit{'c'}\spanPunctuation{\symbol{125}}\spanOperator{.}\spanIdentifier{card}
\spanIdentifier{stdout}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanStringLit{"Hallo"}\spanPunctuation{)} \spanComment{\# the same as writeLine(stdout, "Hallo")}
\end{rstpre}
Another way to look at the method call syntax is that it provides the missing postfix notation.

The method call syntax conflicts with explicit generic instantiations: \texttt{p\symbol{91}T\symbol{93}(x)} cannot be written as \texttt{x.p\symbol{91}T\symbol{93}} because \texttt{x.p\symbol{91}T\symbol{93}} is always parsed as \texttt{(x.p)\symbol{91}T\symbol{93}}.

See also: \href{\#templates-limitations-of-the-method-call-syntax}{Limitations of the method call syntax}.

The \texttt{\symbol{91}: \symbol{93}} notation has been designed to mitigate this issue: \texttt{x.p\symbol{91}:T\symbol{93}} is rewritten by the parser to \texttt{p\symbol{91}T\symbol{93}(x)}, \texttt{x.p\symbol{91}:T\symbol{93}(y)} is rewritten to \texttt{p\symbol{91}T\symbol{93}(x, y)}. Note that \texttt{\symbol{91}: \symbol{93}} has no AST representation, the rewrite is performed directly in the parsing step.

\rsthB{Properties}\label{procedures-properties}
Nim has no need for \emph{get-properties}: Ordinary get-procedures that are called with the \emph{method call syntax} achieve the same. But setting a value is different; for this a special setter syntax is needed:

\begin{rstpre}
\spanComment{\# Module asocket}
\spanKeyword{type}
  \spanIdentifier{Socket}\spanOperator{*} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{RootObj}
    \spanIdentifier{host}\spanPunctuation{:} \spanIdentifier{int} \spanComment{\# cannot be accessed from the outside of the module}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanIdentifier{host}\spanOperator{=}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{Socket}\spanPunctuation{,} \spanIdentifier{value}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{inline}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanComment{\#\# setter of hostAddr.}
  \spanComment{\#\# This accesses the 'host' field and is not a recursive call to}
  \spanComment{\#\# \symbol{96}\symbol{96}host=\symbol{96}\symbol{96} because the builtin dot access is preferred if it is}
  \spanComment{\#\# available:}
  \spanIdentifier{s}\spanOperator{.}\spanIdentifier{host} \spanOperator{=} \spanIdentifier{value}

\spanKeyword{proc} \spanIdentifier{host}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{Socket}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{inline}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanComment{\#\# getter of hostAddr}
  \spanComment{\#\# This accesses the 'host' field and is not a recursive call to}
  \spanComment{\#\# \symbol{96}\symbol{96}host\symbol{96}\symbol{96} because the builtin dot access is preferred if it is}
  \spanComment{\#\# available:}
  \spanIdentifier{s}\spanOperator{.}\spanIdentifier{host}
\end{rstpre}
\begin{rstpre}
\spanComment{\# module B}
\spanKeyword{import} \spanIdentifier{asocket}
\spanKeyword{var} \spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{Socket}
\spanIdentifier{new} \spanIdentifier{s}
\spanIdentifier{s}\spanOperator{.}\spanIdentifier{host} \spanOperator{=} \spanDecNumber{34}  \spanComment{\# same as \symbol{96}host=\symbol{96}(s, 34)}
\end{rstpre}
A proc defined as \texttt{f=} (with the trailing \texttt{=}) is called a setter\label{setter_1}. A setter can be called explicitly via the common backticks notation:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanIdentifier{f}\spanOperator{=}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{MyObject}\spanPunctuation{;} \spanIdentifier{value}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{discard}

\spanPunctuation{\symbol{96}}\spanIdentifier{f}\spanOperator{=}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{myObject}\spanPunctuation{,} \spanStringLit{"value"}\spanPunctuation{)}
\end{rstpre}
\texttt{f=} can be called implicitly in the pattern \texttt{x.f = value} if and only if the type of \texttt{x} does not have a field named \texttt{f} or if \texttt{f} is not visible in the current module. These rules ensure that object fields and accessors can have the same name. Within the module \texttt{x.f} is then always interpreted as field access and outside the module it is interpreted as an accessor proc call.

\rsthB{Command invocation syntax}\label{procedures-command-invocation-syntax}
Routines can be invoked without the \texttt{()} if the call is syntactically a statement. This command invocation syntax also works for expressions, but then only a single argument may follow. This restriction means \texttt{echo f 1, f 2} is parsed as \texttt{echo(f(1), f(2))} and not as \texttt{echo(f(1, f(2)))}. The method call syntax may be used to provide one more argument in this case:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{optarg}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanDecNumber{0}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanIdentifier{x} \spanOperator{+} \spanIdentifier{y}
\spanKeyword{proc} \spanIdentifier{singlearg}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanDecNumber{20}\spanOperator{*}\spanIdentifier{x}

\spanIdentifier{echo} \spanIdentifier{optarg} \spanDecNumber{1}\spanPunctuation{,} \spanStringLit{" "}\spanPunctuation{,} \spanIdentifier{singlearg} \spanDecNumber{2}  \spanComment{\# prints "1 40"}

\spanKeyword{let} \spanIdentifier{fail} \spanOperator{=} \spanIdentifier{optarg} \spanDecNumber{1}\spanPunctuation{,} \spanIdentifier{optarg} \spanDecNumber{8}   \spanComment{\# Wrong. Too many arguments for a command call}
\spanKeyword{let} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{optarg}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{,} \spanIdentifier{optarg} \spanDecNumber{8}\spanPunctuation{)}  \spanComment{\# traditional procedure call with 2 arguments}
\spanKeyword{let} \spanIdentifier{y} \spanOperator{=} \spanFloatNumber{1.}\spanIdentifier{optarg} \spanIdentifier{optarg} \spanDecNumber{8}    \spanComment{\# same thing as above, w/o the parenthesis}
\spanIdentifier{assert} \spanIdentifier{x} \spanOperator{==} \spanIdentifier{y}
\end{rstpre}
The command invocation syntax also can't have complex expressions as arguments. For example: (\href{\#procedures-anonymous-procs}{anonymous procs}), \texttt{if}, \texttt{case} or \texttt{try}. Function calls with no arguments still needs () to distinguish between a call and the function itself as a first class value.

\rsthB{Closures}\label{procedures-closures}
Procedures can appear at the top level in a module as well as inside other scopes, in which case they are called nested procs. A nested proc can access local variables from its enclosing scope and if it does so it becomes a closure. Any captured variables are stored in a hidden additional argument to the closure (its environment) and they are accessed by reference by both the closure and its enclosing scope (i.e. any modifications made to them are visible in both places). The closure environment may be allocated on the heap or on the stack if the compiler determines that this would be safe.

\rsthC{Creating closures in loops}\label{closures-creating-closures-in-loops}
Since closures capture local variables by reference it is often not wanted behavior inside loop bodies. See \href{system.html\#closureScope.t,untyped}{closureScope} and \href{sugar.html\#capture.m,openArray\symbol{91}typed\symbol{93},untyped}{capture} for details on how to change this behavior.

\rsthB{Anonymous Procs}\label{procedures-anonymous-procs}
Unnamed procedures can be used as lambda expressions to pass into other procedures:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{cities} \spanOperator{=} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanStringLit{"Frankfurt"}\spanPunctuation{,} \spanStringLit{"Tokyo"}\spanPunctuation{,} \spanStringLit{"New York"}\spanPunctuation{,} \spanStringLit{"Kyiv"}\spanPunctuation{\symbol{93}}

\spanIdentifier{cities}\spanOperator{.}\spanIdentifier{sort}\spanPunctuation{(}\spanKeyword{proc} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,}\spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
    \spanIdentifier{cmp}\spanPunctuation{(}\spanIdentifier{x}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{,} \spanIdentifier{y}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{)}\spanPunctuation{)}
\end{rstpre}
Procs as expressions can appear both as nested procs and inside top level executable code. The  \href{sugar.html}{sugar} module contains the \texttt{=>} macro which enables a more succinct syntax for anonymous procedures resembling lambdas as they are in languages like JavaScript, C\#, etc.

\rsthB{Func}\label{procedures-func}
The \texttt{func} keyword introduces a shortcut for a noSideEffect\label{nosideeffect_1} proc.

\begin{rstpre}
\spanKeyword{func} \spanIdentifier{binarySearch}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{openArray}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{;} \spanIdentifier{elem}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int}
\end{rstpre}
Is short for:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{binarySearch}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{openArray}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{;} \spanIdentifier{elem}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{noSideEffect}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\rsthB{Nonoverloadable builtins}\label{procedures-nonoverloadable-builtins}
The following builtin procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):\begin{rstpre}

declared, defined, definedInScope, compiles, sizeof,
is, shallowCopy, getAst, astToStr, spawn, procCall
\end{rstpre}


Thus they act more like keywords than like ordinary identifiers; unlike a keyword however, a redefinition may shadow\label{shadow_1} the definition in the \texttt{system} module. From this list the following should not be written in dot notation \texttt{x.f} since \texttt{x} cannot be type checked before it gets passed to \texttt{f}:\begin{rstpre}

declared, defined, definedInScope, compiles, getAst, astToStr
\end{rstpre}


\rsthB{Var parameters}\label{procedures-var-parameters}
The type of a parameter may be prefixed with the \texttt{var} keyword:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{divmod}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{;} \spanIdentifier{res}\spanPunctuation{,} \spanIdentifier{remainder}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{res} \spanOperator{=} \spanIdentifier{a} \spanKeyword{div} \spanIdentifier{b}
  \spanIdentifier{remainder} \spanOperator{=} \spanIdentifier{a} \spanKeyword{mod} \spanIdentifier{b}

\spanKeyword{var}
  \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}

\spanIdentifier{divmod}\spanPunctuation{(}\spanDecNumber{8}\spanPunctuation{,} \spanDecNumber{5}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{)} \spanComment{\# modifies x and y}
\spanIdentifier{assert} \spanIdentifier{x} \spanOperator{==} \spanDecNumber{1}
\spanIdentifier{assert} \spanIdentifier{y} \spanOperator{==} \spanDecNumber{3}
\end{rstpre}
In the example, \texttt{res} and \texttt{remainder} are \texttt{var parameters}. Var parameters can be modified by the procedure and the changes are visible to the caller. The argument passed to a var parameter has to be an l-value. Var parameters are implemented as hidden pointers. The above example is equivalent to:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{divmod}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{;} \spanIdentifier{res}\spanPunctuation{,} \spanIdentifier{remainder}\spanPunctuation{:} \spanKeyword{ptr} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{res}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{a} \spanKeyword{div} \spanIdentifier{b}
  \spanIdentifier{remainder}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{a} \spanKeyword{mod} \spanIdentifier{b}

\spanKeyword{var}
  \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}
\spanIdentifier{divmod}\spanPunctuation{(}\spanDecNumber{8}\spanPunctuation{,} \spanDecNumber{5}\spanPunctuation{,} \spanKeyword{addr}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}\spanPunctuation{,} \spanKeyword{addr}\spanPunctuation{(}\spanIdentifier{y}\spanPunctuation{)}\spanPunctuation{)}
\spanIdentifier{assert} \spanIdentifier{x} \spanOperator{==} \spanDecNumber{1}
\spanIdentifier{assert} \spanIdentifier{y} \spanOperator{==} \spanDecNumber{3}
\end{rstpre}
In the examples, var parameters or pointers are used to provide two return values. This can be done in a cleaner way by returning a tuple:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{divmod}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{tuple}\spanPunctuation{\symbol{91}}\spanIdentifier{res}\spanPunctuation{,} \spanIdentifier{remainder}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{\symbol{93}} \spanOperator{=}
  \spanPunctuation{(}\spanIdentifier{a} \spanKeyword{div} \spanIdentifier{b}\spanPunctuation{,} \spanIdentifier{a} \spanKeyword{mod} \spanIdentifier{b}\spanPunctuation{)}

\spanKeyword{var} \spanIdentifier{t} \spanOperator{=} \spanIdentifier{divmod}\spanPunctuation{(}\spanDecNumber{8}\spanPunctuation{,} \spanDecNumber{5}\spanPunctuation{)}

\spanIdentifier{assert} \spanIdentifier{t}\spanOperator{.}\spanIdentifier{res} \spanOperator{==} \spanDecNumber{1}
\spanIdentifier{assert} \spanIdentifier{t}\spanOperator{.}\spanIdentifier{remainder} \spanOperator{==} \spanDecNumber{3}
\end{rstpre}
One can use tuple unpacking\label{tuple-unpacking_1} to access the tuple's fields:

\begin{rstpre}
\spanKeyword{var} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{divmod}\spanPunctuation{(}\spanDecNumber{8}\spanPunctuation{,} \spanDecNumber{5}\spanPunctuation{)} \spanComment{\# tuple unpacking}
\spanIdentifier{assert} \spanIdentifier{x} \spanOperator{==} \spanDecNumber{1}
\spanIdentifier{assert} \spanIdentifier{y} \spanOperator{==} \spanDecNumber{3}
\end{rstpre}
\textbf{Note}: \texttt{var} parameters are never necessary for efficient parameter passing. Since non-var parameters cannot be modified the compiler is always free to pass arguments by reference if it considers it can speed up execution.

\rsthB{Var return type}\label{procedures-var-return-type}
A proc, converter or iterator may return a \texttt{var} type which means that the returned value is an l-value and can be modified by the caller:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{g} \spanOperator{=} \spanDecNumber{0}

\spanKeyword{proc} \spanIdentifier{writeAccessToG}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{g}

\spanIdentifier{writeAccessToG}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=} \spanDecNumber{6}
\spanIdentifier{assert} \spanIdentifier{g} \spanOperator{==} \spanDecNumber{6}
\end{rstpre}
It is a static error if the implicitly introduced pointer could be used to access a location beyond its lifetime:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{writeAccessToG}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{int} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{g} \spanOperator{=} \spanDecNumber{0}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{g} \spanComment{\# Error!}
\end{rstpre}
For iterators, a component of a tuple return type can have a \texttt{var} type too:

\begin{rstpre}
\spanKeyword{iterator} \spanIdentifier{mpairs}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{tuple}\spanPunctuation{\symbol{91}}\spanIdentifier{key}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{,} \spanIdentifier{val}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{string}\spanPunctuation{\symbol{93}} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{high}\spanPunctuation{:}
    \spanKeyword{yield} \spanPunctuation{(}\spanIdentifier{i}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
In the standard library every name of a routine that returns a \texttt{var} type starts with the prefix \texttt{m} per convention.

Memory safety for returning by \texttt{var T} is ensured by a simple borrowing rule: If \texttt{result} does not refer to a location pointing to the heap (that is in \texttt{result = X} the \texttt{X} involves a \texttt{ptr} or \texttt{ref} access) then it has to be derived from the routine's first parameter:\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{forward}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{T}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{T} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{x} \spanComment{\# ok, derived from the first parameter.}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{param}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{int} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}
  \spanComment{\# we know 'forward' provides a view into the location derived from}
  \spanComment{\# its first argument 'x'.}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{forward}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)} \spanComment{\# Error: location is derived from \symbol{96}\symbol{96}x\symbol{96}\symbol{96}}
                      \spanComment{\# which is not p's first parameter and lives}
                      \spanComment{\# on the stack.}
\end{rstpre}
In other words, the lifetime of what \texttt{result} points to is attached to the lifetime of the first parameter and that is enough knowledge to verify memory safety at the callsite.

\rsthC{Future directions}\label{var-return-type-future-directions}
Later versions of Nim can be more precise about the borrowing rule with a syntax like:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{(}\spanIdentifier{other}\spanPunctuation{:} \spanIdentifier{Y}\spanPunctuation{;} \spanIdentifier{container}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{X}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{T} \spanKeyword{from} \spanIdentifier{container}
\end{rstpre}
Here \texttt{var T from container} explicitly exposes that the location is derived from the second parameter (called 'container' in this case). The syntax \texttt{var T from p} specifies a type \texttt{varTy\symbol{91}T, 2\symbol{93}} which is incompatible with \texttt{varTy\symbol{91}T, 1\symbol{93}}.

\rsthB{NRVO}\label{procedures-nrvo}
\textbf{Note}: This section describes the current implementation. This part of the language specification will be changed. See \href{https://github.com/nim-lang/RFCs/issues/230}{https://github.com/nim-lang/RFCs/issues/230} for more information.

The return value is represented inside the body of a routine as the special result\label{result_3} variable. This allows for a mechanism much like C++'s "named return value optimization" (NRVO\label{nrvo_1}). NRVO means that the stores to \texttt{result} inside \texttt{p} directly affect the destination \texttt{dest} in \texttt{let/var dest = p(args)} (definition of \texttt{dest}) and also in \texttt{dest = p(args)} (assignment to \texttt{dest}). This is achieved by rewriting \texttt{dest = p(args)} to \texttt{p'(args, dest)} where \texttt{p'} is a variation of \texttt{p} that returns \texttt{void} and receives a hidden mutable parameter representing \texttt{result}.

Informally:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{BigT} \spanOperator{=} \spanOperator{...}

\spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)}
\spanIdentifier{x} \spanOperator{=} \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)}

\spanComment{\# is roughly turned into:}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{BigT}\spanPunctuation{)} \spanOperator{=} \spanOperator{...}

\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{;} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}
\spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}
\end{rstpre}
Let \texttt{T}'s be \texttt{p}'s return type. NRVO applies for \texttt{T} if \texttt{sizeof(T) >= N} (where \texttt{N} is implementation dependent), in other words, it applies for "big" structures.

If \texttt{p} can raise an exception, NRVO applies regardless. This can produce observable differences in behavior:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{BigT} \spanOperator{=} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanDecNumber{16}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{\symbol{93}}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{raiseAt}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{BigT} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanIdentifier{high}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{)}\spanPunctuation{:}
    \spanKeyword{if} \spanIdentifier{i} \spanOperator{==} \spanIdentifier{raiseAt}\spanPunctuation{:} \spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{ValueError}\spanPunctuation{,} \spanStringLit{"interception"}\spanPunctuation{)}
    \spanIdentifier{result}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{i}

\spanKeyword{proc} \spanIdentifier{main} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{BigT}
  \spanKeyword{try}\spanPunctuation{:}
    \spanIdentifier{x} \spanOperator{=} \spanIdentifier{p}\spanPunctuation{(}\spanDecNumber{8}\spanPunctuation{)}
  \spanKeyword{except} \spanIdentifier{ValueError}\spanPunctuation{:}
    \spanIdentifier{doAssert} \spanIdentifier{x} \spanOperator{==} \spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{,} \spanDecNumber{5}\spanPunctuation{,} \spanDecNumber{6}\spanPunctuation{,} \spanDecNumber{7}\spanPunctuation{,} \spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{0}\spanPunctuation{,} \spanDecNumber{0}\spanPunctuation{\symbol{93}}

\spanIdentifier{main}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
However, the current implementation produces a warning in these cases. There are different ways to deal with this warning:

\begin{enumerate}\item Disable the warning via \texttt{\symbol{123}.push warning\symbol{91}ObservableStores\symbol{93}: off.\symbol{125}} ... \texttt{\symbol{123}.pop.\symbol{125}}. Then one may need to ensure that \texttt{p} only raises \emph{before} any stores to \texttt{result} happen.
\item One can use a temporary helper variable, for example instead of \texttt{x = p(8)} use \texttt{let tmp = p(8); x = tmp}.
\end{enumerate}
\rsthB{Overloading of the subscript operator}\label{procedures-overloading-of-the-subscript-operator}
The \texttt{\symbol{91}\symbol{93}} subscript operator for arrays/openarrays/sequences can be overloaded.

\rsthA{Multi-methods}\label{multiminusmethods}
\textbf{Note:} Starting from Nim 0.20, to use multi-methods one must explicitly pass \texttt{--multimethods:on} when compiling.

Procedures always use static dispatch. Multi-methods use dynamic dispatch. For dynamic dispatch to work on an object it should be a reference type.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Expression} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{RootObj} \spanComment{\#\# abstract base class for an expression}
  \spanIdentifier{Literal} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Expression}
    \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}
  \spanIdentifier{PlusExpr} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Expression}
    \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Expression}

\spanKeyword{method} \spanIdentifier{eval}\spanPunctuation{(}\spanIdentifier{e}\spanPunctuation{:} \spanIdentifier{Expression}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{base}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanComment{\# override this base method}
  \spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{CatchableError}\spanPunctuation{,} \spanStringLit{"Method without implementation override"}\spanPunctuation{)}

\spanKeyword{method} \spanIdentifier{eval}\spanPunctuation{(}\spanIdentifier{e}\spanPunctuation{:} \spanIdentifier{Literal}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanKeyword{return} \spanIdentifier{e}\spanOperator{.}\spanIdentifier{x}

\spanKeyword{method} \spanIdentifier{eval}\spanPunctuation{(}\spanIdentifier{e}\spanPunctuation{:} \spanIdentifier{PlusExpr}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanComment{\# watch out: relies on dynamic binding}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{eval}\spanPunctuation{(}\spanIdentifier{e}\spanOperator{.}\spanIdentifier{a}\spanPunctuation{)} \spanOperator{+} \spanIdentifier{eval}\spanPunctuation{(}\spanIdentifier{e}\spanOperator{.}\spanIdentifier{b}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{newLit}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Literal} \spanOperator{=}
  \spanIdentifier{new}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{)}
  \spanIdentifier{result}\spanOperator{.}\spanIdentifier{x} \spanOperator{=} \spanIdentifier{x}

\spanKeyword{proc} \spanIdentifier{newPlus}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Expression}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{PlusExpr} \spanOperator{=}
  \spanIdentifier{new}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{)}
  \spanIdentifier{result}\spanOperator{.}\spanIdentifier{a} \spanOperator{=} \spanIdentifier{a}
  \spanIdentifier{result}\spanOperator{.}\spanIdentifier{b} \spanOperator{=} \spanIdentifier{b}

\spanIdentifier{echo} \spanIdentifier{eval}\spanPunctuation{(}\spanIdentifier{newPlus}\spanPunctuation{(}\spanIdentifier{newPlus}\spanPunctuation{(}\spanIdentifier{newLit}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{newLit}\spanPunctuation{(}\spanDecNumber{2}\spanPunctuation{)}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{newLit}\spanPunctuation{(}\spanDecNumber{4}\spanPunctuation{)}\spanPunctuation{)}\spanPunctuation{)}
\end{rstpre}
In the example the constructors \texttt{newLit} and \texttt{newPlus} are procs because they should use static binding, but \texttt{eval} is a method because it requires dynamic binding.

As can be seen in the example, base methods have to be annotated with the base\label{base_1} pragma. The \texttt{base} pragma also acts as a reminder for the programmer that a base method \texttt{m} is used as the foundation to determine all the effects that a call to \texttt{m} might cause.

\textbf{Note}: Compile-time execution is not (yet) supported for methods.

\textbf{Note}: Starting from Nim 0.20, generic methods are deprecated.

\rsthB{Inhibit dynamic method resolution via procCall}\label{multiminusmethods-inhibit-dynamic-method-resolution-via-proccall}
Dynamic method resolution can be inhibited via the builtin system.procCall\label{systemdotproccall_1}. This is somewhat comparable to the super\label{super_1} keyword that traditional OOP languages offer.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Thing} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{RootObj}
  \spanIdentifier{Unit} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Thing}
    \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}

\spanKeyword{method} \spanIdentifier{m}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{Thing}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{base}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"base"}

\spanKeyword{method} \spanIdentifier{m}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{Unit}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# Call the base method:}
  \spanIdentifier{procCall} \spanIdentifier{m}\spanPunctuation{(}\spanIdentifier{Thing}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}\spanPunctuation{)}
  \spanIdentifier{echo} \spanStringLit{"1"}
\end{rstpre}
\rsthA{Iterators and the for statement}\label{iterators-and-the-for-statement}
The for\label{for_1} statement is an abstract mechanism to iterate over the elements of a container. It relies on an iterator\label{iterator_1} to do so. Like \texttt{while} statements, \texttt{for} statements open an implicit block\label{implicit-block_1}, so that they can be left with a \texttt{break} statement.

The \texttt{for} loop declares iteration variables - their scope reaches until the end of the loop body. The iteration variables' types are inferred by the return type of the iterator.

An iterator is similar to a procedure, except that it can be called in the context of a \texttt{for} loop. Iterators provide a way to specify the iteration over an abstract type. A key role in the execution of a \texttt{for} loop plays the \texttt{yield} statement in the called iterator. Whenever a \texttt{yield} statement is reached the data is bound to the \texttt{for} loop variables and control continues in the body of the \texttt{for} loop. The iterator's local variables and execution state are automatically saved between calls. Example:

\begin{rstpre}
\spanComment{\# this definition exists in the system module}
\spanKeyword{iterator} \spanIdentifier{items}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{char} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{inline}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{i} \spanOperator{=} \spanDecNumber{0}
  \spanKeyword{while} \spanIdentifier{i} \spanOperator{<} \spanIdentifier{len}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}\spanPunctuation{:}
    \spanKeyword{yield} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}
    \spanIdentifier{inc}\spanPunctuation{(}\spanIdentifier{i}\spanPunctuation{)}

\spanKeyword{for} \spanIdentifier{ch} \spanKeyword{in} \spanIdentifier{items}\spanPunctuation{(}\spanStringLit{"hello world"}\spanPunctuation{)}\spanPunctuation{:} \spanComment{\# \symbol{96}ch\symbol{96} is an iteration variable}
  \spanIdentifier{echo} \spanIdentifier{ch}
\end{rstpre}
The compiler generates code as if the programmer would have written this:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{i} \spanOperator{=} \spanDecNumber{0}
\spanKeyword{while} \spanIdentifier{i} \spanOperator{<} \spanIdentifier{len}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)}\spanPunctuation{:}
  \spanKeyword{var} \spanIdentifier{ch} \spanOperator{=} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanIdentifier{i}\spanPunctuation{\symbol{93}}
  \spanIdentifier{echo} \spanIdentifier{ch}
  \spanIdentifier{inc}\spanPunctuation{(}\spanIdentifier{i}\spanPunctuation{)}
\end{rstpre}
If the iterator yields a tuple, there can be as many iteration variables as there are components in the tuple. The i'th iteration variable's type is the type of the i'th component. In other words, implicit tuple unpacking in a for loop context is supported.

\rsthB{Implicit items/pairs invocations}\label{iterators-and-the-for-statement-implicit-itemsslashpairs-invocations}
If the for loop expression \texttt{e} does not denote an iterator and the for loop has exactly 1 variable, the for loop expression is rewritten to \texttt{items(e)}; ie. an \texttt{items} iterator is implicitly invoked:

\begin{rstpre}
\spanKeyword{for} \spanIdentifier{x} \spanKeyword{in} \spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,}\spanDecNumber{2}\spanPunctuation{,}\spanDecNumber{3}\spanPunctuation{\symbol{93}}\spanPunctuation{:} \spanIdentifier{echo} \spanIdentifier{x}
\end{rstpre}
If the for loop has exactly 2 variables, a \texttt{pairs} iterator is implicitly invoked.

Symbol lookup of the identifiers \texttt{items}/\texttt{pairs} is performed after the rewriting step, so that all overloads of \texttt{items}/\texttt{pairs} are taken into account.

\rsthB{First class iterators}\label{iterators-and-the-for-statement-first-class-iterators}
There are 2 kinds of iterators in Nim: \emph{inline} and \emph{closure} iterators. An inline iterator\label{inline-iterator_1} is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size.

Caution: the body of a for loop over an inline iterator is inlined into each \texttt{yield} statement appearing in the iterator code, so ideally the code should be refactored to contain a single yield when possible to avoid code bloat.

Inline iterators are second class citizens; They can be passed as parameters only to other inlining code facilities like templates, macros and other inline iterators.

In contrast to that, a closure iterator\label{closure-iterator_1} can be passed around more freely:

\begin{rstpre}
\spanKeyword{iterator} \spanIdentifier{count0}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{closure}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanKeyword{yield} \spanDecNumber{0}

\spanKeyword{iterator} \spanIdentifier{count2}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{closure}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanDecNumber{1}
  \spanKeyword{yield} \spanIdentifier{x}
  \spanIdentifier{inc} \spanIdentifier{x}
  \spanKeyword{yield} \spanIdentifier{x}

\spanKeyword{proc} \spanIdentifier{invoke}\spanPunctuation{(}\spanIdentifier{iter}\spanPunctuation{:} \spanKeyword{iterator}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{closure}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{x} \spanKeyword{in} \spanIdentifier{iter}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{echo} \spanIdentifier{x}

\spanIdentifier{invoke}\spanPunctuation{(}\spanIdentifier{count0}\spanPunctuation{)}
\spanIdentifier{invoke}\spanPunctuation{(}\spanIdentifier{count2}\spanPunctuation{)}
\end{rstpre}
Closure iterators and inline iterators have some restrictions:

\begin{enumerate}\item For now, a closure iterator cannot be executed at compile time.
\item \texttt{return} is allowed in a closure iterator but not in an inline iterator (but rarely useful) and ends the iteration.
\item Neither inline nor closure iterators can be recursive.
\item Neither inline nor closure iterators have the special \texttt{result} variable.
\item Closure iterators are not supported by the js backend.
\end{enumerate}
Iterators that are neither marked \texttt{\symbol{123}.closure.\symbol{125}} nor \texttt{\symbol{123}.inline.\symbol{125}} explicitly default to being inline, but this may change in future versions of the implementation.

The \texttt{iterator} type is always of the calling convention \texttt{closure} implicitly; the following example shows how to use iterators to implement a collaborative tasking\label{collaborative-tasking_1} system:

\begin{rstpre}
\spanComment{\# simple tasking:}
\spanKeyword{type}
  \spanIdentifier{Task} \spanOperator{=} \spanKeyword{iterator} \spanPunctuation{(}\spanIdentifier{ticker}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}

\spanKeyword{iterator} \spanIdentifier{a1}\spanPunctuation{(}\spanIdentifier{ticker}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{closure}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"a1: A"}
  \spanKeyword{yield}
  \spanIdentifier{echo} \spanStringLit{"a1: B"}
  \spanKeyword{yield}
  \spanIdentifier{echo} \spanStringLit{"a1: C"}
  \spanKeyword{yield}
  \spanIdentifier{echo} \spanStringLit{"a1: D"}

\spanKeyword{iterator} \spanIdentifier{a2}\spanPunctuation{(}\spanIdentifier{ticker}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{closure}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"a2: A"}
  \spanKeyword{yield}
  \spanIdentifier{echo} \spanStringLit{"a2: B"}
  \spanKeyword{yield}
  \spanIdentifier{echo} \spanStringLit{"a2: C"}

\spanKeyword{proc} \spanIdentifier{runTasks}\spanPunctuation{(}\spanIdentifier{t}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{Task}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{ticker} \spanOperator{=} \spanDecNumber{0}
  \spanKeyword{while} \spanIdentifier{true}\spanPunctuation{:}
    \spanKeyword{let} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{t}\spanPunctuation{\symbol{91}}\spanIdentifier{ticker} \spanKeyword{mod} \spanIdentifier{t}\spanOperator{.}\spanIdentifier{len}\spanPunctuation{\symbol{93}}
    \spanKeyword{if} \spanIdentifier{finished}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{break}
    \spanIdentifier{x}\spanPunctuation{(}\spanIdentifier{ticker}\spanPunctuation{)}
    \spanIdentifier{inc} \spanIdentifier{ticker}

\spanIdentifier{runTasks}\spanPunctuation{(}\spanIdentifier{a1}\spanPunctuation{,} \spanIdentifier{a2}\spanPunctuation{)}
\end{rstpre}
The builtin \texttt{system.finished} can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.

Note that \texttt{system.finished} is error prone to use because it only returns \texttt{true} one iteration after the iterator has finished:

\begin{rstpre}
\spanKeyword{iterator} \spanIdentifier{mycount}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{closure}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{a}
  \spanKeyword{while} \spanIdentifier{x} \spanOperator{<=} \spanIdentifier{b}\spanPunctuation{:}
    \spanKeyword{yield} \spanIdentifier{x}
    \spanIdentifier{inc} \spanIdentifier{x}

\spanKeyword{var} \spanIdentifier{c} \spanOperator{=} \spanIdentifier{mycount} \spanComment{\# instantiate the iterator}
\spanKeyword{while} \spanKeyword{not} \spanIdentifier{finished}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{c}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{)}

\spanComment{\# Produces}
\spanDecNumber{1}
\spanDecNumber{2}
\spanDecNumber{3}
\spanDecNumber{0}
\end{rstpre}
Instead this code has to be used:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{c} \spanOperator{=} \spanIdentifier{mycount} \spanComment{\# instantiate the iterator}
\spanKeyword{while} \spanIdentifier{true}\spanPunctuation{:}
  \spanKeyword{let} \spanIdentifier{value} \spanOperator{=} \spanIdentifier{c}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{)}
  \spanKeyword{if} \spanIdentifier{finished}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{break} \spanComment{\# and discard 'value'!}
  \spanIdentifier{echo} \spanIdentifier{value}
\end{rstpre}
It helps to think that the iterator actually returns a pair \texttt{(value, done)} and \texttt{finished} is used to access the hidden \texttt{done} field.

Closure iterators are \emph{resumable functions} and so one has to provide the arguments to every call. To get around this limitation one can capture parameters of an outer factory proc:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{mycount}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{iterator} \spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanKeyword{iterator} \spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=}
    \spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{a}
    \spanKeyword{while} \spanIdentifier{x} \spanOperator{<=} \spanIdentifier{b}\spanPunctuation{:}
      \spanKeyword{yield} \spanIdentifier{x}
      \spanIdentifier{inc} \spanIdentifier{x}

\spanKeyword{let} \spanIdentifier{foo} \spanOperator{=} \spanIdentifier{mycount}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{)}

\spanKeyword{for} \spanIdentifier{f} \spanKeyword{in} \spanIdentifier{foo}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{f}
\end{rstpre}
\rsthA{Converters}\label{converters}
A converter is like an ordinary proc except that it enhances the "implicitly convertible" type relation (see \href{\#type-relations-convertible-relation}{Convertible relation}):

\begin{rstpre}
\spanComment{\# bad style ahead: Nim is not C.}
\spanKeyword{converter} \spanIdentifier{toBool}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=} \spanIdentifier{x} \spanOperator{!=} \spanDecNumber{0}

\spanKeyword{if} \spanDecNumber{4}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"compiles"}
\end{rstpre}
A converter can also be explicitly invoked for improved readability. Note that implicit converter chaining is not supported: If there is a converter from type A to type B and from type B to type C the implicit conversion from A to C is not provided.

\rsthA{Type sections}\label{type-sections}
Example:

\begin{rstpre}
\spanKeyword{type} \spanComment{\# example demonstrating mutually recursive types}
  \spanIdentifier{Node} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object}  \spanComment{\# an object managed by the garbage collector (ref)}
    \spanIdentifier{le}\spanPunctuation{,} \spanIdentifier{ri}\spanPunctuation{:} \spanIdentifier{Node}     \spanComment{\# left and right subtrees}
    \spanIdentifier{sym}\spanPunctuation{:} \spanKeyword{ref} \spanIdentifier{Sym}     \spanComment{\# leaves contain a reference to a Sym}
  
  \spanIdentifier{Sym} \spanOperator{=} \spanKeyword{object}       \spanComment{\# a symbol}
    \spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{string}     \spanComment{\# the symbol's name}
    \spanIdentifier{line}\spanPunctuation{:} \spanIdentifier{int}        \spanComment{\# the line the symbol was declared in}
    \spanIdentifier{code}\spanPunctuation{:} \spanIdentifier{Node}       \spanComment{\# the symbol's abstract syntax tree}
\end{rstpre}
A type section begins with the \texttt{type} keyword. It contains multiple type definitions. A type definition binds a type to a name. Type definitions can be recursive or even mutually recursive. Mutually recursive types are only possible within a single \texttt{type} section. Nominal types like \texttt{objects} or \texttt{enums} can only be defined in a \texttt{type} section.

\rsthA{Exception handling}\label{exception-handling}
\rsthB{Try statement}\label{exception-handling-try-statement}
Example:

\begin{rstpre}
\spanComment{\# read the first two lines of a text file that should contain numbers}
\spanComment{\# and tries to add them}
\spanKeyword{var}
  \spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{File}
\spanKeyword{if} \spanIdentifier{open}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanStringLit{"numbers.txt"}\spanPunctuation{)}\spanPunctuation{:}
  \spanKeyword{try}\spanPunctuation{:}
    \spanKeyword{var} \spanIdentifier{a} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{)}
    \spanKeyword{var} \spanIdentifier{b} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{)}
    \spanIdentifier{echo} \spanStringLit{"sum: "} \spanOperator{\&} \spanOperator{\$}\spanPunctuation{(}\spanIdentifier{parseInt}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{)} \spanOperator{+} \spanIdentifier{parseInt}\spanPunctuation{(}\spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{)}
  \spanKeyword{except} \spanIdentifier{OverflowDefect}\spanPunctuation{:}
    \spanIdentifier{echo} \spanStringLit{"overflow!"}
  \spanKeyword{except} \spanIdentifier{ValueError}\spanPunctuation{:}
    \spanIdentifier{echo} \spanStringLit{"could not convert string to integer"}
  \spanKeyword{except} \spanIdentifier{IOError}\spanPunctuation{:}
    \spanIdentifier{echo} \spanStringLit{"IO error!"}
  \spanKeyword{except}\spanPunctuation{:}
    \spanIdentifier{echo} \spanStringLit{"Unknown exception!"}
  \spanKeyword{finally}\spanPunctuation{:}
    \spanIdentifier{close}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{)}
\end{rstpre}
The statements after the \texttt{try} are executed in sequential order unless an exception \texttt{e} is raised. If the exception type of \texttt{e} matches any listed in an \texttt{except} clause the corresponding statements are executed. The statements following the \texttt{except} clauses are called exception handlers\label{exception-handlers_1}.

The empty except\label{except_1} clause is executed if there is an exception that is not listed otherwise. It is similar to an \texttt{else} clause in \texttt{if} statements.

If there is a finally\label{finally_1} clause, it is always executed after the exception handlers.

The exception is \emph{consumed} in an exception handler. However, an exception handler may raise another exception. If the exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a \texttt{finally} clause - is not executed (if an exception occurs).

\rsthB{Try expression}\label{exception-handling-try-expression}
Try can also be used as an expression; the type of the \texttt{try} branch then needs to fit the types of \texttt{except} branches, but the type of the \texttt{finally} branch always has to be \texttt{void}:

\begin{rstpre}
\spanKeyword{from} \spanIdentifier{strutils} \spanKeyword{import} \spanIdentifier{parseInt}

\spanKeyword{let} \spanIdentifier{x} \spanOperator{=} \spanKeyword{try}\spanPunctuation{:} \spanIdentifier{parseInt}\spanPunctuation{(}\spanStringLit{"133a"}\spanPunctuation{)}
        \spanKeyword{except}\spanPunctuation{:} \spanOperator{-}\spanDecNumber{1}
        \spanKeyword{finally}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"hi"}
\end{rstpre}
To prevent confusing code there is a parsing limitation; if the \texttt{try} follows a \texttt{(} it has to be written as a one liner:

\begin{rstpre}
\spanKeyword{let} \spanIdentifier{x} \spanOperator{=} \spanPunctuation{(}\spanKeyword{try}\spanPunctuation{:} \spanIdentifier{parseInt}\spanPunctuation{(}\spanStringLit{"133a"}\spanPunctuation{)} \spanKeyword{except}\spanPunctuation{:} \spanOperator{-}\spanDecNumber{1}\spanPunctuation{)}
\end{rstpre}
\rsthB{Except clauses}\label{exception-handling-except-clauses}
Within an \texttt{except} clause it is possible to access the current exception using the following syntax:

\begin{rstpre}
\spanKeyword{try}\spanPunctuation{:}
  \spanComment{\# ...}
\spanKeyword{except} \spanIdentifier{IOError} \spanKeyword{as} \spanIdentifier{e}\spanPunctuation{:}
  \spanComment{\# Now use "e"}
  \spanIdentifier{echo} \spanStringLit{"I/O error: "} \spanOperator{\&} \spanIdentifier{e}\spanOperator{.}\spanIdentifier{msg}
\end{rstpre}
Alternatively, it is possible to use \texttt{getCurrentException} to retrieve the exception that has been raised:

\begin{rstpre}
\spanKeyword{try}\spanPunctuation{:}
  \spanComment{\# ...}
\spanKeyword{except} \spanIdentifier{IOError}\spanPunctuation{:}
  \spanKeyword{let} \spanIdentifier{e} \spanOperator{=} \spanIdentifier{getCurrentException}\spanPunctuation{(}\spanPunctuation{)}
  \spanComment{\# Now use "e"}
\end{rstpre}
Note that \texttt{getCurrentException} always returns a \texttt{ref Exception} type. If a variable of the proper type is needed (in the example above, \texttt{IOError}), one must convert it explicitly:

\begin{rstpre}
\spanKeyword{try}\spanPunctuation{:}
  \spanComment{\# ...}
\spanKeyword{except} \spanIdentifier{IOError}\spanPunctuation{:}
  \spanKeyword{let} \spanIdentifier{e} \spanOperator{=} \spanPunctuation{(}\spanKeyword{ref} \spanIdentifier{IOError}\spanPunctuation{)}\spanPunctuation{(}\spanIdentifier{getCurrentException}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{)}
  \spanComment{\# "e" is now of the proper type}
\end{rstpre}
However, this is seldom needed. The most common case is to extract an error message from \texttt{e}, and for such situations it is enough to use \texttt{getCurrentExceptionMsg}:

\begin{rstpre}
\spanKeyword{try}\spanPunctuation{:}
  \spanComment{\# ...}
\spanKeyword{except}\spanPunctuation{:}
  \spanIdentifier{echo} \spanIdentifier{getCurrentExceptionMsg}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
\rsthB{Custom exceptions}\label{exception-handling-custom-exceptions}
Is it possible to create custom exceptions. A custom exception is a custom type:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{LoadError}\spanOperator{*} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{Exception}
\end{rstpre}
Ending the custom exception's name with \texttt{Error} is recommended.

Custom exceptions can be raised like any others, e.g.:

\begin{rstpre}
\spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{LoadError}\spanPunctuation{,} \spanStringLit{"Failed to load data"}\spanPunctuation{)}
\end{rstpre}
\rsthB{Defer statement}\label{exception-handling-defer-statement}
Instead of a \texttt{try finally} statement a \texttt{defer} statement can be used.

Any statements following the \texttt{defer} in the current block will be considered to be in an implicit try block:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{main} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{f} \spanOperator{=} \spanIdentifier{open}\spanPunctuation{(}\spanStringLit{"numbers.txt"}\spanPunctuation{)}
  \spanKeyword{defer}\spanPunctuation{:} \spanIdentifier{close}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{)}
  \spanIdentifier{f}\spanOperator{.}\spanIdentifier{write} \spanStringLit{"abc"}
  \spanIdentifier{f}\spanOperator{.}\spanIdentifier{write} \spanStringLit{"def"}
\end{rstpre}
Is rewritten to:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{main} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{f} \spanOperator{=} \spanIdentifier{open}\spanPunctuation{(}\spanStringLit{"numbers.txt"}\spanPunctuation{)}
  \spanKeyword{try}\spanPunctuation{:}
    \spanIdentifier{f}\spanOperator{.}\spanIdentifier{write} \spanStringLit{"abc"}
    \spanIdentifier{f}\spanOperator{.}\spanIdentifier{write} \spanStringLit{"def"}
  \spanKeyword{finally}\spanPunctuation{:}
    \spanIdentifier{close}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{)}
\end{rstpre}
Top level \texttt{defer} statements are not supported since it's unclear what such a statement should refer to.

\rsthB{Raise statement}\label{exception-handling-raise-statement}
Example:

\begin{rstpre}
\spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{IOError}\spanPunctuation{,} \spanStringLit{"IO failed"}\spanPunctuation{)}
\end{rstpre}
Apart from built-in operations like array indexing, memory allocation, etc. the \texttt{raise} statement is the only way to raise an exception.

If no exception name is given, the current exception is re-raised\label{reminusraised_1}. The ReraiseDefect\label{reraisedefect_1} exception is raised if there is no exception to re-raise. It follows that the \texttt{raise} statement \emph{always} raises an exception.

\rsthB{Exception hierarchy}\label{exception-handling-exception-hierarchy}
The exception tree is defined in the \href{system.html}{system} module. Every exception inherits from \texttt{system.Exception}. Exceptions that indicate programming bugs inherit from \texttt{system.Defect} (which is a subtype of \texttt{Exception}) and are strictly speaking not catchable as they can also be mapped to an operation that terminates the whole process. If panics are turned into exceptions, these exceptions inherit from \texttt{Defect}.

Exceptions that indicate any other runtime error that can be caught inherit from \texttt{system.CatchableError} (which is a subtype of \texttt{Exception}).

\rsthB{Imported exceptions}\label{exception-handling-imported-exceptions}
It is possible to raise/catch imported C++ exceptions. Types imported using \texttt{importcpp} can be raised or caught. Exceptions are raised by value and caught by reference. Example:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{CStdException} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"std::exception"}\spanPunctuation{,} \spanIdentifier{header}\spanPunctuation{:} \spanStringLit{"<exception>"}\spanPunctuation{,} \spanIdentifier{inheritable}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object}
    \spanComment{\#\# does not inherit from \symbol{96}RootObj\symbol{96}, so we use \symbol{96}inheritable\symbol{96} instead}
  \spanIdentifier{CRuntimeError} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{requiresInit}\spanPunctuation{,} \spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"std::runtime\_error"}\spanPunctuation{,} \spanIdentifier{header}\spanPunctuation{:} \spanStringLit{"<stdexcept>"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object} \spanKeyword{of} \spanIdentifier{CStdException}
    \spanComment{\#\# \symbol{96}CRuntimeError\symbol{96} has no default constructor => \symbol{96}requiresInit\symbol{96}}
\spanKeyword{proc} \spanIdentifier{what}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{CStdException}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{cstring} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"((char *)\#.what())"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanIdentifier{initRuntimeError}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{cstring}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{CRuntimeError} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"std::runtime\_error(\symbol{64})"}\spanPunctuation{,} \spanIdentifier{constructor}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanIdentifier{initStdException}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{CStdException} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"std::exception()"}\spanPunctuation{,} \spanIdentifier{constructor}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{proc} \spanIdentifier{fn}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{let} \spanIdentifier{a} \spanOperator{=} \spanIdentifier{initRuntimeError}\spanPunctuation{(}\spanStringLit{"foo"}\spanPunctuation{)}
  \spanIdentifier{doAssert} \spanOperator{\$}\spanIdentifier{a}\spanOperator{.}\spanIdentifier{what} \spanOperator{==} \spanStringLit{"foo"}
  \spanKeyword{var} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{cstring}
  \spanKeyword{try}\spanPunctuation{:} \spanKeyword{raise} \spanIdentifier{initRuntimeError}\spanPunctuation{(}\spanStringLit{"foo2"}\spanPunctuation{)}
  \spanKeyword{except} \spanIdentifier{CStdException} \spanKeyword{as} \spanIdentifier{e}\spanPunctuation{:}
    \spanIdentifier{doAssert} \spanIdentifier{e} \spanKeyword{is} \spanIdentifier{CStdException}
    \spanIdentifier{b} \spanOperator{=} \spanIdentifier{e}\spanOperator{.}\spanIdentifier{what}\spanPunctuation{(}\spanPunctuation{)}
  \spanIdentifier{doAssert} \spanOperator{\$}\spanIdentifier{b} \spanOperator{==} \spanStringLit{"foo2"}
  
  \spanKeyword{try}\spanPunctuation{:} \spanKeyword{raise} \spanIdentifier{initStdException}\spanPunctuation{(}\spanPunctuation{)}
  \spanKeyword{except} \spanIdentifier{CStdException}\spanPunctuation{:} \spanKeyword{discard}
  
  \spanKeyword{try}\spanPunctuation{:} \spanKeyword{raise} \spanIdentifier{initRuntimeError}\spanPunctuation{(}\spanStringLit{"foo3"}\spanPunctuation{)}
  \spanKeyword{except} \spanIdentifier{CRuntimeError} \spanKeyword{as} \spanIdentifier{e}\spanPunctuation{:}
    \spanIdentifier{b} \spanOperator{=} \spanIdentifier{e}\spanOperator{.}\spanIdentifier{what}\spanPunctuation{(}\spanPunctuation{)}
  \spanKeyword{except} \spanIdentifier{CStdException}\spanPunctuation{:}
    \spanIdentifier{doAssert} \spanIdentifier{false}
  \spanIdentifier{doAssert} \spanOperator{\$}\spanIdentifier{b} \spanOperator{==} \spanStringLit{"foo3"}

\spanIdentifier{fn}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
\textbf{Note:} \texttt{getCurrentException()} and \texttt{getCurrentExceptionMsg()} are not available for imported exceptions from C++. One needs to use the \texttt{except ImportedException as x:} syntax and rely on functionality of the \texttt{x} object to get exception details.

\rsthA{Effect system}\label{effect-system}
\rsthB{Exception tracking}\label{effect-system-exception-tracking}
Nim supports exception tracking. The raises\label{raises_1} pragma can be used to explicitly define which exceptions a proc/iterator/method/converter is allowed to raise. The compiler verifies this:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{what}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{raises}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{IOError}\spanPunctuation{,} \spanIdentifier{OSError}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanKeyword{if} \spanIdentifier{what}\spanPunctuation{:} \spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{IOError}\spanPunctuation{,} \spanStringLit{"IO"}\spanPunctuation{)}
  \spanKeyword{else}\spanPunctuation{:} \spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{OSError}\spanPunctuation{,} \spanStringLit{"OS"}\spanPunctuation{)}
\end{rstpre}
An empty \texttt{raises} list (\texttt{raises: \symbol{91}\symbol{93}}) means that no exception may be raised:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{raises}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanKeyword{try}\spanPunctuation{:}
    \spanIdentifier{unsafeCall}\spanPunctuation{(}\spanPunctuation{)}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{true}
  \spanKeyword{except}\spanPunctuation{:}
    \spanIdentifier{result} \spanOperator{=} \spanIdentifier{false}
\end{rstpre}
A \texttt{raises} list can also be attached to a proc type. This affects type compatibility:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Callback} \spanOperator{=} \spanKeyword{proc} \spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{raises}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{IOError}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{var}
  \spanIdentifier{c}\spanPunctuation{:} \spanIdentifier{Callback}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{OSError}\spanPunctuation{,} \spanStringLit{"OS"}\spanPunctuation{)}

\spanIdentifier{c} \spanOperator{=} \spanIdentifier{p} \spanComment{\# type error}
\end{rstpre}
For a routine \texttt{p} the compiler uses inference rules to determine the set of possibly raised exceptions; the algorithm operates on \texttt{p}'s call graph:

\begin{enumerate}\item Every indirect call via some proc type \texttt{T} is assumed to raise \texttt{system.Exception} (the base type of the exception hierarchy) and thus any exception unless \texttt{T} has an explicit \texttt{raises} list. However if the call is of the form \texttt{f(...)} where \texttt{f} is a parameter of the currently analysed routine it is ignored. The call is optimistically assumed to have no effect. Rule 2 compensates for this case.
\item Every expression of some proc type within a call that is not a call itself (and not nil) is assumed to be called indirectly somehow and thus its raises list is added to \texttt{p}'s raises list.
\item Every call to a proc \texttt{q} which has an unknown body (due to a forward declaration or an \texttt{importc} pragma) is assumed to raise \texttt{system.Exception} unless \texttt{q} has an explicit \texttt{raises} list.
\item Every call to a method \texttt{m} is assumed to raise \texttt{system.Exception} unless \texttt{m} has an explicit \texttt{raises} list.
\item For every other call the analysis can determine an exact \texttt{raises} list.
\item For determining a \texttt{raises} list, the \texttt{raise} and \texttt{try} statements of \texttt{p} are taken into consideration.
\end{enumerate}
Rules 1-2 ensure the following works:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{noRaise}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanKeyword{proc}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{raises}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanComment{\# unknown call that might raise anything, but valid:}
  \spanIdentifier{x}\spanPunctuation{(}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{doRaise}\spanPunctuation{(}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{raises}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{IOError}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{IOError}\spanPunctuation{,} \spanStringLit{"IO"}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{use}\spanPunctuation{(}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{raises}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanComment{\# doesn't compile! Can raise IOError!}
  \spanIdentifier{noRaise}\spanPunctuation{(}\spanIdentifier{doRaise}\spanPunctuation{)}
\end{rstpre}
So in many cases a callback does not cause the compiler to be overly conservative in its effect analysis.

Exceptions inheriting from \texttt{system.Defect} are not tracked with the \texttt{.raises: \symbol{91}\symbol{93}} exception tracking mechanism. This is more consistent with the built-in operations. The following code is valid::

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{mydiv}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{raises}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{a} \spanKeyword{div} \spanIdentifier{b} \spanComment{\# can raise an DivByZeroDefect}
\end{rstpre}
And so is::

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{mydiv}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{raises}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanKeyword{if} \spanIdentifier{b} \spanOperator{==} \spanDecNumber{0}\spanPunctuation{:} \spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{DivByZeroDefect}\spanPunctuation{,} \spanStringLit{"division by zero"}\spanPunctuation{)}
  \spanKeyword{else}\spanPunctuation{:} \spanIdentifier{result} \spanOperator{=} \spanIdentifier{a} \spanKeyword{div} \spanIdentifier{b}
\end{rstpre}
The reason for this is that \texttt{DivByZeroDefect} inherits from \texttt{Defect} and with \texttt{--panics:on} Defects become unrecoverable errors. (Since version 1.4 of the language.)

\rsthB{Tag tracking}\label{effect-system-tag-tracking}
The exception tracking is part of Nim's effect system\label{effect-system_1}. Raising an exception is an \emph{effect}. Other effects can also be defined. A user defined effect is a means to \emph{tag} a routine and to perform checks against this tag:

\begin{rstpre}
\spanKeyword{type} \spanIdentifier{IO} \spanOperator{=} \spanKeyword{object} \spanComment{\#\# input/output effect}
\spanKeyword{proc} \spanIdentifier{readLine}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{tags}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanIdentifier{IO}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{discard}

\spanKeyword{proc} \spanIdentifier{no\_IO\_please}\spanPunctuation{(}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{tags}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanComment{\# the compiler prevents this:}
  \spanKeyword{let} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{readLine}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
A tag has to be a type name. A \texttt{tags} list - like a \texttt{raises} list - can also be attached to a proc type. This affects type compatibility.

The inference for tag tracking is analogous to the inference for exception tracking.

\rsthB{Effects pragma}\label{effect-system-effects-pragma}
The \texttt{effects} pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the \texttt{effects}'s position:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{what}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{if} \spanIdentifier{what}\spanPunctuation{:}
    \spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{IOError}\spanPunctuation{,} \spanStringLit{"IO"}\spanPunctuation{)}
    \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{effects}\spanOperator{.}\spanPunctuation{\symbol{125}}
  \spanKeyword{else}\spanPunctuation{:}
    \spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{OSError}\spanPunctuation{,} \spanStringLit{"OS"}\spanPunctuation{)}
\end{rstpre}
The compiler produces a hint message that \texttt{IOError} can be raised. \texttt{OSError} is not listed as it cannot be raised in the branch the \texttt{effects} pragma appears in.

\rsthA{Generics}\label{generics}
Generics are Nim's means to parametrize procs, iterators or types with type parameters\label{type-parameters_1}. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type.

The following example shows a generic binary tree can be modelled:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{BinaryTree}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object} \spanComment{\# BinaryTree is a generic type with}
                              \spanComment{\# generic param \symbol{96}\symbol{96}T\symbol{96}\symbol{96}}
    \spanIdentifier{le}\spanPunctuation{,} \spanIdentifier{ri}\spanPunctuation{:} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}     \spanComment{\# left and right subtrees; may be nil}
    \spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{T}                   \spanComment{\# the data stored in a node}

\spanKeyword{proc} \spanIdentifier{newNode}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=}
  \spanComment{\# constructor for a node}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{le}\spanPunctuation{:} \spanKeyword{nil}\spanPunctuation{,} \spanIdentifier{ri}\spanPunctuation{:} \spanKeyword{nil}\spanPunctuation{,} \spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{data}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{add}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# insert a node into the tree}
  \spanKeyword{if} \spanIdentifier{root} \spanOperator{==} \spanKeyword{nil}\spanPunctuation{:}
    \spanIdentifier{root} \spanOperator{=} \spanIdentifier{n}
  \spanKeyword{else}\spanPunctuation{:}
    \spanKeyword{var} \spanIdentifier{it} \spanOperator{=} \spanIdentifier{root}
    \spanKeyword{while} \spanIdentifier{it} \spanOperator{!=} \spanKeyword{nil}\spanPunctuation{:}
      \spanComment{\# compare the data items; uses the generic \symbol{96}\symbol{96}cmp\symbol{96}\symbol{96} proc}
      \spanComment{\# that works for any type that has a \symbol{96}\symbol{96}==\symbol{96}\symbol{96} and \symbol{96}\symbol{96}<\symbol{96}\symbol{96} operator}
      \spanKeyword{var} \spanIdentifier{c} \spanOperator{=} \spanIdentifier{cmp}\spanPunctuation{(}\spanIdentifier{it}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{,} \spanIdentifier{n}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{)}
      \spanKeyword{if} \spanIdentifier{c} \spanOperator{<} \spanDecNumber{0}\spanPunctuation{:}
        \spanKeyword{if} \spanIdentifier{it}\spanOperator{.}\spanIdentifier{le} \spanOperator{==} \spanKeyword{nil}\spanPunctuation{:}
          \spanIdentifier{it}\spanOperator{.}\spanIdentifier{le} \spanOperator{=} \spanIdentifier{n}
          \spanKeyword{return}
        \spanIdentifier{it} \spanOperator{=} \spanIdentifier{it}\spanOperator{.}\spanIdentifier{le}
      \spanKeyword{else}\spanPunctuation{:}
        \spanKeyword{if} \spanIdentifier{it}\spanOperator{.}\spanIdentifier{ri} \spanOperator{==} \spanKeyword{nil}\spanPunctuation{:}
          \spanIdentifier{it}\spanOperator{.}\spanIdentifier{ri} \spanOperator{=} \spanIdentifier{n}
          \spanKeyword{return}
        \spanIdentifier{it} \spanOperator{=} \spanIdentifier{it}\spanOperator{.}\spanIdentifier{ri}

\spanKeyword{proc} \spanIdentifier{add}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# convenience proc:}
  \spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{,} \spanIdentifier{newNode}\spanPunctuation{(}\spanIdentifier{data}\spanPunctuation{)}\spanPunctuation{)}

\spanKeyword{iterator} \spanIdentifier{preorder}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{:} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{T} \spanOperator{=}
  \spanComment{\# Preorder traversal of a binary tree.}
  \spanComment{\# Since recursive iterators are not yet implemented,}
  \spanComment{\# this uses an explicit stack (which is more efficient anyway):}
  \spanKeyword{var} \spanIdentifier{stack}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanIdentifier{root}\spanPunctuation{\symbol{93}}
  \spanKeyword{while} \spanIdentifier{stack}\spanOperator{.}\spanIdentifier{len} \spanOperator{>} \spanDecNumber{0}\spanPunctuation{:}
    \spanKeyword{var} \spanIdentifier{n} \spanOperator{=} \spanIdentifier{stack}\spanOperator{.}\spanIdentifier{pop}\spanPunctuation{(}\spanPunctuation{)}
    \spanKeyword{while} \spanIdentifier{n} \spanOperator{!=} \spanKeyword{nil}\spanPunctuation{:}
      \spanKeyword{yield} \spanIdentifier{n}\spanOperator{.}\spanIdentifier{data}
      \spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{stack}\spanPunctuation{,} \spanIdentifier{n}\spanOperator{.}\spanIdentifier{ri}\spanPunctuation{)}  \spanComment{\# push right subtree onto the stack}
      \spanIdentifier{n} \spanOperator{=} \spanIdentifier{n}\spanOperator{.}\spanIdentifier{le}          \spanComment{\# and follow the left pointer}

\spanKeyword{var}
  \spanIdentifier{root}\spanPunctuation{:} \spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}} \spanComment{\# instantiate a BinaryTree with \symbol{96}\symbol{96}string\symbol{96}\symbol{96}}
\spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{,} \spanIdentifier{newNode}\spanPunctuation{(}\spanStringLit{"hello"}\spanPunctuation{)}\spanPunctuation{)} \spanComment{\# instantiates \symbol{96}\symbol{96}newNode\symbol{96}\symbol{96} and \symbol{96}\symbol{96}add\symbol{96}\symbol{96}}
\spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{,} \spanStringLit{"world"}\spanPunctuation{)}          \spanComment{\# instantiates the second \symbol{96}\symbol{96}add\symbol{96}\symbol{96} proc}
\spanKeyword{for} \spanIdentifier{str} \spanKeyword{in} \spanIdentifier{preorder}\spanPunctuation{(}\spanIdentifier{root}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{stdout}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanIdentifier{str}\spanPunctuation{)}
\end{rstpre}
The \texttt{T} is called a generic type parameter\label{generic-type-parameter_1} or a type variable\label{type-variable_1}.

\rsthB{Is operator}\label{generics-is-operator}
The \texttt{is} operator is evaluated during semantic analysis to check for type equivalence. It is therefore very useful for type specialization within generic code:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Table}\spanPunctuation{\symbol{91}}\spanIdentifier{Key}\spanPunctuation{,} \spanIdentifier{Value}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{keys}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{Key}\spanPunctuation{\symbol{93}}
    \spanIdentifier{values}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{Value}\spanPunctuation{\symbol{93}}
    \spanKeyword{when} \spanKeyword{not} \spanPunctuation{(}\spanIdentifier{Key} \spanKeyword{is} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanComment{\# empty value for strings used for optimization}
      \spanIdentifier{deletedKeys}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{bool}\spanPunctuation{\symbol{93}}
\end{rstpre}
\rsthB{Type Classes}\label{generics-type-classes}
A type class is a special pseudo-type that can be used to match against types in the context of overload resolution or the \texttt{is} operator. Nim supports the following built-in type classes:

\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|X|X|X|X|X|X|X|X|}
\hline
\textbf{type class} & \textbf{matches}\\
\hline
\texttt{object} & any object type\\
\hline
\texttt{tuple} & any tuple type\\
\hline
 & \\
\hline
\texttt{enum} & any enumeration\\
\hline
\texttt{proc} & any proc type\\
\hline
\texttt{ref} & any \texttt{ref} type\\
\hline
\texttt{ptr} & any \texttt{ptr} type\\
\hline
\texttt{var} & any \texttt{var} type\\
\hline
\texttt{distinct} & any distinct type\\
\hline
\texttt{array} & any array type\\
\hline
\texttt{set} & any set type\\
\hline
\texttt{seq} & any seq type\\
\hline
\texttt{auto} & any type\\
\hline
\texttt{any} & distinct auto (see below)\\
\hline
\end{rsttab}\end{table}Furthermore, every generic type automatically creates a type class of the same name that will match any instantiation of the generic type.

Type classes can be combined using the standard boolean operators to form more complex type classes:

\begin{rstpre}
\spanComment{\# create a type class that will match all tuple and object types}
\spanKeyword{type} \spanIdentifier{RecordType} \spanOperator{=} \spanKeyword{tuple} \spanKeyword{or} \spanKeyword{object}

\spanKeyword{proc} \spanIdentifier{printFields}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{:} \spanIdentifier{RecordType}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{rec}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{key}\spanPunctuation{,} \spanIdentifier{value} \spanKeyword{in} \spanIdentifier{fieldPairs}\spanPunctuation{(}\spanIdentifier{rec}\spanPunctuation{)}\spanPunctuation{:}
    \spanIdentifier{echo} \spanIdentifier{key}\spanPunctuation{,} \spanStringLit{" = "}\spanPunctuation{,} \spanIdentifier{value}
\end{rstpre}
Whilst the syntax of type classes appears to resemble that of ADTs/algebraic data types in ML-like languages, it should be understood that type classes are static constraints to be enforced at type instantiations. Type classes are not really types in themselves, but are instead a system of providing generic "checks" that ultimately \emph{resolve} to some singular type. Type classes do not allow for runtime type dynamism, unlike object variants or methods.

As an example, the following would not compile:

\begin{rstpre}
\spanKeyword{type} \spanIdentifier{TypeClass} \spanOperator{=} \spanIdentifier{int} \spanOperator{|} \spanIdentifier{string}
\spanKeyword{var} \spanIdentifier{foo}\spanPunctuation{:} \spanIdentifier{TypeClass} \spanOperator{=} \spanDecNumber{2} \spanComment{\# foo's type is resolved to an int here}
\spanIdentifier{foo} \spanOperator{=} \spanStringLit{"this will fail"} \spanComment{\# error here, because foo is an int}
\end{rstpre}
Nim allows for type classes and regular types to be specified as type constraints\label{type-constraints_1} of the generic type parameter:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{onlyIntOrString}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{:} \spanIdentifier{int}\spanOperator{|}\spanIdentifier{string}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}

\spanIdentifier{onlyIntOrString}\spanPunctuation{(}\spanDecNumber{450}\spanPunctuation{,} \spanDecNumber{616}\spanPunctuation{)} \spanComment{\# valid}
\spanIdentifier{onlyIntOrString}\spanPunctuation{(}\spanFloatNumber{5.0}\spanPunctuation{,} \spanFloatNumber{0.0}\spanPunctuation{)} \spanComment{\# type mismatch}
\spanIdentifier{onlyIntOrString}\spanPunctuation{(}\spanStringLit{"xy"}\spanPunctuation{,} \spanDecNumber{50}\spanPunctuation{)} \spanComment{\# invalid as 'T' cannot be both at the same time}
\end{rstpre}
\rsthB{Implicit generics}\label{generics-implicit-generics}
A type class can be used directly as the parameter's type.

\begin{rstpre}
\spanComment{\# create a type class that will match all tuple and object types}
\spanKeyword{type} \spanIdentifier{RecordType} \spanOperator{=} \spanKeyword{tuple} \spanKeyword{or} \spanKeyword{object}

\spanKeyword{proc} \spanIdentifier{printFields}\spanPunctuation{(}\spanIdentifier{rec}\spanPunctuation{:} \spanIdentifier{RecordType}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{for} \spanIdentifier{key}\spanPunctuation{,} \spanIdentifier{value} \spanKeyword{in} \spanIdentifier{fieldPairs}\spanPunctuation{(}\spanIdentifier{rec}\spanPunctuation{)}\spanPunctuation{:}
    \spanIdentifier{echo} \spanIdentifier{key}\spanPunctuation{,} \spanStringLit{" = "}\spanPunctuation{,} \spanIdentifier{value}
\end{rstpre}
Procedures utilizing type classes in such manner are considered to be implicitly generic\label{implicitly-generic_1}. They will be instantiated once for each unique combination of param types used within the program.

By default, during overload resolution each named type class will bind to exactly one concrete type. We call such type classes bind once\label{bind-once_1} types. Here is an example taken directly from the system module to illustrate this:

\begin{rstpre}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{==}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanKeyword{tuple}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanComment{\#\# requires \symbol{96}x\symbol{96} and \symbol{96}y\symbol{96} to be of the same tuple type}
  \spanComment{\#\# generic \symbol{96}\symbol{96}==\symbol{96}\symbol{96} operator for tuples that is lifted from the components}
  \spanComment{\#\# of \symbol{96}x\symbol{96} and \symbol{96}y\symbol{96}.}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{true}
  \spanKeyword{for} \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b} \spanKeyword{in} \spanIdentifier{fields}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{)}\spanPunctuation{:}
    \spanKeyword{if} \spanIdentifier{a} \spanOperator{!=} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{result} \spanOperator{=} \spanIdentifier{false}
\end{rstpre}
Alternatively, the \texttt{distinct} type modifier can be applied to the type class to allow each param matching the type class to bind to a different type. Such type classes are called bind many\label{bind-many_1} types.

Procs written with the implicitly generic style will often need to refer to the type parameters of the matched generic type. They can be easily accessed using the dot syntax:

\begin{rstpre}
\spanKeyword{type} \spanIdentifier{Matrix}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{,} \spanIdentifier{Rows}\spanPunctuation{,} \spanIdentifier{Columns}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{object}
  \spanOperator{...}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{m}\spanPunctuation{:} \spanIdentifier{Matrix}\spanPunctuation{,} \spanIdentifier{row}\spanPunctuation{,} \spanIdentifier{col}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Matrix}\spanOperator{.}\spanIdentifier{T} \spanOperator{=}
  \spanIdentifier{m}\spanOperator{.}\spanIdentifier{data}\spanPunctuation{\symbol{91}}\spanIdentifier{col} \spanOperator{*} \spanIdentifier{high}\spanPunctuation{(}\spanIdentifier{Matrix}\spanOperator{.}\spanIdentifier{Columns}\spanPunctuation{)} \spanOperator{+} \spanIdentifier{row}\spanPunctuation{\symbol{93}}
\end{rstpre}
Here are more examples that illustrate implicit generics:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{t}\spanPunctuation{:} \spanIdentifier{Table}\spanPunctuation{;} \spanIdentifier{k}\spanPunctuation{:} \spanIdentifier{Table}\spanOperator{.}\spanIdentifier{Key}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Table}\spanOperator{.}\spanIdentifier{Value}

\spanComment{\# is roughly the same as:}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{\symbol{91}}\spanIdentifier{Key}\spanPunctuation{,} \spanIdentifier{Value}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{t}\spanPunctuation{:} \spanIdentifier{Table}\spanPunctuation{\symbol{91}}\spanIdentifier{Key}\spanPunctuation{,} \spanIdentifier{Value}\spanPunctuation{\symbol{93}}\spanPunctuation{;} \spanIdentifier{k}\spanPunctuation{:} \spanIdentifier{Key}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Value}
\end{rstpre}
\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{Table}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Table}\spanPunctuation{)}

\spanComment{\# is roughly the same as:}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{\symbol{91}}\spanIdentifier{Key}\spanPunctuation{,} \spanIdentifier{Value}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Table}\spanPunctuation{\symbol{91}}\spanIdentifier{Key}\spanPunctuation{,} \spanIdentifier{Value}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{Table}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanKeyword{distinct} \spanIdentifier{Table}\spanPunctuation{)}

\spanComment{\# is roughly the same as:}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{\symbol{91}}\spanIdentifier{Key}\spanPunctuation{,} \spanIdentifier{Value}\spanPunctuation{,} \spanIdentifier{KeyB}\spanPunctuation{,} \spanIdentifier{ValueB}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{Table}\spanPunctuation{\symbol{91}}\spanIdentifier{Key}\spanPunctuation{,} \spanIdentifier{Value}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Table}\spanPunctuation{\symbol{91}}\spanIdentifier{KeyB}\spanPunctuation{,} \spanIdentifier{ValueB}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
\texttt{typedesc} used as a parameter type also introduces an implicit generic. \texttt{typedesc} has its own set of rules:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{)}

\spanComment{\# is roughly the same as:}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
\texttt{typedesc} is a "bind many" type class:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{)}

\spanComment{\# is roughly the same as:}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{,} \spanIdentifier{T2}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanIdentifier{T2}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
A parameter of type \texttt{typedesc} is itself usable as a type. If it is used as a type, it's the underlying type. (In other words, one level of "typedesc"-ness is stripped off:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{;} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{a}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}

\spanComment{\# is roughly the same as:}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{;} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}

\spanComment{\# hence this is a valid call:}
\spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{int}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{)}
\spanComment{\# as parameter 'a' requires a type, but 'b' requires a value.}
\end{rstpre}
\rsthB{Generic inference restrictions}\label{generics-generic-inference-restrictions}
The types \texttt{var T}, \texttt{out T} and \texttt{typedesc\symbol{91}T\symbol{93}} cannot be inferred in a generic instantiation. The following is not allowed:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{g}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{:} \spanKeyword{proc}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)}\spanPunctuation{;} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{f}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{c}\spanPunctuation{(}\spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=} \spanIdentifier{echo} \spanIdentifier{y}
\spanKeyword{proc} \spanIdentifier{v}\spanPunctuation{(}\spanIdentifier{y}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{y} \spanOperator{+=} \spanDecNumber{100}
\spanKeyword{var} \spanIdentifier{i}\spanPunctuation{:} \spanIdentifier{int}

\spanComment{\# allowed: infers 'T' to be of type 'int'}
\spanIdentifier{g}\spanPunctuation{(}\spanIdentifier{c}\spanPunctuation{,} \spanDecNumber{42}\spanPunctuation{)}

\spanComment{\# not valid: 'T' is not inferred to be of type 'var int'}
\spanIdentifier{g}\spanPunctuation{(}\spanIdentifier{v}\spanPunctuation{,} \spanIdentifier{i}\spanPunctuation{)}

\spanComment{\# also not allowed: explicit instantiation via 'var int'}
\spanIdentifier{g}\spanPunctuation{\symbol{91}}\spanKeyword{var} \spanIdentifier{int}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{v}\spanPunctuation{,} \spanIdentifier{i}\spanPunctuation{)}
\end{rstpre}
\rsthB{Symbol lookup in generics}\label{generics-symbol-lookup-in-generics}
\rsthC{Open and Closed symbols}\label{symbol-lookup-in-generics-open-and-closed-symbols}
The symbol binding rules in generics are slightly subtle: There are "open" and "closed" symbols. A "closed" symbol cannot be re-bound in the instantiation context, an "open" symbol can. Per default overloaded symbols are open and every other symbol is closed.

Open symbols are looked up in two different contexts: Both the context at definition and the context at instantiation are considered:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Index} \spanOperator{=} \spanKeyword{distinct} \spanIdentifier{int}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{==}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Index}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{borrow}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{var} \spanIdentifier{a} \spanOperator{=} \spanPunctuation{(}\spanDecNumber{0}\spanPunctuation{,} \spanFloatNumber{0.}\spanIdentifier{Index}\spanPunctuation{)}
\spanKeyword{var} \spanIdentifier{b} \spanOperator{=} \spanPunctuation{(}\spanDecNumber{0}\spanPunctuation{,} \spanFloatNumber{0.}\spanIdentifier{Index}\spanPunctuation{)}

\spanIdentifier{echo} \spanIdentifier{a} \spanOperator{==} \spanIdentifier{b} \spanComment{\# works!}
\end{rstpre}
In the example the generic \texttt{==} for tuples (as defined in the system module) uses the \texttt{==} operators of the tuple's components. However, the \texttt{==} for the \texttt{Index} type is defined \emph{after} the \texttt{==} for tuples; yet the example compiles as the instantiation takes the currently defined symbols into account too.

\rsthB{Mixin statement}\label{generics-mixin-statement}
A symbol can be forced to be open by a mixin\label{mixin_1} declaration:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{create}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{ref} \spanIdentifier{T} \spanOperator{=}
  \spanComment{\# there is no overloaded 'init' here, so we need to state that it's an}
  \spanComment{\# open symbol explicitly:}
  \spanKeyword{mixin} \spanIdentifier{init}
  \spanIdentifier{new} \spanIdentifier{result}
  \spanIdentifier{init} \spanIdentifier{result}
\end{rstpre}
\texttt{mixin} statements only make sense in templates and generics.

\rsthB{Bind statement}\label{generics-bind-statement}
The \texttt{bind} statement is the counterpart to the \texttt{mixin} statement. It can be used to explicitly declare identifiers that should be bound early (i.e. the identifiers should be looked up in the scope of the template/generic definition):

\begin{rstpre}
\spanComment{\# Module A}
\spanKeyword{var}
  \spanIdentifier{lastId} \spanOperator{=} \spanDecNumber{0}

\spanKeyword{template} \spanIdentifier{genId}\spanOperator{*:} \spanIdentifier{untyped} \spanOperator{=}
  \spanKeyword{bind} \spanIdentifier{lastId}
  \spanIdentifier{inc}\spanPunctuation{(}\spanIdentifier{lastId}\spanPunctuation{)}
  \spanIdentifier{lastId}
\end{rstpre}
\begin{rstpre}
\spanComment{\# Module B}
\spanKeyword{import} \spanIdentifier{A}

\spanIdentifier{echo} \spanIdentifier{genId}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
But a \texttt{bind} is rarely useful because symbol binding from the definition scope is the default.

\texttt{bind} statements only make sense in templates and generics.

\rsthA{Templates}\label{templates}
A template is a simple form of a macro: It is a simple substitution mechanism that operates on Nim's abstract syntax trees. It is processed in the semantic pass of the compiler.

The syntax to \emph{invoke} a template is the same as calling a procedure.

Example:

\begin{rstpre}
\spanKeyword{template} \spanPunctuation{\symbol{96}}\spanOperator{!=}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanComment{\# this definition exists in the System module}
  \spanKeyword{not} \spanPunctuation{(}\spanIdentifier{a} \spanOperator{==} \spanIdentifier{b}\spanPunctuation{)}

\spanIdentifier{assert}\spanPunctuation{(}\spanDecNumber{5} \spanOperator{!=} \spanDecNumber{6}\spanPunctuation{)} \spanComment{\# the compiler rewrites that to: assert(not (5 == 6))}
\end{rstpre}
The \texttt{!=}, \texttt{>}, \texttt{>=}, \texttt{in}, \texttt{notin}, \texttt{isnot} operators are in fact templates:

\texttt{a > b} is transformed into \texttt{b < a}.\\
\texttt{a in b} is transformed into \texttt{contains(b, a)}.\\
\texttt{notin} and \texttt{isnot} have the obvious meanings.\\


The "types" of templates can be the symbols \texttt{untyped}, \texttt{typed} or \texttt{typedesc}. These are "meta types", they can only be used in certain contexts. Regular types can be used too; this implies that \texttt{typed} expressions are expected.

\rsthB{Typed vs untyped parameters}\label{templates-typed-vs-untyped-parameters}
An \texttt{untyped} parameter means that symbol lookups and type resolution is not performed before the expression is passed to the template. This means that for example \emph{undeclared} identifiers can be passed to the template:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{declareInt}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}

\spanIdentifier{declareInt}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)} \spanComment{\# valid}
\spanIdentifier{x} \spanOperator{=} \spanDecNumber{3}
\end{rstpre}
\begin{rstpre}
\spanKeyword{template} \spanIdentifier{declareInt}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{typed}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{int}

\spanIdentifier{declareInt}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)} \spanComment{\# invalid, because x has not been declared and so has no type}
\end{rstpre}
A template where every parameter is \texttt{untyped} is called an immediate\label{immediate_1} template. For historical reasons templates can be explicitly annotated with an \texttt{immediate} pragma and then these templates do not take part in overloading resolution and the parameters' types are \emph{ignored} by the compiler. Explicit immediate templates are now deprecated.

\textbf{Note}: For historical reasons \texttt{stmt} was an alias for \texttt{typed} and \texttt{expr} was an alias for \texttt{untyped}, but they are removed.

\rsthB{Passing a code block to a template}\label{templates-passing-a-code-block-to-a-template}
One can pass a block of statements as the last argument to a template following the special \texttt{:} syntax:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{withFile}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanIdentifier{fn}\spanPunctuation{,} \spanIdentifier{mode}\spanPunctuation{,} \spanIdentifier{actions}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{File}
  \spanKeyword{if} \spanIdentifier{open}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanIdentifier{fn}\spanPunctuation{,} \spanIdentifier{mode}\spanPunctuation{)}\spanPunctuation{:}
    \spanKeyword{try}\spanPunctuation{:}
      \spanIdentifier{actions}
    \spanKeyword{finally}\spanPunctuation{:}
      \spanIdentifier{close}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{)}
  \spanKeyword{else}\spanPunctuation{:}
    \spanIdentifier{quit}\spanPunctuation{(}\spanStringLit{"cannot open: "} \spanOperator{\&} \spanIdentifier{fn}\spanPunctuation{)}

\spanIdentifier{withFile}\spanPunctuation{(}\spanIdentifier{txt}\spanPunctuation{,} \spanStringLit{"ttempl3.txt"}\spanPunctuation{,} \spanIdentifier{fmWrite}\spanPunctuation{)}\spanPunctuation{:}  \spanComment{\# special colon}
  \spanIdentifier{txt}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanStringLit{"line 1"}\spanPunctuation{)}
  \spanIdentifier{txt}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanStringLit{"line 2"}\spanPunctuation{)}
\end{rstpre}
In the example, the two \texttt{writeLine} statements are bound to the \texttt{actions} parameter.

Usually to pass a block of code to a template the parameter that accepts the block needs to be of type \texttt{untyped}. Because symbol lookups are then delayed until template instantiation time:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{t}\spanPunctuation{(}\spanIdentifier{body}\spanPunctuation{:} \spanIdentifier{typed}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{block}\spanPunctuation{:}
    \spanIdentifier{body}

\spanIdentifier{t}\spanPunctuation{:}
  \spanKeyword{var} \spanIdentifier{i} \spanOperator{=} \spanDecNumber{1}
  \spanIdentifier{echo} \spanIdentifier{i}

\spanIdentifier{t}\spanPunctuation{:}
  \spanKeyword{var} \spanIdentifier{i} \spanOperator{=} \spanDecNumber{2}  \spanComment{\# fails with 'attempt to redeclare i'}
  \spanIdentifier{echo} \spanIdentifier{i}
\end{rstpre}
The above code fails with the mysterious error message that \texttt{i} has already been declared. The reason for this is that the \texttt{var i = ...} bodies need to be type-checked before they are passed to the \texttt{body} parameter and type checking in Nim implies symbol lookups. For the symbol lookups to succeed \texttt{i} needs to be added to the current (i.e. outer) scope. After type checking these additions to the symbol table are not rolled back (for better or worse). The same code works with \texttt{untyped} as the passed body is not required to be type-checked:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{t}\spanPunctuation{(}\spanIdentifier{body}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{block}\spanPunctuation{:}
    \spanIdentifier{body}

\spanIdentifier{t}\spanPunctuation{:}
  \spanKeyword{var} \spanIdentifier{i} \spanOperator{=} \spanDecNumber{1}
  \spanIdentifier{echo} \spanIdentifier{i}

\spanIdentifier{t}\spanPunctuation{:}
  \spanKeyword{var} \spanIdentifier{i} \spanOperator{=} \spanDecNumber{2}  \spanComment{\# compiles}
  \spanIdentifier{echo} \spanIdentifier{i}
\end{rstpre}
\rsthB{Varargs of untyped}\label{templates-varargs-of-untyped}
In addition to the \texttt{untyped} meta-type that prevents type checking there is also \texttt{varargs\symbol{91}untyped\symbol{93}} so that not even the number of parameters is fixed:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{hideIdentifiers}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{untyped}\spanPunctuation{\symbol{93}}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}

\spanIdentifier{hideIdentifiers}\spanPunctuation{(}\spanIdentifier{undeclared1}\spanPunctuation{,} \spanIdentifier{undeclared2}\spanPunctuation{)}
\end{rstpre}
However, since a template cannot iterate over varargs, this feature is generally much more useful for macros.

\rsthB{Symbol binding in templates}\label{templates-symbol-binding-in-templates}
A template is a hygienic\label{hygienic_1} macro and so opens a new scope. Most symbols are bound from the definition scope of the template:

\begin{rstpre}
\spanComment{\# Module A}
\spanKeyword{var}
  \spanIdentifier{lastId} \spanOperator{=} \spanDecNumber{0}

\spanKeyword{template} \spanIdentifier{genId}\spanOperator{*:} \spanIdentifier{untyped} \spanOperator{=}
  \spanIdentifier{inc}\spanPunctuation{(}\spanIdentifier{lastId}\spanPunctuation{)}
  \spanIdentifier{lastId}
\end{rstpre}
\begin{rstpre}
\spanComment{\# Module B}
\spanKeyword{import} \spanIdentifier{A}

\spanIdentifier{echo} \spanIdentifier{genId}\spanPunctuation{(}\spanPunctuation{)} \spanComment{\# Works as 'lastId' has been bound in 'genId's defining scope}
\end{rstpre}
As in generics symbol binding can be influenced via \texttt{mixin} or \texttt{bind} statements.

\rsthB{Identifier construction}\label{templates-identifier-construction}
In templates identifiers can be constructed with the backticks notation:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{typedef}\spanPunctuation{(}\spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{,} \spanIdentifier{typ}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{type}
    \spanPunctuation{\symbol{96}}\spanIdentifier{T} \spanIdentifier{name}\spanPunctuation{\symbol{96}}\spanOperator{*} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{inject}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanIdentifier{typ}
    \spanPunctuation{\symbol{96}}\spanIdentifier{P} \spanIdentifier{name}\spanPunctuation{\symbol{96}}\spanOperator{*} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{inject}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{ref} \spanPunctuation{\symbol{96}}\spanIdentifier{T} \spanIdentifier{name}\spanPunctuation{\symbol{96}}

\spanIdentifier{typedef}\spanPunctuation{(}\spanIdentifier{myint}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{)}
\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{PMyInt}
\end{rstpre}
In the example \texttt{name} is instantiated with \texttt{myint}, so \symbol{96}T name\symbol{96} becomes \texttt{Tmyint}.

\rsthB{Lookup rules for template parameters}\label{templates-lookup-rules-for-template-parameters}
A parameter \texttt{p} in a template is even substituted in the expression \texttt{x.p}. Thus template arguments can be used as field names and a global symbol can be shadowed by the same argument name even when fully qualified:

\begin{rstpre}
\spanComment{\# module 'm'}

\spanKeyword{type}
  \spanIdentifier{Lev} \spanOperator{=} \spanKeyword{enum}
    \spanIdentifier{levA}\spanPunctuation{,} \spanIdentifier{levB}

\spanKeyword{var} \spanIdentifier{abclev} \spanOperator{=} \spanIdentifier{levB}

\spanKeyword{template} \spanIdentifier{tstLev}\spanPunctuation{(}\spanIdentifier{abclev}\spanPunctuation{:} \spanIdentifier{Lev}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo} \spanIdentifier{abclev}\spanPunctuation{,} \spanStringLit{" "}\spanPunctuation{,} \spanIdentifier{m}\spanOperator{.}\spanIdentifier{abclev}

\spanIdentifier{tstLev}\spanPunctuation{(}\spanIdentifier{levA}\spanPunctuation{)}
\spanComment{\# produces: 'levA levA'}
\end{rstpre}
But the global symbol can properly be captured by a \texttt{bind} statement:

\begin{rstpre}
\spanComment{\# module 'm'}

\spanKeyword{type}
  \spanIdentifier{Lev} \spanOperator{=} \spanKeyword{enum}
    \spanIdentifier{levA}\spanPunctuation{,} \spanIdentifier{levB}

\spanKeyword{var} \spanIdentifier{abclev} \spanOperator{=} \spanIdentifier{levB}

\spanKeyword{template} \spanIdentifier{tstLev}\spanPunctuation{(}\spanIdentifier{abclev}\spanPunctuation{:} \spanIdentifier{Lev}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{bind} \spanIdentifier{m}\spanOperator{.}\spanIdentifier{abclev}
  \spanIdentifier{echo} \spanIdentifier{abclev}\spanPunctuation{,} \spanStringLit{" "}\spanPunctuation{,} \spanIdentifier{m}\spanOperator{.}\spanIdentifier{abclev}

\spanIdentifier{tstLev}\spanPunctuation{(}\spanIdentifier{levA}\spanPunctuation{)}
\spanComment{\# produces: 'levA levB'}
\end{rstpre}
\rsthB{Hygiene in templates}\label{templates-hygiene-in-templates}
Per default templates are hygienic\label{hygienic_2}: Local identifiers declared in a template cannot be accessed in the instantiation context:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{newException}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{exceptn}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{,} \spanIdentifier{message}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanKeyword{var}
    \spanIdentifier{e}\spanPunctuation{:} \spanKeyword{ref} \spanIdentifier{exceptn}  \spanComment{\# e is implicitly gensym'ed here}
  \spanIdentifier{new}\spanPunctuation{(}\spanIdentifier{e}\spanPunctuation{)}
  \spanIdentifier{e}\spanOperator{.}\spanIdentifier{msg} \spanOperator{=} \spanIdentifier{message}
  \spanIdentifier{e}

\spanComment{\# so this works:}
\spanKeyword{let} \spanIdentifier{e} \spanOperator{=} \spanStringLit{"message"}
\spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{IoError}\spanPunctuation{,} \spanIdentifier{e}\spanPunctuation{)}
\end{rstpre}
Whether a symbol that is declared in a template is exposed to the instantiation scope is controlled by the inject\label{inject_1} and gensym\label{gensym_1} pragmas: gensym'ed symbols are not exposed but inject'ed are.

The default for symbols of entity \texttt{type}, \texttt{var}, \texttt{let} and \texttt{const} is \texttt{gensym} and for \texttt{proc}, \texttt{iterator}, \texttt{converter}, \texttt{template}, \texttt{macro} is \texttt{inject}. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{withFile}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{,} \spanIdentifier{fn}\spanPunctuation{,} \spanIdentifier{mode}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{,} \spanIdentifier{actions}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanKeyword{block}\spanPunctuation{:}
    \spanKeyword{var} \spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{File}  \spanComment{\# since 'f' is a template param, it's injected implicitly}
    \spanOperator{...}

\spanIdentifier{withFile}\spanPunctuation{(}\spanIdentifier{txt}\spanPunctuation{,} \spanStringLit{"ttempl3.txt"}\spanPunctuation{,} \spanIdentifier{fmWrite}\spanPunctuation{)}\spanPunctuation{:}
  \spanIdentifier{txt}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanStringLit{"line 1"}\spanPunctuation{)}
  \spanIdentifier{txt}\spanOperator{.}\spanIdentifier{writeLine}\spanPunctuation{(}\spanStringLit{"line 2"}\spanPunctuation{)}
\end{rstpre}
The \texttt{inject} and \texttt{gensym} pragmas are second class annotations; they have no semantics outside of a template definition and cannot be abstracted over:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pragma} \spanIdentifier{myInject}\spanPunctuation{:} \spanIdentifier{inject}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{template} \spanIdentifier{t}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{x} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{myInject}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int} \spanComment{\# does NOT work}
\end{rstpre}
To get rid of hygiene in templates, one can use the dirty\label{dirty_1} pragma for a template. \texttt{inject} and \texttt{gensym} have no effect in \texttt{dirty} templates.

\texttt{gensym}'ed symbols cannot be used as \texttt{field} in the \texttt{x.field} syntax. Nor can they be used in the \texttt{ObjectConstruction(field: value)} and \texttt{namedParameterCall(field = value)} syntactic constructs.

The reason for this is that code like

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{T} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{f}\spanPunctuation{:} \spanIdentifier{int}

\spanKeyword{template} \spanIdentifier{tmp}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{let} \spanIdentifier{f} \spanOperator{=} \spanDecNumber{34}
  \spanIdentifier{echo} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{f}\spanPunctuation{,} \spanIdentifier{T}\spanPunctuation{(}\spanIdentifier{f}\spanPunctuation{:} \spanDecNumber{4}\spanPunctuation{)}
\end{rstpre}
should work as expected.

However, this means that the method call syntax is not available for \texttt{gensym}'ed symbols:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{tmp}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{type}
    \spanIdentifier{T} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{gensym}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanIdentifier{int}
  
  \spanIdentifier{echo} \spanIdentifier{x}\spanOperator{.}\spanIdentifier{T} \spanComment{\# invalid: instead use:  'echo T(x)'.}

\spanIdentifier{tmp}\spanPunctuation{(}\spanDecNumber{12}\spanPunctuation{)}
\end{rstpre}
\textbf{Note}: The Nim compiler prior to version 1 was more lenient about this requirement. Use the \texttt{--useVersion:0.19} switch for a transition period.

\rsthB{Limitations of the method call syntax}\label{templates-limitations-of-the-method-call-syntax}
The expression \texttt{x} in \texttt{x.f} needs to be semantically checked (that means symbol lookup and type checking) before it can be decided that it needs to be rewritten to \texttt{f(x)}. Therefore the dot syntax has some limitations when it is used to invoke templates/macros:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{declareVar}\spanPunctuation{(}\spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{const} \spanIdentifier{name} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{inject}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanDecNumber{45}

\spanComment{\# Doesn't compile:}
\spanIdentifier{unknownIdentifier}\spanOperator{.}\spanIdentifier{declareVar}
\end{rstpre}
Another common example is this:

\begin{rstpre}
\spanKeyword{from} \spanIdentifier{sequtils} \spanKeyword{import} \spanIdentifier{toSeq}

\spanKeyword{iterator} \spanIdentifier{something}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanKeyword{yield} \spanStringLit{"Hello"}
  \spanKeyword{yield} \spanStringLit{"World"}

\spanKeyword{var} \spanIdentifier{info} \spanOperator{=} \spanIdentifier{something}\spanPunctuation{(}\spanPunctuation{)}\spanOperator{.}\spanIdentifier{toSeq}
\end{rstpre}
The problem here is that the compiler already decided that \texttt{something()} as an iterator is not callable in this context before \texttt{toSeq} gets its chance to convert it into a sequence.

It is also not possible to use fully qualified identifiers with module symbol in method call syntax. The order in which the dot operator binds to symbols prohibits this.

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{sequtils}

\spanKeyword{var} \spanIdentifier{myItems} \spanOperator{=} \spanOperator{\symbol{64}}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{,}\spanDecNumber{3}\spanPunctuation{,}\spanDecNumber{3}\spanPunctuation{,}\spanDecNumber{7}\spanPunctuation{\symbol{93}}
\spanKeyword{let} \spanIdentifier{N1} \spanOperator{=} \spanIdentifier{count}\spanPunctuation{(}\spanIdentifier{myItems}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{)} \spanComment{\# OK}
\spanKeyword{let} \spanIdentifier{N2} \spanOperator{=} \spanIdentifier{sequtils}\spanOperator{.}\spanIdentifier{count}\spanPunctuation{(}\spanIdentifier{myItems}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{)} \spanComment{\# fully qualified, OK}
\spanKeyword{let} \spanIdentifier{N3} \spanOperator{=} \spanIdentifier{myItems}\spanOperator{.}\spanIdentifier{count}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{)} \spanComment{\# OK}
\spanKeyword{let} \spanIdentifier{N4} \spanOperator{=} \spanIdentifier{myItems}\spanOperator{.}\spanIdentifier{sequtils}\spanOperator{.}\spanIdentifier{count}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{)} \spanComment{\# illegal, \symbol{96}myItems.sequtils\symbol{96} can't be resolved}
\end{rstpre}
This means that when for some reason a procedure needs a disambiguation through the module name, the call needs to be written in function call syntax.

\rsthA{Macros}\label{macros}
A macro is a special function that is executed at compile time. Normally the input for a macro is an abstract syntax tree (AST) of the code that is passed to it. The macro can then do transformations on it and return the transformed AST. This can be used to add custom language features and implement domain specific languages\label{domain-specific-languages_1}.

Macro invocation is a case where semantic analysis does \textbf{not} entirely proceed top to bottom and left to right. Instead, semantic analysis happens at least twice:

\begin{itemize}\item Semantic analysis recognizes and resolves the macro invocation.
\item The compiler executes the macro body (which may invoke other procs).
\item It replaces the AST of the macro invocation with the AST returned by the macro.
\item It repeats semantic analysis of that region of the code.
\item If the AST returned by the macro contains other macro invocations, this process iterates.
\end{itemize}
While macros enable advanced compile-time code transformations, they cannot change Nim's syntax.

\rsthB{Debug Example}\label{macros-debug-example}
The following example implements a powerful \texttt{debug} command that accepts a variable number of arguments:

\begin{rstpre}
\spanComment{\# to work with Nim syntax trees, we need an API that is defined in the}
\spanComment{\# \symbol{96}\symbol{96}macros\symbol{96}\symbol{96} module:}
\spanKeyword{import} \spanIdentifier{macros}

\spanKeyword{macro} \spanIdentifier{debug}\spanPunctuation{(}\spanIdentifier{args}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{untyped}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanComment{\# \symbol{96}args\symbol{96} is a collection of \symbol{96}NimNode\symbol{96} values that each contain the}
  \spanComment{\# AST for an argument of the macro. A macro always has to}
  \spanComment{\# return a \symbol{96}NimNode\symbol{96}. A node of kind \symbol{96}nnkStmtList\symbol{96} is suitable for}
  \spanComment{\# this use case.}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{nnkStmtList}\spanOperator{.}\spanIdentifier{newTree}\spanPunctuation{(}\spanPunctuation{)}
  \spanComment{\# iterate over any argument that is passed to this macro:}
  \spanKeyword{for} \spanIdentifier{n} \spanKeyword{in} \spanIdentifier{args}\spanPunctuation{:}
    \spanComment{\# add a call to the statement list that writes the expression;}
    \spanComment{\# \symbol{96}toStrLit\symbol{96} converts an AST to its string representation:}
    \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{newCall}\spanPunctuation{(}\spanStringLit{"write"}\spanPunctuation{,} \spanIdentifier{newIdentNode}\spanPunctuation{(}\spanStringLit{"stdout"}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{newLit}\spanPunctuation{(}\spanIdentifier{n}\spanOperator{.}\spanIdentifier{repr}\spanPunctuation{)}\spanPunctuation{)}
    \spanComment{\# add a call to the statement list that writes ": "}
    \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{newCall}\spanPunctuation{(}\spanStringLit{"write"}\spanPunctuation{,} \spanIdentifier{newIdentNode}\spanPunctuation{(}\spanStringLit{"stdout"}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{newLit}\spanPunctuation{(}\spanStringLit{": "}\spanPunctuation{)}\spanPunctuation{)}
    \spanComment{\# add a call to the statement list that writes the expressions value:}
    \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{newCall}\spanPunctuation{(}\spanStringLit{"writeLine"}\spanPunctuation{,} \spanIdentifier{newIdentNode}\spanPunctuation{(}\spanStringLit{"stdout"}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{n}\spanPunctuation{)}

\spanKeyword{var}
  \spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{10}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{\symbol{93}}
  \spanIdentifier{x} \spanOperator{=} \spanStringLit{"some string"}
\spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanDecNumber{42}
\spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanDecNumber{45}

\spanIdentifier{debug}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{)}
\end{rstpre}
The macro call expands to:

\begin{rstpre}
\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{"a\symbol{91}0\symbol{93}"}\spanPunctuation{)}
\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{": "}\spanPunctuation{)}
\spanIdentifier{writeLine}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}\spanPunctuation{)}

\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{"a\symbol{91}1\symbol{93}"}\spanPunctuation{)}
\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{": "}\spanPunctuation{)}
\spanIdentifier{writeLine}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}}\spanPunctuation{)}

\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{"x"}\spanPunctuation{)}
\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{": "}\spanPunctuation{)}
\spanIdentifier{writeLine}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{)}
\end{rstpre}
Arguments that are passed to a \texttt{varargs} parameter are wrapped in an array constructor expression. This is why \texttt{debug} iterates over all of \texttt{n}'s children.

\rsthB{BindSym}\label{macros-bindsym}
The above \texttt{debug} macro relies on the fact that \texttt{write}, \texttt{writeLine} and \texttt{stdout} are declared in the system module and thus visible in the instantiating context. There is a way to use bound identifiers (aka symbols\label{symbols_1}) instead of using unbound identifiers. The \texttt{bindSym} builtin can be used for that:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{macros}

\spanKeyword{macro} \spanIdentifier{debug}\spanPunctuation{(}\spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{typed}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{newNimNode}\spanPunctuation{(}\spanIdentifier{nnkStmtList}\spanPunctuation{,} \spanIdentifier{n}\spanPunctuation{)}
  \spanKeyword{for} \spanIdentifier{x} \spanKeyword{in} \spanIdentifier{n}\spanPunctuation{:}
    \spanComment{\# we can bind symbols in scope via 'bindSym':}
    \spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{,} \spanIdentifier{newCall}\spanPunctuation{(}\spanRawData{bindSym"write"}\spanPunctuation{,} \spanRawData{bindSym"stdout"}\spanPunctuation{,} \spanIdentifier{toStrLit}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)}\spanPunctuation{)}\spanPunctuation{)}
    \spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{,} \spanIdentifier{newCall}\spanPunctuation{(}\spanRawData{bindSym"write"}\spanPunctuation{,} \spanRawData{bindSym"stdout"}\spanPunctuation{,} \spanIdentifier{newStrLitNode}\spanPunctuation{(}\spanStringLit{": "}\spanPunctuation{)}\spanPunctuation{)}\spanPunctuation{)}
    \spanIdentifier{add}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{,} \spanIdentifier{newCall}\spanPunctuation{(}\spanRawData{bindSym"writeLine"}\spanPunctuation{,} \spanRawData{bindSym"stdout"}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{)}\spanPunctuation{)}

\spanKeyword{var}
  \spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{10}\spanPunctuation{,} \spanIdentifier{int}\spanPunctuation{\symbol{93}}
  \spanIdentifier{x} \spanOperator{=} \spanStringLit{"some string"}
\spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanDecNumber{42}
\spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanDecNumber{45}

\spanIdentifier{debug}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{)}
\end{rstpre}
The macro call expands to:

\begin{rstpre}
\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{"a\symbol{91}0\symbol{93}"}\spanPunctuation{)}
\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{": "}\spanPunctuation{)}
\spanIdentifier{writeLine}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}\spanPunctuation{)}

\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{"a\symbol{91}1\symbol{93}"}\spanPunctuation{)}
\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{": "}\spanPunctuation{)}
\spanIdentifier{writeLine}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}}\spanPunctuation{)}

\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{"x"}\spanPunctuation{)}
\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanStringLit{": "}\spanPunctuation{)}
\spanIdentifier{writeLine}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{)}
\end{rstpre}
However, the symbols \texttt{write}, \texttt{writeLine} and \texttt{stdout} are already bound and are not looked up again. As the example shows, \texttt{bindSym} does work with overloaded symbols implicitly.

\rsthB{Case-Of Macro}\label{macros-caseminusof-macro}
In Nim it is possible to have a macro with the syntax of a \emph{case-of} expression just with the difference that all of branches are passed to and processed by the macro implementation. It is then up the macro implementation to transform the \emph{of-branches} into a valid Nim statement. The following example should show how this feature could be used for a lexical analyzer.

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{macros}

\spanKeyword{macro} \spanIdentifier{case\_token}\spanPunctuation{(}\spanIdentifier{args}\spanPunctuation{:} \spanIdentifier{varargs}\spanPunctuation{\symbol{91}}\spanIdentifier{untyped}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanIdentifier{echo} \spanIdentifier{args}\spanOperator{.}\spanIdentifier{treeRepr}
  \spanComment{\# creates a lexical analyzer from regular expressions}
  \spanComment{\# ... (implementation is an exercise for the reader ;-)}
  \spanKeyword{discard}

\spanIdentifier{case\_token}\spanPunctuation{:} \spanComment{\# this colon tells the parser it is a macro statement}
\spanKeyword{of} \spanRawData{r"\symbol{91}A-Za-z\_\symbol{93}+\symbol{91}A-Za-z\_0-9\symbol{93}*"}\spanPunctuation{:}
  \spanKeyword{return} \spanIdentifier{tkIdentifier}
\spanKeyword{of} \spanRawData{r"0-9+"}\spanPunctuation{:}
  \spanKeyword{return} \spanIdentifier{tkInteger}
\spanKeyword{of} \spanRawData{r"\symbol{91}\symbol{92}+\symbol{92}-\symbol{92}*\symbol{92}?\symbol{93}+"}\spanPunctuation{:}
  \spanKeyword{return} \spanIdentifier{tkOperator}
\spanKeyword{else}\spanPunctuation{:}
  \spanKeyword{return} \spanIdentifier{tkUnknown}
\end{rstpre}
\textbf{Style note}: For code readability, it is the best idea to use the least powerful programming construct that still suffices. So the "check list" is:

\begin{enumerate}\item Use an ordinary proc/iterator, if possible.
\item Else: Use a generic proc/iterator, if possible.
\item Else: Use a template, if possible.
\item Else: Use a macro.
\end{enumerate}
\rsthA{Special Types}\label{special-types}
\rsthB{static\symbol{91}T\symbol{93}}\label{special-types-static-t}
As their name suggests, static parameters must be constant expressions:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{precompiledRegex}\spanPunctuation{(}\spanIdentifier{pattern}\spanPunctuation{:} \spanKeyword{static} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{RegEx} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{res} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{global}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanIdentifier{re}\spanPunctuation{(}\spanIdentifier{pattern}\spanPunctuation{)}
  \spanKeyword{return} \spanIdentifier{res}

\spanIdentifier{precompiledRegex}\spanPunctuation{(}\spanStringLit{"/d+"}\spanPunctuation{)} \spanComment{\# Replaces the call with a precompiled}
                        \spanComment{\# regex, stored in a global variable}

\spanIdentifier{precompiledRegex}\spanPunctuation{(}\spanIdentifier{paramStr}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{)}\spanPunctuation{)} \spanComment{\# Error, command-line options}
                              \spanComment{\# are not constant expressions}
\end{rstpre}
For the purposes of code generation, all static params are treated as generic params - the proc will be compiled separately for each unique supplied value (or combination of values).

Static params can also appear in the signatures of generic types:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Matrix}\spanPunctuation{\symbol{91}}\spanIdentifier{M}\spanPunctuation{,}\spanIdentifier{N}\spanPunctuation{:} \spanKeyword{static} \spanIdentifier{int}\spanPunctuation{;} \spanIdentifier{T}\spanPunctuation{:} \spanIdentifier{Number}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanFloatNumber{0.}\spanOperator{.}\spanPunctuation{(}\spanIdentifier{M}\spanOperator{*}\spanIdentifier{N} \spanOperator{-} \spanDecNumber{1}\spanPunctuation{)}\spanPunctuation{,} \spanIdentifier{T}\spanPunctuation{\symbol{93}}
    \spanComment{\# Note how \symbol{96}Number\symbol{96} is just a type constraint here, while}
    \spanComment{\# \symbol{96}static int\symbol{96} requires us to supply an int value}
  
  \spanIdentifier{AffineTransform2D}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{Matrix}\spanPunctuation{\symbol{91}}\spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{,} \spanIdentifier{T}\spanPunctuation{\symbol{93}}
  \spanIdentifier{AffineTransform3D}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{Matrix}\spanPunctuation{\symbol{91}}\spanDecNumber{4}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{,} \spanIdentifier{T}\spanPunctuation{\symbol{93}}

\spanKeyword{var} \spanIdentifier{m1}\spanPunctuation{:} \spanIdentifier{AffineTransform3D}\spanPunctuation{\symbol{91}}\spanIdentifier{float}\spanPunctuation{\symbol{93}}  \spanComment{\# OK}
\spanKeyword{var} \spanIdentifier{m2}\spanPunctuation{:} \spanIdentifier{AffineTransform2D}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}} \spanComment{\# Error, \symbol{96}string\symbol{96} is not a \symbol{96}Number\symbol{96}}
\end{rstpre}
Please note that \texttt{static T} is just a syntactic convenience for the underlying generic type \texttt{static\symbol{91}T\symbol{93}}. The type param can be omitted to obtain the type class of all constant expressions. A more specific type class can be created by instantiating \texttt{static} with another type class.

One can force an expression to be evaluated at compile time as a constant expression by coercing it to a corresponding \texttt{static} type:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{math}

\spanIdentifier{echo} \spanKeyword{static}\spanPunctuation{(}\spanIdentifier{fac}\spanPunctuation{(}\spanDecNumber{5}\spanPunctuation{)}\spanPunctuation{)}\spanPunctuation{,} \spanStringLit{" "}\spanPunctuation{,} \spanKeyword{static}\spanPunctuation{\symbol{91}}\spanIdentifier{bool}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanFloatNumber{16.}\spanIdentifier{isPowerOfTwo}\spanPunctuation{)}
\end{rstpre}
The compiler will report any failure to evaluate the expression or a possible type mismatch error.

\rsthB{typedesc\symbol{91}T\symbol{93}}\label{special-types-typedesc-t}
In many contexts, Nim allows to treat the names of types as regular values. These values exists only during the compilation phase, but since all values must have a type, \texttt{typedesc} is considered their special type.

\texttt{typedesc} acts like a generic type. For instance, the type of the symbol \texttt{int} is \texttt{typedesc\symbol{91}int\symbol{93}}. Just like with regular generic types, when the generic param is omitted, \texttt{typedesc} denotes the type class of all types. As a syntactic convenience, one can also use \texttt{typedesc} as a modifier.

Procs featuring \texttt{typedesc} params are considered implicitly generic. They will be instantiated for each unique combination of supplied types and within the body of the proc, the name of each param will refer to the bound concrete type:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{new}\spanPunctuation{(}\spanIdentifier{T}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{ref} \spanIdentifier{T} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"allocating "}\spanPunctuation{,} \spanIdentifier{T}\spanOperator{.}\spanIdentifier{name}
  \spanIdentifier{new}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{)}

\spanKeyword{var} \spanIdentifier{n} \spanOperator{=} \spanIdentifier{Node}\spanOperator{.}\spanIdentifier{new}
\spanKeyword{var} \spanIdentifier{tree} \spanOperator{=} \spanIdentifier{new}\spanPunctuation{(}\spanIdentifier{BinaryTree}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
When multiple type params are present, they will bind freely to different types. To force a bind-once behavior one can use an explicit generic param:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{acceptOnlyTypePairs}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{,} \spanIdentifier{U}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{A}\spanPunctuation{,} \spanIdentifier{B}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{;} \spanIdentifier{C}\spanPunctuation{,} \spanIdentifier{D}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanIdentifier{U}\spanPunctuation{\symbol{93}}\spanPunctuation{)}
\end{rstpre}
Once bound, type params can appear in the rest of the proc signature:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{declareVariableWithType}\spanPunctuation{(}\spanIdentifier{T}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{,} \spanIdentifier{value}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{T} \spanOperator{=} \spanIdentifier{value}

\spanIdentifier{declareVariableWithType} \spanIdentifier{int}\spanPunctuation{,} \spanDecNumber{42}
\end{rstpre}
Overload resolution can be further influenced by constraining the set of types that will match the type param. This works in practice to attaching attributes to types via templates. The constraint can be a concrete type or a type class.

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{maxval}\spanPunctuation{(}\spanIdentifier{T}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanIdentifier{high}\spanPunctuation{(}\spanIdentifier{int}\spanPunctuation{)}
\spanKeyword{template} \spanIdentifier{maxval}\spanPunctuation{(}\spanIdentifier{T}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanIdentifier{float}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{float} \spanOperator{=} \spanIdentifier{Inf}

\spanKeyword{var} \spanIdentifier{i} \spanOperator{=} \spanIdentifier{int}\spanOperator{.}\spanIdentifier{maxval}
\spanKeyword{var} \spanIdentifier{f} \spanOperator{=} \spanIdentifier{float}\spanOperator{.}\spanIdentifier{maxval}
\spanKeyword{when} \spanIdentifier{false}\spanPunctuation{:}
  \spanKeyword{var} \spanIdentifier{s} \spanOperator{=} \spanIdentifier{string}\spanOperator{.}\spanIdentifier{maxval} \spanComment{\# error, maxval is not implemented for string}

\spanKeyword{template} \spanIdentifier{isNumber}\spanPunctuation{(}\spanIdentifier{t}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanKeyword{object}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanStringLit{"Don't think so."}
\spanKeyword{template} \spanIdentifier{isNumber}\spanPunctuation{(}\spanIdentifier{t}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanIdentifier{SomeInteger}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanStringLit{"Yes!"}
\spanKeyword{template} \spanIdentifier{isNumber}\spanPunctuation{(}\spanIdentifier{t}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{\symbol{91}}\spanIdentifier{SomeFloat}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanStringLit{"Maybe, could be NaN."}

\spanIdentifier{echo} \spanStringLit{"is int a number? "}\spanPunctuation{,} \spanIdentifier{isNumber}\spanPunctuation{(}\spanIdentifier{int}\spanPunctuation{)}
\spanIdentifier{echo} \spanStringLit{"is float a number? "}\spanPunctuation{,} \spanIdentifier{isNumber}\spanPunctuation{(}\spanIdentifier{float}\spanPunctuation{)}
\spanIdentifier{echo} \spanStringLit{"is RootObj a number? "}\spanPunctuation{,} \spanIdentifier{isNumber}\spanPunctuation{(}\spanIdentifier{RootObj}\spanPunctuation{)}
\end{rstpre}
Passing \texttt{typedesc} almost identical, just with the differences that the macro is not instantiated generically. The type expression is simply passed as a \texttt{NimNode} to the macro, like everything else.

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{macros}

\spanKeyword{macro} \spanIdentifier{forwardType}\spanPunctuation{(}\spanIdentifier{arg}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{typedesc} \spanOperator{=}
  \spanComment{\# \symbol{96}\symbol{96}arg\symbol{96}\symbol{96} is of type \symbol{96}\symbol{96}NimNode\symbol{96}\symbol{96}}
  \spanKeyword{let} \spanIdentifier{tmp}\spanPunctuation{:} \spanIdentifier{NimNode} \spanOperator{=} \spanIdentifier{arg}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{tmp}

\spanKeyword{var} \spanIdentifier{tmp}\spanPunctuation{:} \spanIdentifier{forwardType}\spanPunctuation{(}\spanIdentifier{int}\spanPunctuation{)}
\end{rstpre}
\rsthB{typeof operator}\label{special-types-typeof-operator}
\textbf{Note}: \texttt{typeof(x)} can for historical reasons also be written as \texttt{type(x)} but \texttt{type(x)} is discouraged.

One can obtain the type of a given expression by constructing a \texttt{typeof} value from it (in many other languages this is known as the typeof\label{typeof_1} operator):

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanDecNumber{0}
\spanKeyword{var} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{typeof}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{)} \spanComment{\# y has type int}
\end{rstpre}
If \texttt{typeof} is used to determine the result type of a proc/iterator/converter call \texttt{c(X)} (where \texttt{X} stands for a possibly empty list of arguments), the interpretation where \texttt{c} is an iterator is preferred over the other interpretations, but this behavior can be changed by passing \texttt{typeOfProc} as the second argument to \texttt{typeof}:

\begin{rstpre}
\spanKeyword{iterator} \spanIdentifier{split}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanKeyword{discard}
\spanKeyword{proc} \spanIdentifier{split}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{discard}

\spanComment{\# since an iterator is the preferred interpretation, \symbol{96}y\symbol{96} has the type \symbol{96}\symbol{96}string\symbol{96}\symbol{96}:}
\spanIdentifier{assert} \spanIdentifier{typeof}\spanPunctuation{(}\spanStringLit{"a b c"}\spanOperator{.}\spanIdentifier{split}\spanPunctuation{)} \spanKeyword{is} \spanIdentifier{string}

\spanIdentifier{assert} \spanIdentifier{typeof}\spanPunctuation{(}\spanStringLit{"a b c"}\spanOperator{.}\spanIdentifier{split}\spanPunctuation{,} \spanIdentifier{typeOfProc}\spanPunctuation{)} \spanKeyword{is} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}
\end{rstpre}
\rsthA{Modules}\label{modules}
Nim supports splitting a program into pieces by a module concept. Each module needs to be in its own file and has its own namespace\label{namespace_1}. Modules enable information hiding\label{information-hiding_1} and separate compilation\label{separate-compilation_1}. A module may gain access to symbols of another module by the import\label{import_1} statement. Recursive module dependencies\label{recursive-module-dependencies_1} are allowed, but slightly subtle. Only top-level symbols that are marked with an asterisk (\texttt{*}) are exported. A valid module name can only be a valid Nim identifier (and thus its filename is \texttt{identifier.nim}).

The algorithm for compiling modules is:

\begin{itemize}\item compile the whole module as usual, following import statements recursively
\item if there is a cycle only import the already parsed symbols (that are exported); if an unknown identifier occurs then abort
\end{itemize}
This is best illustrated by an example:

\begin{rstpre}
\spanComment{\# Module A}
\spanKeyword{type}
  \spanIdentifier{T1}\spanOperator{*} \spanOperator{=} \spanIdentifier{int}  \spanComment{\# Module A exports the type \symbol{96}\symbol{96}T1\symbol{96}\symbol{96}}
\spanKeyword{import} \spanIdentifier{B}     \spanComment{\# the compiler starts parsing B}

\spanKeyword{proc} \spanIdentifier{main}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{i} \spanOperator{=} \spanIdentifier{p}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{)} \spanComment{\# works because B has been parsed completely here}

\spanIdentifier{main}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
\begin{rstpre}
\spanComment{\# Module B}
\spanKeyword{import} \spanIdentifier{A}  \spanComment{\# A is not parsed here! Only the already known symbols}
          \spanComment{\# of A are imported.}

\spanKeyword{proc} \spanIdentifier{p}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{A}\spanOperator{.}\spanIdentifier{T1}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{A}\spanOperator{.}\spanIdentifier{T1} \spanOperator{=}
  \spanComment{\# this works because the compiler has already}
  \spanComment{\# added T1 to A's interface symbol table}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{x} \spanOperator{+} \spanDecNumber{1}
\end{rstpre}
\rsthC{Import statement}\label{modules-import-statement}
After the \texttt{import} statement a list of module names can follow or a single module name followed by an \texttt{except} list to prevent some symbols to be imported:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{strutils} \spanKeyword{except} \spanPunctuation{\symbol{96}}\spanOperator{\%}\spanPunctuation{\symbol{96}}\spanPunctuation{,} \spanIdentifier{toUpperAscii}

\spanComment{\# doesn't work then:}
\spanIdentifier{echo} \spanStringLit{"\$1"} \spanOperator{\%} \spanStringLit{"abc"}\spanOperator{.}\spanIdentifier{toUpperAscii}
\end{rstpre}
It is not checked that the \texttt{except} list is really exported from the module. This feature allows to compile against an older version of the module that does not export these identifiers.

The \texttt{import} statement is only allowed at the top level.

\rsthC{Include statement}\label{modules-include-statement}
The \texttt{include} statement does something fundamentally different than importing a module: it merely includes the contents of a file. The \texttt{include} statement is useful to split up a large module into several files:

\begin{rstpre}
\spanKeyword{include} \spanIdentifier{fileA}\spanPunctuation{,} \spanIdentifier{fileB}\spanPunctuation{,} \spanIdentifier{fileC}
\end{rstpre}
The \texttt{include} statement can be used outside of the top level, as such:

\begin{rstpre}
\spanComment{\# Module A}
\spanIdentifier{echo} \spanStringLit{"Hello World!"}
\end{rstpre}
\begin{rstpre}
\spanComment{\# Module B}
\spanKeyword{proc} \spanIdentifier{main}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{include} \spanIdentifier{A}

\spanIdentifier{main}\spanPunctuation{(}\spanPunctuation{)} \spanComment{\# => Hello World!}
\end{rstpre}
\rsthC{Module names in imports}\label{modules-module-names-in-imports}
A module alias can be introduced via the \texttt{as} keyword:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{strutils} \spanKeyword{as} \spanIdentifier{su}\spanPunctuation{,} \spanIdentifier{sequtils} \spanKeyword{as} \spanIdentifier{qu}

\spanIdentifier{echo} \spanIdentifier{su}\spanOperator{.}\spanIdentifier{format}\spanPunctuation{(}\spanStringLit{"\$1"}\spanPunctuation{,} \spanStringLit{"lalelu"}\spanPunctuation{)}
\end{rstpre}
The original module name is then not accessible. The notations \texttt{path/to/module} or \texttt{"path/to/module"} can be used to refer to a module in subdirectories:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{lib}\spanOperator{/}\spanIdentifier{pure}\spanOperator{/}\spanIdentifier{os}\spanPunctuation{,} \spanStringLit{"lib/pure/times"}
\end{rstpre}
Note that the module name is still \texttt{strutils} and not \texttt{lib/pure/strutils} and so one \textbf{cannot} do:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{lib}\spanOperator{/}\spanIdentifier{pure}\spanOperator{/}\spanIdentifier{strutils}
\spanIdentifier{echo} \spanIdentifier{lib}\spanOperator{/}\spanIdentifier{pure}\spanOperator{/}\spanIdentifier{strutils}\spanOperator{.}\spanIdentifier{toUpperAscii}\spanPunctuation{(}\spanStringLit{"abc"}\spanPunctuation{)}
\end{rstpre}
Likewise the following does not make sense as the name is \texttt{strutils} already:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{lib}\spanOperator{/}\spanIdentifier{pure}\spanOperator{/}\spanIdentifier{strutils} \spanKeyword{as} \spanIdentifier{strutils}
\end{rstpre}
\rsthC{Collective imports from a directory}\label{modules-collective-imports-from-a-directory}
The syntax \texttt{import dir / \symbol{91}moduleA, moduleB\symbol{93}} can be used to import multiple modules from the same directory.

Path names are syntactically either Nim identifiers or string literals. If the path name is not a valid Nim identifier it needs to be a string literal:

\begin{rstpre}
\spanKeyword{import} \spanStringLit{"gfx/3d/somemodule"} \spanComment{\# in quotes because '3d' is not a valid Nim identifier}
\end{rstpre}
\rsthC{Pseudo import/include paths}\label{modules-pseudo-importslashinclude-paths}
A directory can also be a so called "pseudo directory". They can be used to avoid ambiguity when there are multiple modules with the same path.

There are two pseudo directories:

1. \texttt{std}: The \texttt{std} pseudo directory is the abstract location of Nim's standard library. For example, the syntax \texttt{import std / strutils} is used to unambiguously refer to the standard library's \texttt{strutils} module.

2. \texttt{pkg}: The \texttt{pkg} pseudo directory is used to unambiguously refer to a Nimble package. However, for technical details that lie outside of the scope of this document its semantics are: \emph{Use the search path to look for module name but ignore the standard library locations}. In other words, it is the opposite of \texttt{std}.

\rsthC{From import statement}\label{modules-from-import-statement}
After the \texttt{from} statement a module name follows followed by an \texttt{import} to list the symbols one likes to use without explicit full qualification:

\begin{rstpre}
\spanKeyword{from} \spanIdentifier{strutils} \spanKeyword{import} \spanPunctuation{\symbol{96}}\spanOperator{\%}\spanPunctuation{\symbol{96}}

\spanIdentifier{echo} \spanStringLit{"\$1"} \spanOperator{\%} \spanStringLit{"abc"}
\spanComment{\# always possible: full qualification:}
\spanIdentifier{echo} \spanIdentifier{strutils}\spanOperator{.}\spanIdentifier{replace}\spanPunctuation{(}\spanStringLit{"abc"}\spanPunctuation{,} \spanStringLit{"a"}\spanPunctuation{,} \spanStringLit{"z"}\spanPunctuation{)}
\end{rstpre}
It's also possible to use \texttt{from module import nil} if one wants to import the module but wants to enforce fully qualified access to every symbol in \texttt{module}.

\rsthC{Export statement}\label{modules-export-statement}
An \texttt{export} statement can be used for symbol forwarding so that client modules don't need to import a module's dependencies:

\begin{rstpre}
\spanComment{\# module B}
\spanKeyword{type} \spanIdentifier{MyObject}\spanOperator{*} \spanOperator{=} \spanKeyword{object}
\end{rstpre}
\begin{rstpre}
\spanComment{\# module A}
\spanKeyword{import} \spanIdentifier{B}
\spanKeyword{export} \spanIdentifier{B}\spanOperator{.}\spanIdentifier{MyObject}

\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{\$}\spanPunctuation{\symbol{96}}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{MyObject}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanStringLit{"my object"}
\end{rstpre}
\begin{rstpre}
\spanComment{\# module C}
\spanKeyword{import} \spanIdentifier{A}

\spanComment{\# B.MyObject has been imported implicitly here:}
\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{MyObject}
\spanIdentifier{echo} \spanOperator{\$}\spanIdentifier{x}
\end{rstpre}
When the exported symbol is another module, all of its definitions will be forwarded. One can use an \texttt{except} list to exclude some of the symbols.

Notice that when exporting, one needs to specify only the module name:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{foo}\spanOperator{/}\spanIdentifier{bar}\spanOperator{/}\spanIdentifier{baz}
\spanKeyword{export} \spanIdentifier{baz}
\end{rstpre}
\rsthB{Scope rules}\label{modules-scope-rules}
Identifiers are valid from the point of their declaration until the end of the block in which the declaration occurred. The range where the identifier is known is the scope of the identifier. The exact scope of an identifier depends on the way it was declared.

\rsthC{Block scope}\label{scope-rules-block-scope}
The \emph{scope} of a variable declared in the declaration part of a block is valid from the point of declaration until the end of the block. If a block contains a second block, in which the identifier is redeclared, then inside this block, the second declaration will be valid. Upon leaving the inner block, the first declaration is valid again. An identifier cannot be redefined in the same block, except if valid for procedure or iterator overloading purposes.

\rsthC{Tuple or object scope}\label{scope-rules-tuple-or-object-scope}
The field identifiers inside a tuple or object definition are valid in the following places:

\begin{itemize}\item To the end of the tuple/object definition.
\item Field designators of a variable of the given tuple/object type.
\item In all descendant types of the object type.
\end{itemize}
\rsthC{Module scope}\label{scope-rules-module-scope}
All identifiers of a module are valid from the point of declaration until the end of the module. Identifiers from indirectly dependent modules are \emph{not} available. The system\label{system_1} module is automatically imported in every module.

If a module imports an identifier by two different modules, each occurrence of the identifier has to be qualified, unless it is an overloaded procedure or iterator in which case the overloading resolution takes place:

\begin{rstpre}
\spanComment{\# Module A}
\spanKeyword{var} \spanIdentifier{x}\spanOperator{*:} \spanIdentifier{string}
\end{rstpre}
\begin{rstpre}
\spanComment{\# Module B}
\spanKeyword{var} \spanIdentifier{x}\spanOperator{*:} \spanIdentifier{int}
\end{rstpre}
\begin{rstpre}
\spanComment{\# Module C}
\spanKeyword{import} \spanIdentifier{A}\spanPunctuation{,} \spanIdentifier{B}
\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{)} \spanComment{\# error: x is ambiguous}
\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanIdentifier{A}\spanOperator{.}\spanIdentifier{x}\spanPunctuation{)} \spanComment{\# no error: qualifier used}

\spanKeyword{var} \spanIdentifier{x} \spanOperator{=} \spanDecNumber{4}
\spanIdentifier{write}\spanPunctuation{(}\spanIdentifier{stdout}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{)} \spanComment{\# not ambiguous: uses the module C's x}
\end{rstpre}
\rsthA{Compiler Messages}\label{compiler-messages}
The Nim compiler emits different kinds of messages: hint\label{hint_1}, warning\label{warning_1}, and error\label{error_1} messages. An \emph{error} message is emitted if the compiler encounters any static error.

\rsthA{Pragmas}\label{pragmas}
Pragmas are Nim's method to give the compiler additional information / commands without introducing a massive number of new keywords. Pragmas are processed on the fly during semantic checking. Pragmas are enclosed in the special \texttt{\symbol{123}.} and \texttt{.\symbol{125}} curly brackets. Pragmas are also often used as a first implementation to play with a language feature before a nicer syntax to access the feature becomes available.

\rsthB{deprecated pragma}\label{pragmas-deprecated-pragma}
The deprecated pragma is used to mark a symbol as deprecated:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{deprecated}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{var} \spanIdentifier{x} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{deprecated}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{char}
\end{rstpre}
This pragma can also take in an optional warning string to relay to developers.

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{thing}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{bool}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{deprecated}\spanPunctuation{:} \spanStringLit{"use thong instead"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\rsthB{noSideEffect pragma}\label{pragmas-nosideeffect-pragma}
The \texttt{noSideEffect} pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type \texttt{var T} or \texttt{out T} or \texttt{ref T} or \texttt{ptr T} this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.

As a special semantic rule, the built-in \href{system.html\#debugEcho,varargs\symbol{91}typed,\symbol{93}}{debugEcho} pretends to be free of side effects, so that it can be used for debugging routines marked as \texttt{noSideEffect}.

\texttt{func} is syntactic sugar for a proc with no side effects:

\begin{rstpre}
\spanKeyword{func} \spanPunctuation{\symbol{96}}\spanOperator{+}\spanPunctuation{\symbol{96}} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int}
\end{rstpre}
To override the compiler's side effect analysis a \texttt{\symbol{123}.noSideEffect.\symbol{125}} pragma block can be used:

\begin{rstpre}
\spanKeyword{func} \spanIdentifier{f}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{noSideEffect}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
    \spanIdentifier{echo} \spanStringLit{"test"}
\end{rstpre}
\rsthB{compileTime pragma}\label{pragmas-compiletime-pragma}
The \texttt{compileTime} pragma is used to mark a proc or variable to be used only during compile-time execution. No code will be generated for it. Compile-time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses \texttt{system.NimNode} within its parameter types is implicitly declared \texttt{compileTime}:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{astHelper}\spanPunctuation{(}\spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{NimNode}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{NimNode} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{n}
\end{rstpre}
Is the same as:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{astHelper}\spanPunctuation{(}\spanIdentifier{n}\spanPunctuation{:} \spanIdentifier{NimNode}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{NimNode} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{compileTime}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{n}
\end{rstpre}
\texttt{compileTime} variables are available at runtime too. This simplifies certain idioms where variables are filled at compile-time (for example, lookup tables) but accessed at runtime:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{macros}

\spanKeyword{var} \spanIdentifier{nameToProc} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{compileTime}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanPunctuation{(}\spanIdentifier{string}\spanPunctuation{,} \spanKeyword{proc} \spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{nimcall}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{)}\spanPunctuation{\symbol{93}}

\spanKeyword{macro} \spanIdentifier{registerProc}\spanPunctuation{(}\spanIdentifier{p}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{newTree}\spanPunctuation{(}\spanIdentifier{nnkStmtList}\spanPunctuation{,} \spanIdentifier{p}\spanPunctuation{)}
  
  \spanKeyword{let} \spanIdentifier{procName} \spanOperator{=} \spanIdentifier{p}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}
  \spanKeyword{let} \spanIdentifier{procNameAsStr} \spanOperator{=} \spanOperator{\$}\spanIdentifier{p}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}
  \spanIdentifier{result}\spanOperator{.}\spanIdentifier{add} \spanIdentifier{quote} \spanKeyword{do}\spanPunctuation{:}
    \spanIdentifier{nameToProc}\spanOperator{.}\spanIdentifier{add}\spanPunctuation{(}\spanPunctuation{(}\spanPunctuation{\symbol{96}}\spanIdentifier{procNameAsStr}\spanPunctuation{\symbol{96}}\spanPunctuation{,} \spanPunctuation{\symbol{96}}\spanIdentifier{procName}\spanPunctuation{\symbol{96}}\spanPunctuation{)}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{foo}\spanPunctuation{:} \spanIdentifier{string} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{registerProc}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanStringLit{"foo"}
\spanKeyword{proc} \spanIdentifier{bar}\spanPunctuation{:} \spanIdentifier{string} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{registerProc}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanStringLit{"bar"}
\spanKeyword{proc} \spanIdentifier{baz}\spanPunctuation{:} \spanIdentifier{string} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{registerProc}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanStringLit{"baz"}

\spanIdentifier{doAssert} \spanIdentifier{nameToProc}\spanPunctuation{\symbol{91}}\spanDecNumber{2}\spanPunctuation{\symbol{93}}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{==} \spanStringLit{"baz"}
\end{rstpre}
\rsthB{noReturn pragma}\label{pragmas-noreturn-pragma}
The \texttt{noreturn} pragma is used to mark a proc that never returns.

\rsthB{acyclic pragma}\label{pragmas-acyclic-pragma}
The \texttt{acyclic} pragma can be used for object types to mark them as acyclic even though they seem to be cyclic. This is an \textbf{optimization} for the garbage collector to not consider objects of this type as part of a cycle:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Node} \spanOperator{=} \spanKeyword{ref} \spanIdentifier{NodeObj}
  \spanIdentifier{NodeObj} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{acyclic}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{left}\spanPunctuation{,} \spanIdentifier{right}\spanPunctuation{:} \spanIdentifier{Node}
    \spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{string}
\end{rstpre}
Or if we directly use a ref object:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Node} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{acyclic}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{ref} \spanKeyword{object}
    \spanIdentifier{left}\spanPunctuation{,} \spanIdentifier{right}\spanPunctuation{:} \spanIdentifier{Node}
    \spanIdentifier{data}\spanPunctuation{:} \spanIdentifier{string}
\end{rstpre}
In the example a tree structure is declared with the \texttt{Node} type. Note that the type definition is recursive and the GC has to assume that objects of this type may form a cyclic graph. The \texttt{acyclic} pragma passes the information that this cannot happen to the GC. If the programmer uses the \texttt{acyclic} pragma for data types that are in reality cyclic, the memory leaks can be the result, but memory safety is preserved.

\rsthB{final pragma}\label{pragmas-final-pragma}
The \texttt{final} pragma can be used for an object type to specify that it cannot be inherited from. Note that inheritance is only available for objects that inherit from an existing object (via the \texttt{object of SuperType} syntax) or that have been marked as \texttt{inheritable}.

\rsthB{shallow pragma}\label{pragmas-shallow-pragma}
The \texttt{shallow} pragma affects the semantics of a type: The compiler is allowed to make a shallow copy. This can cause serious semantic issues and break memory safety! However, it can speed up assignments considerably, because the semantics of Nim require deep copying of sequences and strings. This can be expensive, especially if sequences are used to build a tree structure:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{NodeKind} \spanOperator{=} \spanKeyword{enum} \spanIdentifier{nkLeaf}\spanPunctuation{,} \spanIdentifier{nkInner}
  \spanIdentifier{Node} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{shallow}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object}
    \spanKeyword{case} \spanIdentifier{kind}\spanPunctuation{:} \spanIdentifier{NodeKind}
    \spanKeyword{of} \spanIdentifier{nkLeaf}\spanPunctuation{:}
      \spanIdentifier{strVal}\spanPunctuation{:} \spanIdentifier{string}
    \spanKeyword{of} \spanIdentifier{nkInner}\spanPunctuation{:}
      \spanIdentifier{children}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{Node}\spanPunctuation{\symbol{93}}
\end{rstpre}
\rsthB{pure pragma}\label{pragmas-pure-pragma}
An object type can be marked with the \texttt{pure} pragma so that its type field which is used for runtime type identification is omitted. This used to be necessary for binary compatibility with other compiled languages.

An enum type can be marked as \texttt{pure}. Then access of its fields always requires full qualification.

\rsthB{asmNoStackFrame pragma}\label{pragmas-asmnostackframe-pragma}
A proc can be marked with the \texttt{asmNoStackFrame} pragma to tell the compiler it should not generate a stack frame for the proc. There are also no exit statements like \texttt{return result;} generated and the generated C function is declared as \texttt{\_\_declspec(naked)} or \texttt{\_\_attribute\_\_((naked))} (depending on the used C compiler).

\textbf{Note}: This pragma should only be used by procs which consist solely of assembler statements.

\rsthB{error pragma}\label{pragmas-error-pragma}
The \texttt{error} pragma is used to make the compiler output an error message with the given content. Compilation does not necessarily abort after an error though.

The \texttt{error} pragma can also be used to annotate a symbol (like an iterator or proc). The \emph{usage} of the symbol then triggers a static error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:

\begin{rstpre}
\spanComment{\#\# check that underlying int values are compared and not the pointers:}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanOperator{==}\spanPunctuation{\symbol{96}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanKeyword{ptr} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{error}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\rsthB{fatal pragma}\label{pragmas-fatal-pragma}
The \texttt{fatal} pragma is used to make the compiler output an error message with the given content. In contrast to the \texttt{error} pragma, compilation is guaranteed to be aborted by this pragma. Example:

\begin{rstpre}
\spanKeyword{when} \spanKeyword{not} \spanIdentifier{defined}\spanPunctuation{(}\spanIdentifier{objc}\spanPunctuation{)}\spanPunctuation{:}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{fatal}\spanPunctuation{:} \spanStringLit{"Compile this program with the objc command!"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\rsthB{warning pragma}\label{pragmas-warning-pragma}
The \texttt{warning} pragma is used to make the compiler output a warning message with the given content. Compilation continues after the warning.

\rsthB{hint pragma}\label{pragmas-hint-pragma}
The \texttt{hint} pragma is used to make the compiler output a hint message with the given content. Compilation continues after the hint.

\rsthB{line pragma}\label{pragmas-line-pragma}
The \texttt{line} pragma can be used to affect line information of the annotated statement as seen in stack backtraces:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{myassert}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{cond}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{,} \spanIdentifier{msg} \spanOperator{=} \spanStringLit{""}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{if} \spanKeyword{not} \spanIdentifier{cond}\spanPunctuation{:}
    \spanComment{\# change run-time line information of the 'raise' statement:}
    \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{line}\spanPunctuation{:} \spanIdentifier{instantiationInfo}\spanPunctuation{(}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
      \spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{EAssertionFailed}\spanPunctuation{,} \spanIdentifier{msg}\spanPunctuation{)}
\end{rstpre}
If the \texttt{line} pragma is used with a parameter, the parameter needs be a \texttt{tuple\symbol{91}filename: string, line: int\symbol{93}}. If it is used without a parameter, \texttt{system.InstantiationInfo()} is used.

\rsthB{linearScanEnd pragma}\label{pragmas-linearscanend-pragma}
The \texttt{linearScanEnd} pragma can be used to tell the compiler how to compile a Nim case\label{case_1} statement. Syntactically it has to be used as a statement:

\begin{rstpre}
\spanKeyword{case} \spanIdentifier{myInt}
\spanKeyword{of} \spanDecNumber{0}\spanPunctuation{:}
  \spanIdentifier{echo} \spanStringLit{"most common case"}
\spanKeyword{of} \spanDecNumber{1}\spanPunctuation{:}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{linearScanEnd}\spanOperator{.}\spanPunctuation{\symbol{125}}
  \spanIdentifier{echo} \spanStringLit{"second most common case"}
\spanKeyword{of} \spanDecNumber{2}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"unlikely: use branch table"}
\spanKeyword{else}\spanPunctuation{:} \spanIdentifier{echo} \spanStringLit{"unlikely too: use branch table for "}\spanPunctuation{,} \spanIdentifier{myInt}
\end{rstpre}
In the example, the case branches \texttt{0} and \texttt{1} are much more common than the other cases. Therefore the generated assembler code should test for these values first, so that the CPU's branch predictor has a good chance to succeed (avoiding an expensive CPU pipeline stall). The other cases might be put into a jump table for O(1) overhead, but at the cost of a (very likely) pipeline stall.

The \texttt{linearScanEnd} pragma should be put into the last branch that should be tested against via linear scanning. If put into the last branch of the whole \texttt{case} statement, the whole \texttt{case} statement uses linear scanning.

\rsthB{computedGoto pragma}\label{pragmas-computedgoto-pragma}
The \texttt{computedGoto} pragma can be used to tell the compiler how to compile a Nim case\label{case_2} in a \texttt{while true} statement. Syntactically it has to be used as a statement inside the loop:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{MyEnum} \spanOperator{=} \spanKeyword{enum}
    \spanIdentifier{enumA}\spanPunctuation{,} \spanIdentifier{enumB}\spanPunctuation{,} \spanIdentifier{enumC}\spanPunctuation{,} \spanIdentifier{enumD}\spanPunctuation{,} \spanIdentifier{enumE}

\spanKeyword{proc} \spanIdentifier{vm}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{instructions}\spanPunctuation{:} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{100}\spanPunctuation{,} \spanIdentifier{MyEnum}\spanPunctuation{\symbol{93}}
  \spanIdentifier{instructions}\spanPunctuation{\symbol{91}}\spanDecNumber{2}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{enumC}
  \spanIdentifier{instructions}\spanPunctuation{\symbol{91}}\spanDecNumber{3}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{enumD}
  \spanIdentifier{instructions}\spanPunctuation{\symbol{91}}\spanDecNumber{4}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{enumA}
  \spanIdentifier{instructions}\spanPunctuation{\symbol{91}}\spanDecNumber{5}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{enumD}
  \spanIdentifier{instructions}\spanPunctuation{\symbol{91}}\spanDecNumber{6}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{enumC}
  \spanIdentifier{instructions}\spanPunctuation{\symbol{91}}\spanDecNumber{7}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{enumA}
  \spanIdentifier{instructions}\spanPunctuation{\symbol{91}}\spanDecNumber{8}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{enumB}
  
  \spanIdentifier{instructions}\spanPunctuation{\symbol{91}}\spanDecNumber{12}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanIdentifier{enumE}
  \spanKeyword{var} \spanIdentifier{pc} \spanOperator{=} \spanDecNumber{0}
  \spanKeyword{while} \spanIdentifier{true}\spanPunctuation{:}
    \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{computedGoto}\spanOperator{.}\spanPunctuation{\symbol{125}}
    \spanKeyword{let} \spanIdentifier{instr} \spanOperator{=} \spanIdentifier{instructions}\spanPunctuation{\symbol{91}}\spanIdentifier{pc}\spanPunctuation{\symbol{93}}
    \spanKeyword{case} \spanIdentifier{instr}
    \spanKeyword{of} \spanIdentifier{enumA}\spanPunctuation{:}
      \spanIdentifier{echo} \spanStringLit{"yeah A"}
    \spanKeyword{of} \spanIdentifier{enumC}\spanPunctuation{,} \spanIdentifier{enumD}\spanPunctuation{:}
      \spanIdentifier{echo} \spanStringLit{"yeah CD"}
    \spanKeyword{of} \spanIdentifier{enumB}\spanPunctuation{:}
      \spanIdentifier{echo} \spanStringLit{"yeah B"}
    \spanKeyword{of} \spanIdentifier{enumE}\spanPunctuation{:}
      \spanKeyword{break}
    \spanIdentifier{inc}\spanPunctuation{(}\spanIdentifier{pc}\spanPunctuation{)}

\spanIdentifier{vm}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
As the example shows \texttt{computedGoto} is mostly useful for interpreters. If the underlying backend (C compiler) does not support the computed goto extension the pragma is simply ignored.

\rsthB{immediate pragma}\label{pragmas-immediate-pragma}
The immediate pragma is obsolete. See \href{\#templates-typed-vs-untyped-parameters}{Typed vs untyped parameters}.

\rsthB{compilation option pragmas}\label{pragmas-compilation-option-pragmas}
The listed pragmas here can be used to override the code generation options for a proc/method/converter.

The implementation currently provides the following possible options (various others may be added later).

\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|X|X|X|X|}
\hline
\textbf{pragma} & \textbf{allowed values} & \textbf{description}\\
\hline
checks & on|off  & Turns the code generation for all runtime checks on or off.\\
\hline
boundChecks & on|off  & Turns the code generation for array bound checks on or off.\\
\hline
overflowChecks & on|off  & Turns the code generation for over- or underflow checks on or off.\\
\hline
nilChecks & on|off  & Turns the code generation for nil pointer checks on or off.\\
\hline
assertions & on|off  & Turns the code generation for assertions on or off.\\
\hline
warnings & on|off  & Turns the warning messages of the compiler on or off.\\
\hline
hints & on|off  & Turns the hint messages of the compiler on or off.\\
\hline
optimization & none2size  & Optimize the code for speed or size, or disable optimization.\\
\hline
patterns & on|off  & Turns the term rewriting templates/macros on or off.\\
\hline
callconv & cdecl|... & Specifies the default calling convention for all procedures (and procedure types) that follow.\\
\hline
\end{rsttab}\end{table}Example:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{checks}\spanPunctuation{:} \spanIdentifier{off}\spanPunctuation{,} \spanIdentifier{optimization}\spanPunctuation{:} \spanIdentifier{speed}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanComment{\# compile without runtime checks and optimize for speed}
\end{rstpre}
\rsthB{push and pop pragmas}\label{pragmas-push-and-pop-pragmas}
The push/pop\label{pushslashpop_1} pragmas are very similar to the option directive, but are used to override the settings temporarily. Example:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{push} \spanIdentifier{checks}\spanPunctuation{:} \spanIdentifier{off}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanComment{\# compile this section without runtime checks as it is}
\spanComment{\# speed critical}
\spanComment{\# ... some code ...}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pop}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanComment{\# restore old settings}
\end{rstpre}
push/pop\label{pushslashpop_2} can switch on/off some standard library pragmas, example:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{push} \spanIdentifier{inline}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanIdentifier{thisIsInlined}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanDecNumber{42}
\spanKeyword{func} \spanIdentifier{willBeInlined}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{float} \spanOperator{=} \spanFloatNumber{42.0}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pop}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanIdentifier{notInlined}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanDecNumber{9}

\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{push} \spanIdentifier{discardable}\spanPunctuation{,} \spanIdentifier{boundChecks}\spanPunctuation{:} \spanIdentifier{off}\spanPunctuation{,} \spanIdentifier{compileTime}\spanPunctuation{,} \spanIdentifier{noSideEffect}\spanPunctuation{,} \spanIdentifier{experimental}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{template} \spanIdentifier{example}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanStringLit{"https://nim-lang.org"}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pop}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{push} \spanIdentifier{deprecated}\spanPunctuation{,} \spanIdentifier{hint}\spanPunctuation{\symbol{91}}\spanIdentifier{LineTooLong}\spanPunctuation{\symbol{93}}\spanPunctuation{:} \spanIdentifier{off}\spanPunctuation{,} \spanIdentifier{used}\spanPunctuation{,} \spanIdentifier{stackTrace}\spanPunctuation{:} \spanIdentifier{off}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanIdentifier{sample}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=} \spanIdentifier{true}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pop}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
For third party pragmas it depends on its implementation, but uses the same syntax.

\rsthB{register pragma}\label{pragmas-register-pragma}
The \texttt{register} pragma is for variables only. It declares the variable as \texttt{register}, giving the compiler a hint that the variable should be placed in a hardware register for faster access. C compilers usually ignore this though and for good reasons: Often they do a better job without it anyway.

In highly specific cases (a dispatch loop of a bytecode interpreter for example) it may provide benefits, though.

\rsthB{global pragma}\label{pragmas-global-pragma}
The \texttt{global} pragma can be applied to a variable within a proc to instruct the compiler to store it in a global location and initialize it once at program startup.

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{isHexNumber}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{pattern} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{global}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanRawData{re"\symbol{91}0-9a-fA-F\symbol{93}+"}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{s}\spanOperator{.}\spanIdentifier{match}\spanPunctuation{(}\spanIdentifier{pattern}\spanPunctuation{)}
\end{rstpre}
When used within a generic proc, a separate unique global variable will be created for each instantiation of the proc. The order of initialization of the created global variables within a module is not defined, but all of them will be initialized after any top-level variables in their originating module and before any variable in a module that imports it.

\rsthB{Disabling certain messages}\label{pragmas-disabling-certain-messages}
Nim generates some warnings and hints ("line too long") that may annoy the user. A mechanism for disabling certain messages is provided: Each hint and warning message contains a symbol in brackets. This is the message's identifier that can be used to enable or disable it:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{hint}\spanPunctuation{\symbol{91}}\spanIdentifier{LineTooLong}\spanPunctuation{\symbol{93}}\spanPunctuation{:} \spanIdentifier{off}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanComment{\# turn off the hint about too long lines}
\end{rstpre}
This is often better than disabling all warnings at once.

\rsthB{used pragma}\label{pragmas-used-pragma}
Nim produces a warning for symbols that are not exported and not used either. The \texttt{used} pragma can be attached to a symbol to suppress this warning. This is particularly useful when the symbol was generated by a macro:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{implementArithOps}\spanPunctuation{(}\spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{proc} \spanIdentifier{echoAdd}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{used}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
    \spanIdentifier{echo} \spanIdentifier{a} \spanOperator{+} \spanIdentifier{b}
  \spanKeyword{proc} \spanIdentifier{echoSub}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{used}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
    \spanIdentifier{echo} \spanIdentifier{a} \spanOperator{-} \spanIdentifier{b}

\spanComment{\# no warning produced for the unused 'echoSub'}
\spanIdentifier{implementArithOps}\spanPunctuation{(}\spanIdentifier{int}\spanPunctuation{)}
\spanIdentifier{echoAdd} \spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{5}
\end{rstpre}
\texttt{used} can also be used as a top level statement to mark a module as "used". This prevents the "Unused import" warning:

\begin{rstpre}
\spanComment{\# module: debughelper.nim}
\spanKeyword{when} \spanIdentifier{defined}\spanPunctuation{(}\spanIdentifier{nimHasUsed}\spanPunctuation{)}\spanPunctuation{:}
  \spanComment{\# 'import debughelper' is so useful for debugging}
  \spanComment{\# that Nim shouldn't produce a warning for that import,}
  \spanComment{\# even if currently unused:}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{used}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\rsthB{experimental pragma}\label{pragmas-experimental-pragma}
The \texttt{experimental} pragma enables experimental language features. Depending on the concrete feature this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed any time).

Example:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{threadpool}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{experimental}\spanPunctuation{:} \spanStringLit{"parallel"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{proc} \spanIdentifier{threadedEcho}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{i}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{,} \spanStringLit{" "}\spanPunctuation{,} \spanOperator{\$}\spanIdentifier{i}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{useParallel}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{parallel}\spanPunctuation{:}
    \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{4}\spanPunctuation{:}
      \spanIdentifier{spawn} \spanIdentifier{threadedEcho}\spanPunctuation{(}\spanStringLit{"echo in parallel"}\spanPunctuation{,} \spanIdentifier{i}\spanPunctuation{)}

\spanIdentifier{useParallel}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
As a top level statement, the experimental pragma enables a feature for the rest of the module it's enabled in. This is problematic for macro and generic instantiations that cross a module scope. Currently these usages have to be put into a \texttt{.push/pop} environment:

\begin{rstpre}
\spanComment{\# client.nim}
\spanKeyword{proc} \spanIdentifier{useParallel}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{unused}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\# use a generic T here to show the problem.}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{push} \spanIdentifier{experimental}\spanPunctuation{:} \spanStringLit{"parallel"}\spanOperator{.}\spanPunctuation{\symbol{125}}
  \spanIdentifier{parallel}\spanPunctuation{:}
    \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanFloatNumber{0.}\spanOperator{.}\spanDecNumber{4}\spanPunctuation{:}
      \spanIdentifier{echo} \spanStringLit{"echo in parallel"}
  
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pop}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\begin{rstpre}
\spanKeyword{import} \spanIdentifier{client}
\spanIdentifier{useParallel}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{)}
\end{rstpre}
\rsthA{Implementation Specific Pragmas}\label{implementation-specific-pragmas}
This section describes additional pragmas that the current Nim implementation supports but which should not be seen as part of the language specification.

\rsthB{Bitsize pragma}\label{implementation-specific-pragmas-bitsize-pragma}
The \texttt{bitsize} pragma is for object field members. It declares the field as a bitfield in C/C++.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{mybitfield} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{flag} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{bitsize}\spanPunctuation{:}\spanFloatNumber{1.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{cuint}
\end{rstpre}
generates:

\begin{rstpre}
\spanKeyword{struct} \spanIdentifier{mybitfield} \spanPunctuation{\symbol{123}}
  \spanKeyword{unsigned} \spanKeyword{int} \spanIdentifier{flag}\spanPunctuation{:}\spanDecNumber{1}\spanPunctuation{;}
\spanPunctuation{\symbol{125}}\spanPunctuation{;}
\end{rstpre}
\rsthB{Align pragma}\label{implementation-specific-pragmas-align-pragma}
The align\label{align_1} pragma is for variables and object field members. It modifies the alignment requirement of the entity being declared. The argument must be a constant power of 2. Valid non-zero alignments that are weaker than other align pragmas on the same declaration are ignored. Alignments that are weaker that the alignment requirement of the type are ignored.

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{sseType} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{sseData} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{align}\spanPunctuation{(}\spanDecNumber{16}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanDecNumber{4}\spanPunctuation{,} \spanIdentifier{float32}\spanPunctuation{\symbol{93}}
  
  \spanComment{\# every object will be aligned to 128-byte boundary}
  \spanIdentifier{Data} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{char}
    \spanIdentifier{cacheline} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{align}\spanPunctuation{(}\spanDecNumber{128}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{array}\spanPunctuation{\symbol{91}}\spanDecNumber{128}\spanPunctuation{,} \spanIdentifier{char}\spanPunctuation{\symbol{93}} \spanComment{\# over-aligned array of char,}

\spanKeyword{proc} \spanIdentifier{main}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"sizeof(Data) = "}\spanPunctuation{,} \spanIdentifier{sizeof}\spanPunctuation{(}\spanIdentifier{Data}\spanPunctuation{)}\spanPunctuation{,} \spanStringLit{" (1 byte + 127 bytes padding + 128-byte array)"}
  \spanComment{\# output: sizeof(Data) = 256 (1 byte + 127 bytes padding + 128-byte array)}
  \spanIdentifier{echo} \spanStringLit{"alignment of sseType is "}\spanPunctuation{,} \spanIdentifier{alignof}\spanPunctuation{(}\spanIdentifier{sseType}\spanPunctuation{)}
  \spanComment{\# output: alignment of sseType is 16}
  \spanKeyword{var} \spanIdentifier{d} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{align}\spanPunctuation{(}\spanDecNumber{2048}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{Data} \spanComment{\# this instance of data is aligned even stricter}

\spanIdentifier{main}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
This pragma has no effect for the JS backend.

\rsthB{Volatile pragma}\label{implementation-specific-pragmas-volatile-pragma}
The \texttt{volatile} pragma is for variables only. It declares the variable as \texttt{volatile}, whatever that means in C/C++ (its semantics are not well defined in C/C++).

\textbf{Note}: This pragma will not exist for the LLVM backend.

\rsthB{NoDecl pragma}\label{implementation-specific-pragmas-nodecl-pragma}
The \texttt{noDecl} pragma can be applied to almost any symbol (variable, proc, type, etc.) and is sometimes useful for interoperability with C: It tells Nim that it should not generate a declaration for the symbol in the C code. For example:

\begin{rstpre}
\spanKeyword{var}
  \spanIdentifier{EACCES} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importc}\spanPunctuation{,} \spanIdentifier{noDecl}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{cint} \spanComment{\# pretend EACCES was a variable, as}
                                   \spanComment{\# Nim does not know its value}
\end{rstpre}
However, the \texttt{header} pragma is often the better alternative.

\textbf{Note}: This will not work for the LLVM backend.

\rsthB{Header pragma}\label{implementation-specific-pragmas-header-pragma}
The \texttt{header} pragma is very similar to the \texttt{noDecl} pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead the generated code should contain an \texttt{\#include}:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{PFile} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importc}\spanPunctuation{:} \spanStringLit{"FILE*"}\spanPunctuation{,} \spanIdentifier{header}\spanPunctuation{:} \spanStringLit{"<stdio.h>"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{distinct} \spanIdentifier{pointer}
    \spanComment{\# import C's FILE* type; Nim will treat it as a new pointer type}
\end{rstpre}
The \texttt{header} pragma always expects a string constant. The string constant contains the header file: As usual for C, a system header file is enclosed in angle brackets: \texttt{<>}. If no angle brackets are given, Nim encloses the header file in \texttt{""} in the generated C code.

\textbf{Note}: This will not work for the LLVM backend.

\rsthB{IncompleteStruct pragma}\label{implementation-specific-pragmas-incompletestruct-pragma}
The \texttt{incompleteStruct} pragma tells the compiler to not use the underlying C \texttt{struct} in a \texttt{sizeof} expression:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{DIR}\spanOperator{*} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importc}\spanPunctuation{:} \spanStringLit{"DIR"}\spanPunctuation{,} \spanIdentifier{header}\spanPunctuation{:} \spanStringLit{"<dirent.h>"}\spanPunctuation{,}
         \spanIdentifier{pure}\spanPunctuation{,} \spanIdentifier{incompleteStruct}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object}
\end{rstpre}
\rsthB{Compile pragma}\label{implementation-specific-pragmas-compile-pragma}
The \texttt{compile} pragma can be used to compile and link a C/C++ source file with the project:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{compile}\spanPunctuation{:} \spanStringLit{"myfile.cpp"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\textbf{Note}: Nim computes a SHA1 checksum and only recompiles the file if it has changed. One can use the \texttt{-f} command line option to force recompilation of the file.

\rsthB{Link pragma}\label{implementation-specific-pragmas-link-pragma}
The \texttt{link} pragma can be used to link an additional file with the project:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{link}\spanPunctuation{:} \spanStringLit{"myfile.o"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\rsthB{PassC pragma}\label{implementation-specific-pragmas-passc-pragma}
The \texttt{passc} pragma can be used to pass additional parameters to the C compiler like one would using the commandline switch \texttt{--passc}:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{passc}\spanPunctuation{:} \spanStringLit{"-Wall -Werror"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
Note that one can use \texttt{gorge} from the \href{system.html}{system module} to embed parameters from an external command that will be executed during semantic analysis:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{passc}\spanPunctuation{:} \spanIdentifier{gorge}\spanPunctuation{(}\spanStringLit{"pkg-config --cflags sdl"}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\rsthB{LocalPassc pragma}\label{implementation-specific-pragmas-localpassc-pragma}
The \texttt{localPassc} pragma can be used to pass additional parameters to the C compiler, but only for the C/C++ file that is produced from the Nim module the pragma resides in:

\begin{rstpre}
\spanComment{\# Module A.nim}
\spanComment{\# Produces: A.nim.cpp}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{localPassc}\spanPunctuation{:} \spanStringLit{"-Wall -Werror"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanComment{\# Passed when compiling A.nim.cpp}
\end{rstpre}
\rsthB{PassL pragma}\label{implementation-specific-pragmas-passl-pragma}
The \texttt{passL} pragma can be used to pass additional parameters to the linker like one would using the commandline switch \texttt{--passL}:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{passL}\spanPunctuation{:} \spanStringLit{"-lSDLmain -lSDL"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
Note that one can use \texttt{gorge} from the \href{system.html}{system module} to embed parameters from an external command that will be executed during semantic analysis:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{passL}\spanPunctuation{:} \spanIdentifier{gorge}\spanPunctuation{(}\spanStringLit{"pkg-config --libs sdl"}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\rsthB{Emit pragma}\label{implementation-specific-pragmas-emit-pragma}
The \texttt{emit} pragma can be used to directly affect the output of the compiler's code generator. The code is then unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with C++\label{cplusplus_1} or Objective C\label{objective-c_1} code.

Example:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{emit}\spanPunctuation{:} \spanLongStringLit{"""
static int cvariable = 420;
"""}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{push} \spanIdentifier{stackTrace}\spanPunctuation{:}\spanIdentifier{off}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanIdentifier{embedsC}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{nimVar} \spanOperator{=} \spanDecNumber{89}
  \spanComment{\# access Nim symbols within an emit section outside of string literals:}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{emit}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanLongStringLit{"""fprintf(stdout, "\%d\symbol{92}n", cvariable + (int)"""}\spanPunctuation{,} \spanIdentifier{nimVar}\spanPunctuation{,} \spanStringLit{");"}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pop}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanIdentifier{embedsC}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
\texttt{nimbase.h} defines \texttt{NIM\_EXTERNC} C macro that can be used for \texttt{extern "C"} code to work with both \texttt{nim c} and \texttt{nim cpp}, eg:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{foobar}\spanPunctuation{(}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importc}\spanPunctuation{:}\spanStringLit{"\$1"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{emit}\spanPunctuation{:} \spanLongStringLit{"""
\#include <stdio.h>
NIM\_EXTERNC
void fun()\symbol{123}\symbol{125}
"""}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
For backwards compatibility, if the argument to the \texttt{emit} statement is a single string literal, Nim symbols can be referred to via backticks. This usage is however deprecated.

For a toplevel emit statement the section where in the generated C/C++ file the code should be emitted can be influenced via the prefixes \texttt{/*TYPESECTION*/} or \texttt{/*VARSECTION*/} or \texttt{/*INCLUDESECTION*/}:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{emit}\spanPunctuation{:} \spanLongStringLit{"""/*TYPESECTION*/
struct Vector3 \symbol{123}
public:
  Vector3(): x(5) \symbol{123}\symbol{125}
  Vector3(float x\_): x(x\_) \symbol{123}\symbol{125}
  float x;
\symbol{125};
"""}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{type} \spanIdentifier{Vector3} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"Vector3"}\spanPunctuation{,} \spanIdentifier{nodecl}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object}
  \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{cfloat}

\spanKeyword{proc} \spanIdentifier{constructVector3}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{cfloat}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Vector3} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"Vector3(\symbol{64})"}\spanPunctuation{,} \spanIdentifier{nodecl}\spanPunctuation{\symbol{125}}
\end{rstpre}
\rsthB{ImportCpp pragma}\label{implementation-specific-pragmas-importcpp-pragma}
\textbf{Note}: \href{https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst}{c2nim} can parse a large subset of C++ and knows about the \texttt{importcpp} pragma pattern language. It is not necessary to know all the details described here.

Similar to the \href{\#foreign-function-interface-importc-pragma}{importc pragma for C}, the \texttt{importcpp} pragma can be used to import C++\label{cplusplus_2} methods or C++ symbols in general. The generated code then uses the C++ method calling syntax: \texttt{obj->method(arg)}.  In combination with the \texttt{header} and \texttt{emit} pragmas this allows \emph{sloppy} interfacing with libraries written in C++:

\begin{rstpre}
\spanComment{\# Horrible example of how to interface with a C++ engine ... ;-)}

\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{link}\spanPunctuation{:} \spanStringLit{"/usr/lib/libIrrlicht.so"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{emit}\spanPunctuation{:} \spanLongStringLit{"""
using namespace irr;
using namespace core;
using namespace scene;
using namespace video;
using namespace io;
using namespace gui;
"""}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{const}
  \spanIdentifier{irr} \spanOperator{=} \spanStringLit{"<irrlicht/irrlicht.h>"}

\spanKeyword{type}
  \spanIdentifier{IrrlichtDeviceObj} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{header}\spanPunctuation{:} \spanIdentifier{irr}\spanPunctuation{,}
                      \spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"IrrlichtDevice"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object}
  \spanIdentifier{IrrlichtDevice} \spanOperator{=} \spanKeyword{ptr} \spanIdentifier{IrrlichtDeviceObj}

\spanKeyword{proc} \spanIdentifier{createDevice}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{IrrlichtDevice} \spanPunctuation{\symbol{123}}\spanOperator{.}
  \spanIdentifier{header}\spanPunctuation{:} \spanIdentifier{irr}\spanPunctuation{,} \spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"createDevice(\symbol{64})"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanIdentifier{run}\spanPunctuation{(}\spanIdentifier{device}\spanPunctuation{:} \spanIdentifier{IrrlichtDevice}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{bool} \spanPunctuation{\symbol{123}}\spanOperator{.}
  \spanIdentifier{header}\spanPunctuation{:} \spanIdentifier{irr}\spanPunctuation{,} \spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"\#.run(\symbol{64})"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
The compiler needs to be told to generate C++ (command \texttt{cpp}) for this to work. The conditional symbol \texttt{cpp} is defined when the compiler emits C++ code.

\rsthC{Namespaces}\label{importcpp-pragma-namespaces}
The \emph{sloppy interfacing} example uses \texttt{.emit} to produce \texttt{using namespace} declarations. It is usually much better to instead refer to the imported name via the \texttt{namespace::identifier} notation:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{IrrlichtDeviceObj} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{header}\spanPunctuation{:} \spanIdentifier{irr}\spanPunctuation{,}
                      \spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"irr::IrrlichtDevice"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object}
\end{rstpre}
\rsthC{Importcpp for enums}\label{importcpp-pragma-importcpp-for-enums}
When \texttt{importcpp} is applied to an enum type the numerical enum values are annotated with the C++ enum type, like in this example: \texttt{((TheCppEnum)(3))}. (This turned out to be the simplest way to implement it.)

\rsthC{Importcpp for procs}\label{importcpp-pragma-importcpp-for-procs}
Note that the \texttt{importcpp} variant for procs uses a somewhat cryptic pattern language for maximum flexibility:

\begin{itemize}\item A hash \texttt{\#} symbol is replaced by the first or next argument.
\item A dot following the hash \texttt{\#.} indicates that the call should use C++'s dot or arrow notation.
\item An at symbol \texttt{\symbol{64}} is replaced by the remaining arguments, separated by commas.
\end{itemize}
For example:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{cppMethod}\spanPunctuation{(}\spanIdentifier{this}\spanPunctuation{:} \spanIdentifier{CppObj}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{,} \spanIdentifier{c}\spanPunctuation{:} \spanIdentifier{cint}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"\#.CppMethod(\symbol{64})"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanKeyword{ptr} \spanIdentifier{CppObj}
\spanIdentifier{cppMethod}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{)}
\end{rstpre}
Produces:

\begin{rstpre}
\spanIdentifier{x}\spanOperator{->}\spanIdentifier{CppMethod}\spanPunctuation{(}\spanDecNumber{1}\spanPunctuation{,} \spanDecNumber{2}\spanPunctuation{,} \spanDecNumber{3}\spanPunctuation{)}
\end{rstpre}
As a special rule to keep backwards compatibility with older versions of the \texttt{importcpp} pragma, if there is no special pattern character (any of \texttt{\# ' \symbol{64}}) at all, C++'s dot or arrow notation is assumed, so the above example can also be written as:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{cppMethod}\spanPunctuation{(}\spanIdentifier{this}\spanPunctuation{:} \spanIdentifier{CppObj}\spanPunctuation{,} \spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{,} \spanIdentifier{c}\spanPunctuation{:} \spanIdentifier{cint}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"CppMethod"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
Note that the pattern language naturally also covers C++'s operator overloading capabilities:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{vectorAddition}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{Vec3}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Vec3} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"\# + \#"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanIdentifier{dictLookup}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{Dict}\spanPunctuation{,} \spanIdentifier{k}\spanPunctuation{:} \spanIdentifier{Key}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Value} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"\#\symbol{91}\#\symbol{93}"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\begin{itemize}\item An apostrophe \texttt{'} followed by an integer \texttt{i} in the range 0..9 is replaced by the i'th parameter \emph{type}. The 0th position is the result type. This can be used to pass types to C++ function templates. Between the \texttt{'} and the digit an asterisk can be used to get to the base type of the type. (So it "takes away a star" from the type; \texttt{T*} becomes \texttt{T}.) Two stars can be used to get to the element type of the element type etc.
\end{itemize}
For example:

\begin{rstpre}
\spanKeyword{type} \spanIdentifier{Input} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"System::Input"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object}
\spanKeyword{proc} \spanIdentifier{getSubsystem}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{ptr} \spanIdentifier{T} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"SystemManager::getSubsystem<'*0>()"}\spanPunctuation{,} \spanIdentifier{nodecl}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{let} \spanIdentifier{x}\spanPunctuation{:} \spanKeyword{ptr} \spanIdentifier{Input} \spanOperator{=} \spanIdentifier{getSubsystem}\spanPunctuation{\symbol{91}}\spanIdentifier{Input}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
Produces:

\begin{rstpre}
\spanIdentifier{x} \spanOperator{=} \spanIdentifier{SystemManager}\spanPunctuation{:}\spanPunctuation{:}\spanIdentifier{getSubsystem}\spanOperator{<}\spanIdentifier{System}\spanPunctuation{:}\spanPunctuation{:}\spanIdentifier{Input}\spanOperator{>}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
\begin{itemize}\item \texttt{\#\symbol{64}} is a special case to support a \texttt{cnew} operation. It is required so that the call expression is inlined directly, without going through a temporary location. This is only required to circumvent a limitation of the current code generator.
\end{itemize}
For example C++'s \texttt{new} operator can be "imported" like this:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{cnew}\spanOperator{*}\spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{T}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{ptr} \spanIdentifier{T} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"(new '*0\#\symbol{64})"}\spanPunctuation{,} \spanIdentifier{nodecl}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanComment{\# constructor of 'Foo':}
\spanKeyword{proc} \spanIdentifier{constructFoo}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{cint}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Foo} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"Foo(\symbol{64})"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{let} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{cnew} \spanIdentifier{constructFoo}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{)}
\end{rstpre}
Produces:

\begin{rstpre}
\spanIdentifier{x} \spanOperator{=} \spanIdentifier{new} \spanIdentifier{Foo}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{)}
\end{rstpre}
However, depending on the use case \texttt{new Foo} can also be wrapped like this instead:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{newFoo}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{cint}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{ptr} \spanIdentifier{Foo} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"new Foo(\symbol{64})"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{let} \spanIdentifier{x} \spanOperator{=} \spanIdentifier{newFoo}\spanPunctuation{(}\spanDecNumber{3}\spanPunctuation{,} \spanDecNumber{4}\spanPunctuation{)}
\end{rstpre}
\rsthC{Wrapping constructors}\label{importcpp-pragma-wrapping-constructors}
Sometimes a C++ class has a private copy constructor and so code like \texttt{Class c = Class(1,2);} must not be generated but instead \texttt{Class c(1,2);}. For this purpose the Nim proc that wraps a C++ constructor needs to be annotated with the constructor\label{constructor_1} pragma. This pragma also helps to generate faster C++ code since construction then doesn't invoke the copy constructor:

\begin{rstpre}
\spanComment{\# a better constructor of 'Foo':}
\spanKeyword{proc} \spanIdentifier{constructFoo}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{cint}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{Foo} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"Foo(\symbol{64})"}\spanPunctuation{,} \spanIdentifier{constructor}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\rsthC{Wrapping destructors}\label{importcpp-pragma-wrapping-destructors}
Since Nim generates C++ directly, any destructor is called implicitly by the C++ compiler at the scope exits. This means that often one can get away with not wrapping the destructor at all! However when it needs to be invoked explicitly, it needs to be wrapped. The pattern language provides everything that is required:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{destroyFoo}\spanPunctuation{(}\spanIdentifier{this}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{Foo}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"\#.\symbol{126}Foo()"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\rsthC{Importcpp for objects}\label{importcpp-pragma-importcpp-for-objects}
Generic \texttt{importcpp}'ed objects are mapped to C++ templates. This means that one can import C++'s templates rather easily without the need for a pattern language for object types:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{StdMap} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"std::map"}\spanPunctuation{,} \spanIdentifier{header}\spanPunctuation{:} \spanStringLit{"<map>"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanPunctuation{\symbol{91}}\spanIdentifier{K}\spanPunctuation{,} \spanIdentifier{V}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{object}
\spanKeyword{proc} \spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{91}}\spanPunctuation{\symbol{93}}\spanOperator{=}\spanPunctuation{\symbol{96}}\spanPunctuation{\symbol{91}}\spanIdentifier{K}\spanPunctuation{,} \spanIdentifier{V}\spanPunctuation{\symbol{93}}\spanPunctuation{(}\spanIdentifier{this}\spanPunctuation{:} \spanKeyword{var} \spanIdentifier{StdMap}\spanPunctuation{\symbol{91}}\spanIdentifier{K}\spanPunctuation{,} \spanIdentifier{V}\spanPunctuation{\symbol{93}}\spanPunctuation{;} \spanIdentifier{key}\spanPunctuation{:} \spanIdentifier{K}\spanPunctuation{;} \spanIdentifier{val}\spanPunctuation{:} \spanIdentifier{V}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}
  \spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"\#\symbol{91}\#\symbol{93} = \#"}\spanPunctuation{,} \spanIdentifier{header}\spanPunctuation{:} \spanStringLit{"<map>"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{StdMap}\spanPunctuation{\symbol{91}}\spanIdentifier{cint}\spanPunctuation{,} \spanIdentifier{cdouble}\spanPunctuation{\symbol{93}}
\spanIdentifier{x}\spanPunctuation{\symbol{91}}\spanDecNumber{6}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanFloatNumber{91.4}
\end{rstpre}
Produces:

\begin{rstpre}
\spanIdentifier{std}\spanPunctuation{:}\spanPunctuation{:}\spanIdentifier{map}\spanOperator{<}\spanKeyword{int}\spanPunctuation{,} \spanKeyword{double}\spanOperator{>} \spanIdentifier{x}\spanPunctuation{;}
\spanIdentifier{x}\spanPunctuation{\symbol{91}}\spanDecNumber{6}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanFloatNumber{91.4}\spanPunctuation{;}
\end{rstpre}
\begin{itemize}\item If more precise control is needed, the apostrophe \texttt{'} can be used in the supplied pattern to denote the concrete type parameters of the generic type. See the usage of the apostrophe operator in proc patterns for more details.
\end{itemize}
\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{VectorIterator} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importcpp}\spanPunctuation{:} \spanStringLit{"std::vector<'0>::iterator"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanPunctuation{\symbol{91}}\spanIdentifier{T}\spanPunctuation{\symbol{93}} \spanOperator{=} \spanKeyword{object}

\spanKeyword{var} \spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{VectorIterator}\spanPunctuation{\symbol{91}}\spanIdentifier{cint}\spanPunctuation{\symbol{93}}
\end{rstpre}
Produces:

\begin{rstpre}
\spanIdentifier{std}\spanPunctuation{:}\spanPunctuation{:}\spanIdentifier{vector}\spanOperator{<}\spanKeyword{int}\spanOperator{>::}\spanIdentifier{iterator} \spanIdentifier{x}\spanPunctuation{;}
\end{rstpre}
\rsthB{ImportJs pragma}\label{implementation-specific-pragmas-importjs-pragma}
Similar to the \href{\#implementation-specific-pragmas-importcpp-pragma}{importcpp pragma for C++}, the \texttt{importjs} pragma can be used to import Javascript methods or symbols in general. The generated code then uses the Javascript method calling syntax: \texttt{obj.method(arg)}.

\rsthB{ImportObjC pragma}\label{implementation-specific-pragmas-importobjc-pragma}
Similar to the \href{\#foreign-function-interface-importc-pragma}{importc pragma for C}, the \texttt{importobjc} pragma can be used to import Objective C\label{objective-c_2} methods.  The generated code then uses the Objective C method calling syntax: \texttt{\symbol{91}obj method param1: arg\symbol{93}}. In addition with the \texttt{header} and \texttt{emit} pragmas this allows \emph{sloppy} interfacing with libraries written in Objective C:

\begin{rstpre}
\spanComment{\# horrible example of how to interface with GNUStep ...}

\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{passL}\spanPunctuation{:} \spanStringLit{"-lobjc"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{emit}\spanPunctuation{:} \spanLongStringLit{"""
\#include <objc/Object.h>
\symbol{64}interface Greeter:Object
\symbol{123}
\symbol{125}

- (void)greet:(long)x y:(long)dummy;
\symbol{64}end

\#include <stdio.h>
\symbol{64}implementation Greeter

- (void)greet:(long)x y:(long)dummy
\symbol{123}
  printf("Hello, World!\symbol{92}n");
\symbol{125}
\symbol{64}end

\#include <stdlib.h>
"""}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{type}
  \spanIdentifier{Id} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importc}\spanPunctuation{:} \spanStringLit{"id"}\spanPunctuation{,} \spanIdentifier{header}\spanPunctuation{:} \spanStringLit{"<objc/Object.h>"}\spanPunctuation{,} \spanIdentifier{final}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{distinct} \spanIdentifier{int}

\spanKeyword{proc} \spanIdentifier{newGreeter}\spanPunctuation{:} \spanIdentifier{Id} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importobjc}\spanPunctuation{:} \spanStringLit{"Greeter new"}\spanPunctuation{,} \spanIdentifier{nodecl}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanIdentifier{greet}\spanPunctuation{(}\spanIdentifier{self}\spanPunctuation{:} \spanIdentifier{Id}\spanPunctuation{,} \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importobjc}\spanPunctuation{:} \spanStringLit{"greet"}\spanPunctuation{,} \spanIdentifier{nodecl}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{proc} \spanIdentifier{free}\spanPunctuation{(}\spanIdentifier{self}\spanPunctuation{:} \spanIdentifier{Id}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importobjc}\spanPunctuation{:} \spanStringLit{"free"}\spanPunctuation{,} \spanIdentifier{nodecl}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{var} \spanIdentifier{g} \spanOperator{=} \spanIdentifier{newGreeter}\spanPunctuation{(}\spanPunctuation{)}
\spanIdentifier{g}\spanOperator{.}\spanIdentifier{greet}\spanPunctuation{(}\spanDecNumber{12}\spanPunctuation{,} \spanDecNumber{34}\spanPunctuation{)}
\spanIdentifier{g}\spanOperator{.}\spanIdentifier{free}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
The compiler needs to be told to generate Objective C (command \texttt{objc}) for this to work. The conditional symbol \texttt{objc} is defined when the compiler emits Objective C code.

\rsthB{CodegenDecl pragma}\label{implementation-specific-pragmas-codegendecl-pragma}
The \texttt{codegenDecl} pragma can be used to directly influence Nim's code generator. It receives a format string that determines how the variable or proc is declared in the generated code.

For variables \$1 in the format string represents the type of the variable and \$2 is the name of the variable.

The following Nim code:

\begin{rstpre}
\spanKeyword{var}
  \spanIdentifier{a} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{codegenDecl}\spanPunctuation{:} \spanStringLit{"\$\# progmem \$\#"}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int}
\end{rstpre}
will generate this C code:

\begin{rstpre}
\spanKeyword{int} \spanIdentifier{progmem} \spanIdentifier{a}
\end{rstpre}
For procedures \$1 is the return type of the procedure, \$2 is the name of the procedure and \$3 is the parameter list.

The following nim code:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{myinterrupt}\spanPunctuation{(}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{codegenDecl}\spanPunctuation{:} \spanStringLit{"\_\_interrupt \$\# \$\#\$\#"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{echo} \spanStringLit{"realistic interrupt handler"}
\end{rstpre}
will generate this code:

\begin{rstpre}
\spanIdentifier{\_\_interrupt} \spanKeyword{void} \spanIdentifier{myinterrupt}\spanPunctuation{(}\spanPunctuation{)}
\end{rstpre}
\rsthB{InjectStmt pragma}\label{implementation-specific-pragmas-injectstmt-pragma}
The \texttt{injectStmt} pragma can be used to inject a statement before every other statement in the current module. It is only supposed to be used for debugging:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{injectStmt}\spanPunctuation{:} \spanIdentifier{gcInvariants}\spanPunctuation{(}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanComment{\# ... complex code here that produces crashes ...}
\end{rstpre}
\rsthB{compile time define pragmas}\label{implementation-specific-pragmas-compile-time-define-pragmas}
The pragmas listed here can be used to optionally accept values from the -d/--define option at compile time.

The implementation currently provides the following possible options (various others may be added later).

\begin{table}\begin{rsttab}{|X|X|X|X|}
\hline
\textbf{pragma} & \textbf{description}\\
\hline
intdefine\label{intdefine_1} & Reads in a build-time define as an integer\\
\hline
strdefine\label{strdefine_1} & Reads in a build-time define as a string\\
\hline
booldefine\label{booldefine_1} & Reads in a build-time define as a bool\\
\hline
\end{rsttab}\end{table}\begin{rstpre}
\spanKeyword{const} \spanIdentifier{FooBar} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{intdefine}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int} \spanOperator{=} \spanDecNumber{5}
\spanIdentifier{echo} \spanIdentifier{FooBar}
\end{rstpre}
\begin{rstpre}
nim c -d:FooBar=42 foobar.nim
\end{rstpre}
In the above example, providing the -d flag causes the symbol \texttt{FooBar} to be overwritten at compile time, printing out 42. If the \texttt{-d:FooBar=42} were to be omitted, the default value of 5 would be used. To see if a value was provided, \texttt{defined(FooBar)} can be used.

The syntax \texttt{-d:flag} is actually just a shortcut for \texttt{-d:flag=true}.

\rsthA{User-defined pragmas}\label{userminusdefined-pragmas}
\rsthB{pragma pragma}\label{userminusdefined-pragmas-pragma-pragma}
The \texttt{pragma} pragma can be used to declare user defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.

Example:

\begin{rstpre}
\spanKeyword{when} \spanIdentifier{appType} \spanOperator{==} \spanStringLit{"lib"}\spanPunctuation{:}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pragma}\spanPunctuation{:} \spanIdentifier{rtl}\spanPunctuation{,} \spanIdentifier{exportc}\spanPunctuation{,} \spanIdentifier{dynlib}\spanPunctuation{,} \spanIdentifier{cdecl}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{else}\spanPunctuation{:}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pragma}\spanPunctuation{:} \spanIdentifier{rtl}\spanPunctuation{,} \spanIdentifier{importc}\spanPunctuation{,} \spanIdentifier{dynlib}\spanPunctuation{:} \spanStringLit{"client.dll"}\spanPunctuation{,} \spanIdentifier{cdecl}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{proc} \spanIdentifier{p}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{rtl}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{a}\spanOperator{+}\spanIdentifier{b}
\end{rstpre}
In the example a new pragma named \texttt{rtl} is introduced that either imports a symbol from a dynamic library or exports the symbol for dynamic library generation.

\rsthB{Custom annotations}\label{userminusdefined-pragmas-custom-annotations}
It is possible to define custom typed pragmas. Custom pragmas do not effect code generation directly, but their presence can be detected by macros. Custom pragmas are defined using templates annotated with pragma \texttt{pragma}:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{dbTable}\spanPunctuation{(}\spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{table\_space}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanStringLit{""}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pragma}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{template} \spanIdentifier{dbKey}\spanPunctuation{(}\spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanStringLit{""}\spanPunctuation{,} \spanIdentifier{primary\_key}\spanPunctuation{:} \spanIdentifier{bool} \spanOperator{=} \spanIdentifier{false}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pragma}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{template} \spanIdentifier{dbForeignKey}\spanPunctuation{(}\spanIdentifier{t}\spanPunctuation{:} \spanIdentifier{typedesc}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pragma}\spanOperator{.}\spanPunctuation{\symbol{125}}
\spanKeyword{template} \spanIdentifier{dbIgnore} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{pragma}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
Consider stylized example of possible Object Relation Mapping (ORM) implementation:

\begin{rstpre}
\spanKeyword{const} \spanIdentifier{tblspace} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{strdefine}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanStringLit{"dev"} \spanComment{\# switch for dev, test and prod environments}

\spanKeyword{type}
  \spanIdentifier{User} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{dbTable}\spanPunctuation{(}\spanStringLit{"users"}\spanPunctuation{,} \spanIdentifier{tblspace}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{id} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{dbKey}\spanPunctuation{(}\spanIdentifier{primary\_key} \spanOperator{=} \spanIdentifier{true}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int}
    \spanIdentifier{name} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanRawData{dbKey"full\_name"}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{string}
    \spanIdentifier{is\_cached} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{dbIgnore}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{bool}
    \spanIdentifier{age}\spanPunctuation{:} \spanIdentifier{int}
  
  \spanIdentifier{UserProfile} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{dbTable}\spanPunctuation{(}\spanStringLit{"profiles"}\spanPunctuation{,} \spanIdentifier{tblspace}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{id} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{dbKey}\spanPunctuation{(}\spanIdentifier{primary\_key} \spanOperator{=} \spanIdentifier{true}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int}
    \spanIdentifier{user\_id} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{dbForeignKey}\spanPunctuation{:} \spanIdentifier{User}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int}
    \spanIdentifier{read\_access}\spanPunctuation{:} \spanIdentifier{bool}
    \spanIdentifier{write\_access}\spanPunctuation{:} \spanIdentifier{bool}
    \spanIdentifier{admin\_acess}\spanPunctuation{:} \spanIdentifier{bool}
\end{rstpre}
In this example custom pragmas are used to describe how Nim objects are mapped to the schema of the relational database. Custom pragmas can have zero or more arguments. In order to pass multiple arguments use one of template call syntaxes. All arguments are typed and follow standard overload resolution rules for templates. Therefore, it is possible to have default values for arguments, pass by name, varargs, etc.

Custom pragmas can be used in all locations where ordinary pragmas can be specified. It is possible to annotate procs, templates, type and variable definitions, statements, etc.

Macros module includes helpers which can be used to simplify custom pragma access \texttt{hasCustomPragma}, \texttt{getCustomPragmaVal}. Please consult the macros module documentation for details. These macros are not magic, everything they do can also be achieved by walking the AST of the object representation.

More examples with custom pragmas:

\begin{itemize}\item Better serialization/deserialization control:
\end{itemize}
\begin{rstpre}
\spanKeyword{type} \spanIdentifier{MyObj} \spanOperator{=} \spanKeyword{object}
  \spanIdentifier{a} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{dontSerialize}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int}
  \spanIdentifier{b} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{defaultDeserialize}\spanPunctuation{:} \spanFloatNumber{5.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{int}
  \spanIdentifier{c} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{serializationKey}\spanPunctuation{:} \spanStringLit{"\_c"}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{string}
\end{rstpre}
\begin{itemize}\item Adopting type for gui inspector in a game engine:
\end{itemize}
\begin{rstpre}
\spanKeyword{type} \spanIdentifier{MyComponent} \spanOperator{=} \spanKeyword{object}
  \spanIdentifier{position} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{editable}\spanPunctuation{,} \spanIdentifier{animatable}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{Vector3}
  \spanIdentifier{alpha} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{editRange}\spanPunctuation{:} \spanPunctuation{\symbol{91}}\spanFloatNumber{0.0}\spanOperator{..}\spanFloatNumber{1.0}\spanPunctuation{\symbol{93}}\spanPunctuation{,} \spanIdentifier{animatable}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{float32}
\end{rstpre}
\rsthB{Macro pragmas}\label{userminusdefined-pragmas-macro-pragmas}
All macros and templates can also be used as pragmas. They can be attached to routines (procs, iterators, etc), type names or type expressions. The compiler will perform the following simple syntactic transformations:

\begin{rstpre}
\spanKeyword{template} \spanIdentifier{command}\spanPunctuation{(}\spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{,} \spanIdentifier{def}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}

\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{command}\spanPunctuation{(}\spanStringLit{"print"}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{discard}
\end{rstpre}
This is translated to:

\begin{rstpre}
\spanIdentifier{command}\spanPunctuation{(}\spanStringLit{"print"}\spanPunctuation{)}\spanPunctuation{:}
  \spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=} \spanKeyword{discard}
\end{rstpre}
\hrule
\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{AsyncEventHandler} \spanOperator{=} \spanKeyword{proc} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{Event}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{async}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
This is translated to:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{AsyncEventHandler} \spanOperator{=} \spanIdentifier{async}\spanPunctuation{(}\spanKeyword{proc} \spanPunctuation{(}\spanIdentifier{x}\spanPunctuation{:} \spanIdentifier{Event}\spanPunctuation{)}\spanPunctuation{)}
\end{rstpre}
\hrule
\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{MyObject} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{schema}\spanPunctuation{:} \spanStringLit{"schema.protobuf"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object}
\end{rstpre}
This is translated to a call to the \texttt{schema} macro with a \texttt{nnkTypeDef} AST node capturing both the left-hand side and right-hand side of the definition. The macro can return a potentially modified \texttt{nnkTypeDef} tree which will replace the original row in the type section.

When multiple macro pragmas are applied to the same definition, the compiler will apply them consequently from left to right. Each macro will receive as input the output of the previous one.

\rsthA{Foreign function interface}\label{foreign-function-interface}
Nim's FFI\label{ffi_1} (foreign function interface) is extensive and only the parts that scale to other future backends (like the LLVM/JavaScript backends) are documented here.

\rsthB{Importc pragma}\label{foreign-function-interface-importc-pragma}
The \texttt{importc} pragma provides a means to import a proc or a variable from C. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier \emph{exactly as spelled}:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{printf}\spanPunctuation{(}\spanIdentifier{formatstr}\spanPunctuation{:} \spanIdentifier{cstring}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{header}\spanPunctuation{:} \spanStringLit{"<stdio.h>"}\spanPunctuation{,} \spanIdentifier{importc}\spanPunctuation{:} \spanStringLit{"printf"}\spanPunctuation{,} \spanIdentifier{varargs}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
When \texttt{importc} is applied to a \texttt{let} statement it can omit its value which will then be expected to come from C. This can be used to import a C \texttt{const}:

\begin{rstpre}
\spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{emit}\spanPunctuation{:} \spanStringLit{"const int cconst = 42;"}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanKeyword{let} \spanIdentifier{cconst} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importc}\spanPunctuation{,} \spanIdentifier{nodecl}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{cint}

\spanIdentifier{assert} \spanIdentifier{cconst} \spanOperator{==} \spanDecNumber{42}
\end{rstpre}
Note that this pragma has been abused in the past to also work in the js backend for js objects and functions. : Other backends do provide the same feature under the same name. Also, when the target language is not set to C, other pragmas are available:

\begin{quote}\begin{itemize}\item \href{manual.html\#implementation-specific-pragmas-importcpp-pragma}{importcpp}
\item \href{manual.html\#implementation-specific-pragmas-importobjc-pragma}{importobjc}
\item \href{manual.html\#implementation-specific-pragmas-importjs-pragma}{importjs}
\end{itemize}
\end{quote}
\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{cstring}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{importc}\spanPunctuation{:} \spanStringLit{"prefix\$1"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
In the example the external name of \texttt{p} is set to \texttt{prefixp}. Only \texttt{\$1} is available and a literal dollar sign must be written as \texttt{\$\$}.

\rsthB{Exportc pragma}\label{foreign-function-interface-exportc-pragma}
The \texttt{exportc} pragma provides a means to export a type, a variable, or a procedure to C. Enums and constants can't be exported. The optional argument is a string containing the C identifier.  If the argument is missing, the C name is the Nim identifier \emph{exactly as spelled}:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{callme}\spanPunctuation{(}\spanIdentifier{formatstr}\spanPunctuation{:} \spanIdentifier{cstring}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{exportc}\spanPunctuation{:} \spanStringLit{"callMe"}\spanPunctuation{,} \spanIdentifier{varargs}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name.

The string literal passed to \texttt{exportc} can be a format string:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{exportc}\spanPunctuation{:} \spanStringLit{"prefix\$1"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{echo} \spanIdentifier{s}
\end{rstpre}
In the example the external name of \texttt{p} is set to \texttt{prefixp}. Only \texttt{\$1} is available and a literal dollar sign must be written as \texttt{\$\$}.

If the symbol should also be exported to a dynamic library, the \texttt{dynlib} pragma should be used in addition to the \texttt{exportc} pragma. See \href{\#foreign-function-interface-dynlib-pragma-for-export}{Dynlib pragma for export}.

\rsthB{Extern pragma}\label{foreign-function-interface-extern-pragma}
Like \texttt{exportc} or \texttt{importc}, the \texttt{extern} pragma affects name mangling. The string literal passed to \texttt{extern} can be a format string:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{p}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{string}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{extern}\spanPunctuation{:} \spanStringLit{"prefix\$1"}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=}
  \spanIdentifier{echo} \spanIdentifier{s}
\end{rstpre}
In the example the external name of \texttt{p} is set to \texttt{prefixp}. Only \texttt{\$1} is available and a literal dollar sign must be written as \texttt{\$\$}.

\rsthB{Bycopy pragma}\label{foreign-function-interface-bycopy-pragma}
The \texttt{bycopy} pragma can be applied to an object or tuple type and instructs the compiler to pass the type by value to procs:

\begin{rstpre}
\spanKeyword{type}
  \spanIdentifier{Vector} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{bycopy}\spanOperator{.}\spanPunctuation{\symbol{125}} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{x}\spanPunctuation{,} \spanIdentifier{y}\spanPunctuation{,} \spanIdentifier{z}\spanPunctuation{:} \spanIdentifier{float}
\end{rstpre}
\rsthB{Byref pragma}\label{foreign-function-interface-byref-pragma}
The \texttt{byref} pragma can be applied to an object or tuple type and instructs the compiler to pass the type by reference (hidden pointer) to procs.

\rsthB{Varargs pragma}\label{foreign-function-interface-varargs-pragma}
The \texttt{varargs} pragma can be applied to procedures only (and procedure types). It tells Nim that the proc can take a variable number of parameters after the last specified parameter. Nim string values will be converted to C strings automatically:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{printf}\spanPunctuation{(}\spanIdentifier{formatstr}\spanPunctuation{:} \spanIdentifier{cstring}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{nodecl}\spanPunctuation{,} \spanIdentifier{varargs}\spanOperator{.}\spanPunctuation{\symbol{125}}

\spanIdentifier{printf}\spanPunctuation{(}\spanStringLit{"hallo \%s"}\spanPunctuation{,} \spanStringLit{"world"}\spanPunctuation{)} \spanComment{\# "world" will be passed as C string}
\end{rstpre}
\rsthB{Union pragma}\label{foreign-function-interface-union-pragma}
The \texttt{union} pragma can be applied to any \texttt{object} type. It means all of the object's fields are overlaid in memory. This produces a \texttt{union} instead of a \texttt{struct} in the generated C/C++ code. The object declaration then must not use inheritance or any GC'ed memory but this is currently not checked.

\textbf{Future directions}: GC'ed memory should be allowed in unions and the GC should scan unions conservatively.

\rsthB{Packed pragma}\label{foreign-function-interface-packed-pragma}
The \texttt{packed} pragma can be applied to any \texttt{object} type. It ensures that the fields of an object are packed back-to-back in memory. It is useful to store packets or messages from/to network or hardware drivers, and for interoperability with C. Combining packed pragma with inheritance is not defined, and it should not be used with GC'ed memory (ref's).

\textbf{Future directions}: Using GC'ed memory in packed pragma will result in a static error. Usage with inheritance should be defined and documented.

\rsthB{Dynlib pragma for import}\label{foreign-function-interface-dynlib-pragma-for-import}
With the \texttt{dynlib} pragma a procedure or a variable can be imported from a dynamic library (\texttt{.dll} files for Windows, \texttt{lib*.so} files for UNIX). The non-optional argument has to be the name of the dynamic library:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{gtk\_image\_new}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{PGtkWidget}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{cdecl}\spanPunctuation{,} \spanIdentifier{dynlib}\spanPunctuation{:} \spanStringLit{"libgtk-x11-2.0.so"}\spanPunctuation{,} \spanIdentifier{importc}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
In general, importing a dynamic library does not require any special linker options or linking with import libraries. This also implies that no \emph{devel} packages need to be installed.

The \texttt{dynlib} import mechanism supports a versioning scheme:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{Tcl\_Eval}\spanPunctuation{(}\spanIdentifier{interp}\spanPunctuation{:} \spanIdentifier{pTcl\_Interp}\spanPunctuation{,} \spanIdentifier{script}\spanPunctuation{:} \spanIdentifier{cstring}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{cdecl}\spanPunctuation{,}
  \spanIdentifier{importc}\spanPunctuation{,} \spanIdentifier{dynlib}\spanPunctuation{:} \spanStringLit{"libtcl(|8.5|8.4|8.3).so.(1|0)"}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
At runtime the dynamic library is searched for (in this order):\begin{rstpre}

libtcl.so.1
libtcl.so.0
libtcl8.5.so.1
libtcl8.5.so.0
libtcl8.4.so.1
libtcl8.4.so.0
libtcl8.3.so.1
libtcl8.3.so.0
\end{rstpre}


The \texttt{dynlib} pragma supports not only constant strings as argument but also string expressions in general:

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{os}

\spanKeyword{proc} \spanIdentifier{getDllName}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=}
  \spanIdentifier{result} \spanOperator{=} \spanStringLit{"mylib.dll"}
  \spanKeyword{if} \spanIdentifier{fileExists}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{return}
  \spanIdentifier{result} \spanOperator{=} \spanStringLit{"mylib2.dll"}
  \spanKeyword{if} \spanIdentifier{fileExists}\spanPunctuation{(}\spanIdentifier{result}\spanPunctuation{)}\spanPunctuation{:} \spanKeyword{return}
  \spanIdentifier{quit}\spanPunctuation{(}\spanStringLit{"could not load dynamic library"}\spanPunctuation{)}

\spanKeyword{proc} \spanIdentifier{myImport}\spanPunctuation{(}\spanIdentifier{s}\spanPunctuation{:} \spanIdentifier{cstring}\spanPunctuation{)} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{cdecl}\spanPunctuation{,} \spanIdentifier{importc}\spanPunctuation{,} \spanIdentifier{dynlib}\spanPunctuation{:} \spanIdentifier{getDllName}\spanPunctuation{(}\spanPunctuation{)}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
\textbf{Note}: Patterns like \texttt{libtcl(|8.5|8.4).so} are only supported in constant strings, because they are precompiled.

\textbf{Note}: Passing variables to the \texttt{dynlib} pragma will fail at runtime because of order of initialization problems.

\textbf{Note}: A \texttt{dynlib} import can be overridden with the \texttt{--dynlibOverride:name} command line option. The Compiler User Guide contains further information.

\rsthB{Dynlib pragma for export}\label{foreign-function-interface-dynlib-pragma-for-export}
With the \texttt{dynlib} pragma a procedure can also be exported to a dynamic library. The pragma then has no argument and has to be used in conjunction with the \texttt{exportc} pragma:

\begin{rstpre}
\spanKeyword{proc} \spanIdentifier{exportme}\spanPunctuation{(}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{int} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{cdecl}\spanPunctuation{,} \spanIdentifier{exportc}\spanPunctuation{,} \spanIdentifier{dynlib}\spanOperator{.}\spanPunctuation{\symbol{125}}
\end{rstpre}
This is only useful if the program is compiled as a dynamic library via the \texttt{--app:lib} command line option.

\rsthA{Threads}\label{threads}
To enable thread support the \texttt{--threads:on} command line switch needs to be used. The \texttt{system} module then contains several threading primitives. See the \href{threads.html}{threads} and \href{channels.html}{channels} modules for the low level thread API. There are also high level parallelism constructs available. See \href{manual\_experimental.html\#parallel-amp-spawn}{spawn} for further details.

Nim's memory model for threads is quite different than that of other common programming languages (C, Pascal, Java): Each thread has its own (garbage collected) heap and sharing of memory is restricted to global variables. This helps to prevent race conditions. GC efficiency is improved quite a lot, because the GC never has to stop other threads and see what they reference.

\rsthB{Thread pragma}\label{threads-thread-pragma}
A proc that is executed as a new thread of execution should be marked by the \texttt{thread} pragma for reasons of readability. The compiler checks for violations of the no heap sharing restriction\label{no-heap-sharing-restriction_1}: This restriction implies that it is invalid to construct a data structure that consists of memory allocated from different (thread local) heaps.

A thread proc is passed to \texttt{createThread} or \texttt{spawn} and invoked indirectly; so the \texttt{thread} pragma implies \texttt{procvar}.

\rsthB{GC safety}\label{threads-gc-safety}
We call a proc \texttt{p} GC safe\label{gc-safe_1} when it doesn't access any global variable that contains GC'ed memory (\texttt{string}, \texttt{seq}, \texttt{ref} or a closure) either directly or indirectly through a call to a GC unsafe proc.

The gcsafe\label{gcsafe_1} annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that \texttt{noSideEffect} implies \texttt{gcsafe}. The only way to create a thread is via \texttt{spawn} or \texttt{createThread}. The invoked proc must not use \texttt{var} parameters nor must any of its parameters contain a \texttt{ref} or \texttt{closure} type. This enforces the \emph{no heap sharing restriction}.

Routines that are imported from C are always assumed to be \texttt{gcsafe}. To disable the GC-safety checking the \texttt{--threadAnalysis:off} command line switch can be used. This is a temporary workaround to ease the porting effort from old code to the new threading model.

To override the compiler's gcsafety analysis a \texttt{\symbol{123}.gcsafe.\symbol{125}} pragma block can be used:

\begin{rstpre}
\spanKeyword{var}
  \spanIdentifier{someGlobal}\spanPunctuation{:} \spanIdentifier{string} \spanOperator{=} \spanStringLit{"some string here"}
  \spanIdentifier{perThread} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{threadvar}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{string}

\spanKeyword{proc} \spanIdentifier{setPerThread}\spanPunctuation{(}\spanPunctuation{)} \spanOperator{=}
  \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{gcsafe}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:}
    \spanIdentifier{deepCopy}\spanPunctuation{(}\spanIdentifier{perThread}\spanPunctuation{,} \spanIdentifier{someGlobal}\spanPunctuation{)}
\end{rstpre}
See also:

\begin{itemize}\item \href{gc.html}{Shared heap memory management.}.
\end{itemize}
\rsthB{Threadvar pragma}\label{threads-threadvar-pragma}
A variable can be marked with the \texttt{threadvar} pragma, which makes it a thread-local\label{threadminuslocal_1} variable; Additionally, this implies all the effects of the \texttt{global} pragma.

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{checkpoints}\spanOperator{*} \spanPunctuation{\symbol{123}}\spanOperator{.}\spanIdentifier{threadvar}\spanOperator{.}\spanPunctuation{\symbol{125}}\spanPunctuation{:} \spanIdentifier{seq}\spanPunctuation{\symbol{91}}\spanIdentifier{string}\spanPunctuation{\symbol{93}}
\end{rstpre}
Due to implementation restrictions thread local variables cannot be initialized within the \texttt{var} section. (Every thread local variable needs to be replicated at thread creation.)

\rsthB{Threads and exceptions}\label{threads-threads-and-exceptions}
The interaction between threads and exceptions is simple: A \emph{handled} exception in one thread cannot affect any other thread. However, an \emph{unhandled} exception in one thread terminates the whole \emph{process}! 




\end{document}
