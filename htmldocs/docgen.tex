% This file was generated by Nim.
% Generated: 2020-08-22 06:37:23 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{Nim DocGen Tools Guide 1.3.5}
\author{Erik O'Leary}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

\tableofcontents \newpage
\rsthA{Introduction}\label{introduction}
This document describes the documentation generation tools\label{documentation-generation-tools_1} built into the \href{nimc.html}{Nim compiler}, which can generate HTML and JSON output from input .nim files and projects, as well as HTML and LaTeX from input RST (reStructuredText) files. The output documentation will include module dependencies (\texttt{import}), any top-level documentation comments (\#\#), and exported symbols (*), including procedures, types, and variables.

\rsthB{Quick start}\label{introduction-quick-start}
Generate HTML documentation for a file:

\begin{rstpre}
nim doc <filename>.nim
\end{rstpre}
Generate HTML documentation for a whole project:

\begin{rstpre}
\# delete any htmldocs/*.idx file before starting
nim doc --project --index:on --git.url:<url> --git.commit:<tag> --outdir:htmldocs <main\_filename>.nim
\# this will generate html files, a theindex.html index, css and js under \symbol{96}htmldocs\symbol{96}
\# See also \symbol{96}--docroot\symbol{96} to specify a relative root.
\# to get search (dochacks.js) to work locally, you need a server otherwise
\# CORS will prevent opening file:// urls; this works:
python3 -m http.server 7029 --directory htmldocs
\# When --outdir is omitted it defaults to \$projectPath/htmldocs,
or \symbol{96}\$nimcache/htmldocs\symbol{96} with \symbol{96}--usenimcache\symbol{96} which avoids clobbering your sources;
and likewise without \symbol{96}--project\symbol{96}.
Adding \symbol{96}-r\symbol{96} will open in a browser directly.
\end{rstpre}
\rsthB{Documentation Comments}\label{introduction-documentation-comments}
Any comments which are preceded by a double-hash (\#\#), are interpreted as documentation.  Comments are parsed as RST (see \href{http://docutils.sourceforge.net/docs/user/rst/quickref.html}{reference}), providing Nim module authors the ability to easily generate richly formatted documentation with only their well-documented code.

Example:

\begin{rstpre}
\spanKeyword{type} \spanIdentifier{Person}\spanOperator{*} \spanOperator{=} \spanKeyword{object}
  \spanComment{\#\# This type contains a description of a person}
  \spanIdentifier{name}\spanPunctuation{:} \spanIdentifier{string}
  \spanIdentifier{age}\spanPunctuation{:} \spanIdentifier{int}
\end{rstpre}
Outputs:\begin{rstpre}
Person* = object
  name: string
  age: int
\end{rstpre}


This type contains a description of a person

Field documentation comments can be added to fields like so:

\begin{rstpre}
\spanKeyword{var} \spanIdentifier{numValues}\spanPunctuation{:} \spanIdentifier{int} \spanComment{\#\# \symbol{92}}
  \spanComment{\#\# \symbol{96}numValues\symbol{96} stores the number of values}
\end{rstpre}
Note that without the \texttt{*} following the name of the type, the documentation for this type would not be generated. Documentation will only be generated for \emph{exported} types/procedures/etc.

\rsthB{Nim file input}\label{introduction-nim-file-input}
The following examples will generate documentation for the below contrived \emph{Nim} module, aptly named 'sample.nim'

sample.nim:

\begin{rstpre}
\spanComment{\#\# This module is a sample.}

\spanKeyword{import} \spanIdentifier{strutils}

\spanKeyword{proc} \spanIdentifier{helloWorld}\spanOperator{*}\spanPunctuation{(}\spanIdentifier{times}\spanPunctuation{:} \spanIdentifier{int}\spanPunctuation{)} \spanOperator{=}
  \spanComment{\#\# Takes an integer and outputs}
  \spanComment{\#\# as many "hello world!"s}
  
  \spanKeyword{for} \spanIdentifier{i} \spanKeyword{in} \spanDecNumber{0} \spanOperator{..} \spanIdentifier{times}\spanOperator{-}\spanDecNumber{1}\spanPunctuation{:}
    \spanIdentifier{echo} \spanStringLit{"hello world!"}

\spanIdentifier{helloWorld}\spanPunctuation{(}\spanDecNumber{5}\spanPunctuation{)}
\end{rstpre}
\rsthA{Document Types}\label{document-types}
\rsthB{HTML}\label{document-types-html}
Generation of HTML documents is done via the \texttt{doc} command. This command takes either a single .nim file, outputting a single .html file with the same base filename, or multiple .nim files, outputting multiple .html files and, optionally, an index file.

The \texttt{doc} command:\begin{rstpre}
nim doc sample
\end{rstpre}


Partial Output:\begin{rstpre}
...
proc helloWorld(times: int) \symbol{123}.raises: \symbol{91}\symbol{93}, tags: \symbol{91}\symbol{93}.\symbol{125}
...
\end{rstpre}


The full output can be seen here: \href{docgen\_sample.html}{docgen\_sample.html}. It runs after semantic checking, and includes pragmas attached implicitly by the compiler.

\rsthB{JSON}\label{document-types-json}
Generation of JSON documents is done via the \texttt{jsondoc} command. This command takes in a .nim file, and outputs a .json file with the same base filename. Note that this tool is built off of the \texttt{doc} command (previously \texttt{doc2}), and contains the same information.

The \texttt{jsondoc} command:\begin{rstpre}
nim jsondoc sample
\end{rstpre}


Output:\begin{rstpre}
\symbol{123}
  "orig": "docgen\_sample.nim",
  "nimble": "",
  "moduleDescription": "This module is a sample",
  "entries": \symbol{91}
    \symbol{123}
      "name": "helloWorld",
      "type": "skProc",
      "line": 5,
      "col": 0,
      "description": "Takes an integer and outputs as many \&quot;hello world!\&quot;s",
      "code": "proc helloWorld(times: int) \symbol{123}.raises: \symbol{91}\symbol{93}, tags: \symbol{91}\symbol{93}.\symbol{125}"
    \symbol{125}
  \symbol{93}
\symbol{125}
\end{rstpre}


Similarly to the old \texttt{doc} command the old \texttt{jsondoc} command has been renamed \texttt{jsondoc0}.

The \texttt{jsondoc0} command:\begin{rstpre}
nim jsondoc0 sample
\end{rstpre}


Output:\begin{rstpre}
\symbol{91}
  \symbol{123}
    "comment": "This module is a sample."
  \symbol{125},
  \symbol{123}
    "name": "helloWorld",
    "type": "skProc",
    "description": "Takes an integer and outputs as many \&quot;hello world!\&quot;s",
    "code": "proc helloWorld*(times: int)"
  \symbol{125}
\symbol{93}
\end{rstpre}


Note that the \texttt{jsondoc} command outputs it's JSON without pretty-printing it, while \texttt{jsondoc0} outputs pretty-printed JSON.

\rsthA{Related Options}\label{related-options}
\rsthB{Project switch}\label{related-options-project-switch}
\begin{rstpre}
nim doc --project filename.nim
\end{rstpre}
This will recursively generate documentation of all nim modules imported into the input module that belong to the Nimble package that \texttt{filename.nim} belongs to.

\rsthB{Index switch}\label{related-options-index-switch}
\begin{rstpre}
nim doc2 --index:on filename.nim
\end{rstpre}
This will generate an index of all the exported symbols in the input Nim module, and put it into a neighboring file with the extension of \texttt{.idx}. The index file is line oriented (newlines have to be escaped). Each line represents a tab separated record of several columns, the first two mandatory, the rest optional. See the Index (idx) file format\ref{index-idx-file-format} section for details.

Once index files have been generated for one or more modules, the Nim compiler command \texttt{buildIndex directory} can be run to go over all the index files in the specified directory to generate a \href{theindex.html}{theindex.html} file.

\rsthB{See source switch}\label{related-options-see-source-switch}
The \texttt{docSeeSrcUrl} switch is deprecated. Use:

\begin{rstpre}
nim doc2 --git.url:<url> filename.nim
\end{rstpre}
With the \texttt{git.url} switch the \emph{See source} hyperlink will appear below each documented item in your source code pointing to the implementation of that item on a GitHub repository. You can click the link to see the implementation of the item.

The \texttt{git.commit} switch overrides the hardcoded \texttt{devel} branch in config/nimdoc.cfg. This is useful to link to a different branch e.g. \texttt{--git.commit:master}, or to a tag e.g. \texttt{--git.commit:1.2.3} or a commit.

Source URLs are generated as \texttt{href="\$\symbol{123}url\symbol{125}/tree/\$\symbol{123}commit\symbol{125}/\$\symbol{123}path\symbol{125}\#L\$\symbol{123}line\symbol{125}"} by default and this compatible with GitHub but not with GitLab.

Similarly, \texttt{git.devel} switch overrides the hardcoded \texttt{devel} branch for the \texttt{Edit} link which is also useful if you have a different working branch than \texttt{devel} e.g. \texttt{--git.devel:master}.

Edit URLs are generated as \texttt{href="\$\symbol{123}url\symbol{125}/tree/\$\symbol{123}devel\symbol{125}/\$\symbol{123}path\symbol{125}\#L\$\symbol{123}line\symbol{125}"} by default.

You can edit \texttt{config/nimdoc.cfg} and modify the \texttt{doc.item.seesrc} value with a hyperlink to your own code repository.

In the case of Nim's own documentation, the \texttt{commit} value is just a commit hash to append to a formatted URL to \href{https://github.com/nim-lang/Nim}{https://github.com/nim-lang/Nim}. The \texttt{tools/nimweb.nim} helper queries the current git commit hash during doc generation, but since you might be working on an unpublished repository, it also allows specifying a \texttt{githash} value in \texttt{web/website.ini} to force a specific commit in the output.

\rsthA{Other Input Formats}\label{other-input-formats}
The \emph{Nim compiler} also has support for RST (reStructuredText) files with the \texttt{rst2html} and \texttt{rst2tex} commands. Documents like this one are initially written in a dialect of RST which adds support for nim source code highlighting with the \texttt{.. code-block:: nim} prefix. \texttt{code-block} also supports highlighting of C++ and some other c-like languages.

Usage:\begin{rstpre}
nim rst2html docgen.txt
\end{rstpre}


Output:\begin{rstpre}
You're reading it!
\end{rstpre}


The \texttt{rst2tex} command is invoked identically to \texttt{rst2html}, but outputs a .tex file instead of .html.

\rsthA{HTML anchor generation}\label{html-anchor-generation}
When you run the \texttt{rst2html} command, all sections in the RST document will get an anchor you can hyperlink to. Usually you can guess the anchor lower casing the section title and replacing spaces with dashes, and in any case you can get it from the table of contents. But when you run the \texttt{doc} or \texttt{doc2} commands to generate API documentation, some symbol get one or two anchors at the same time: a numerical identifier, or a plain name plus a complex name.

The numerical identifier is just a random number. The number gets assigned according to the section and position of the symbol in the file being processed and you should not rely on it being constant: if you add or remove a symbol the numbers may shuffle around.

The plain name of a symbol is a simplified version of its fully exported signature. Variables or constants have the same plain name symbol as their complex name. The plain name for procs, templates, and other callable types will be their unquoted value after removing parameters, return types and pragmas. The plain name allows short and nice linking of symbols which works unless you have a module with collisions due to overloading.

If you hyperlink a plain name symbol and there are other matches on the same HTML file, most browsers will go to the first one. To differentiate the rest, you will need to use the complex name. A complex name for a callable type is made up from several parts:

\begin{quote}(\textbf{plain symbol})(\textbf{.type}),(\textbf{first param})?(\textbf{,param type})*\end{quote}
The first thing to note is that all callable types have at least a comma, even if they don't have any parameters. If there are parameters, they are represented by their types and will be comma separated. To the plain symbol a suffix may be added depending on the type of the callable:

\begin{table}\begin{rsttab}{|X|X|X|X|X|X|X|}
\hline
\textbf{Callable type} & \textbf{Suffix}\\
\hline
proc & \emph{empty string}\\
\hline
macro & \texttt{.m}\\
\hline
method & \texttt{.e}\\
\hline
iterator & \texttt{.i}\\
\hline
template & \texttt{.t}\\
\hline
converter & \texttt{.c}\\
\hline
\end{rsttab}\end{table}The relationship of type to suffix is made by the proc \texttt{complexName} in the \texttt{compiler/docgen.nim} file. Here are some examples of complex names for symbols in the \href{system.html}{system module}.

\begin{itemize}\item \texttt{type SomeSignedInt = int | int8 | int16 | int32 | int64} \textbf{=>} \href{system.html\#SomeSignedInt}{\#SomeSignedInt}
\item \texttt{var globalRaiseHook: proc (e: ref E\_Base): bool \symbol{123}.nimcall.\symbol{125}} \textbf{=>} \href{system.html\#globalRaiseHook}{\#globalRaiseHook}
\item \texttt{const NimVersion = "0.0.0"} \textbf{=>} \href{system.html\#NimVersion}{\#NimVersion}
\item \texttt{proc getTotalMem(): int \symbol{123}.rtl, raises: \symbol{91}\symbol{93}, tags: \symbol{91}\symbol{93}.\symbol{125}} \textbf{=>} \href{system.html\#getTotalMem}{\#getTotalMem,}
\item \texttt{proc len\symbol{91}T\symbol{93}(x: seq\symbol{91}T\symbol{93}): int \symbol{123}.magic: "LengthSeq", noSideEffect.\symbol{125}} \textbf{=>} \href{system.html\#len,seq\symbol{91}T\symbol{93}}{\#len,seq\symbol{91}T\symbol{93}}
\item \texttt{iterator pairs\symbol{91}T\symbol{93}(a: seq\symbol{91}T\symbol{93}): tuple\symbol{91}key: int, val: T\symbol{93} \symbol{123}.inline.\symbol{125}} \textbf{=>} \href{system.html\#pairs.i,seq\symbol{91}T\symbol{93}}{\#pairs.i,seq\symbol{91}T\symbol{93}}
\item \texttt{template newException\symbol{91}\symbol{93}(exceptn: typedesc; message: string; parentException: ref Exception = nil): untyped} \textbf{=>} \href{system.html\#newException.t,typedesc,string,ref.Exception}{\#newException.t,typedesc,string,ref.Exception}
\end{itemize}
\rsthA{Index (idx) file format}\label{index-idx-file-format}
Files with the \texttt{.idx} extension are generated when you use the \href{\#related-options-index-switch}{Index switch} along with commands to generate documentation from source or text files. You can programmatically generate indices with the \href{rstgen.html\#setIndexTerm,RstGenerator,string,string,string,string,string}{setIndexTerm()} and \href{rstgen.html\#writeIndexFile,RstGenerator,string}{writeIndexFile()} procs. The purpose of \texttt{idx} files is to hold the interesting symbols and their HTML references so they can be later concatenated into a big index file with \href{rstgen.html\#mergeIndexes,string}{mergeIndexes()}.  This section documents the file format in detail.

Index files are line oriented and tab separated (newline and tab characters have to be escaped). Each line represents a record with at least two fields, but can have up to four (additional columns are ignored). The content of these columns is:

\begin{enumerate}\item Mandatory term being indexed. Terms can include quoting according to Nim's rules (eg. \symbol{96}\symbol{94}\symbol{96}).
\item Base filename plus anchor hyperlink (eg. \texttt{algorithm.html\#*,int,SortOrder}).
\item Optional human readable string to display as hyperlink. If the value is not present or is the empty string, the hyperlink will be rendered using the term. Prefix whitespace indicates that this entry is not for an API symbol but for a TOC entry.
\item Optional title or description of the hyperlink. Browsers usually display this as a tooltip after hovering a moment over the hyperlink.
\end{enumerate}
The index generation tools try to differentiate between documentation generated from \texttt{.nim} files and documentation generated from \texttt{.txt} or \texttt{.rst} files. The former are always closely related to source code and consist mainly of API entries. The latter are generic documents meant for human reading.

To differentiate both types (documents and APIs), the index generator will add to the index of documents an entry with the title of the document. Since the title is the topmost element, it will be added with a second field containing just the filename without any HTML anchor.  By convention this entry without anchor is the \emph{title entry}, and since entries in the index file are added as they are scanned, the title entry will be the first line. The title for APIs is not present because it can be generated concatenating the name of the file to the word \textbf{Module}.

Normal symbols are added to the index with surrounding whitespaces removed. An exception to this are table of content (TOC) entries. TOC entries are added to the index file with their third column having as much prefix spaces as their level is in the TOC (at least 1 character). The prefix whitespace helps to filter TOC entries from API or text symbols. This is important because the amount of spaces is used to replicate the hierarchy for document TOCs in the final index, and TOC entries found in \texttt{.nim} files are discarded.

\rsthA{Additional resources}\label{additional-resources}
\href{nimc.html\#compiler-usage-command-line-switches}{Nim Compiler User Guide}

\href{http://docutils.sourceforge.net/docs/user/rst/quickref.html}{RST Quick Reference}

The output for HTML and LaTeX comes from the \texttt{config/nimdoc.cfg} and \texttt{config/nimdoc.tex.cfg} configuration files. You can add and modify these files to your project to change the look of docgen output.

You can import the \href{rstgen.html}{packages/docutils/rstgen module} in your programs if you want to reuse the compiler's documentation generation procs. 




\end{document}
