% This file was generated by Nim.
% Generated: 2020-08-22 06:37:51 UTC
\documentclass[a4paper]{article}
\usepackage[left=2cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyvrb, courier}
\usepackage{tabularx}
\usepackage{hyperref}

\begin{document}
\title{Nim Tutorial (Part III) 1.3.5}
\author{Arne DÃ¶ring}

\tolerance 1414 
\hbadness 1414 
\emergencystretch 1.5em 
\hfuzz 0.3pt 
\widowpenalty=10000 
\vfuzz \hfuzz 
\raggedbottom 

\maketitle

\newenvironment{rstpre}{\VerbatimEnvironment\begingroup\begin{Verbatim}[fontsize=\footnotesize , commandchars=\\\{\}]}{\end{Verbatim}\endgroup}

% to pack tabularx into a new environment, special syntax is needed :-(
\newenvironment{rsttab}[1]{\tabularx{\linewidth}{#1}}{\endtabularx}

\newcommand{\rstsub}[1]{\raisebox{-0.5ex}{\scriptsize{#1}}}
\newcommand{\rstsup}[1]{\raisebox{0.5ex}{\scriptsize{#1}}}

\newcommand{\rsthA}[1]{\section{#1}}
\newcommand{\rsthB}[1]{\subsection{#1}}
\newcommand{\rsthC}[1]{\subsubsection{#1}}
\newcommand{\rsthD}[1]{\paragraph{#1}}
\newcommand{\rsthE}[1]{\paragraph{#1}}

\newcommand{\rstovA}[1]{\section*{#1}}
\newcommand{\rstovB}[1]{\subsection*{#1}}
\newcommand{\rstovC}[1]{\subsubsection*{#1}}
\newcommand{\rstovD}[1]{\paragraph*{#1}}
\newcommand{\rstovE}[1]{\paragraph*{#1}}

% Syntax highlighting:
\newcommand{\spanDecNumber}[1]{#1}
\newcommand{\spanBinNumber}[1]{#1}
\newcommand{\spanHexNumber}[1]{#1}
\newcommand{\spanOctNumber}[1]{#1}
\newcommand{\spanFloatNumber}[1]{#1}
\newcommand{\spanIdentifier}[1]{#1}
\newcommand{\spanKeyword}[1]{\textbf{#1}}
\newcommand{\spanStringLit}[1]{#1}
\newcommand{\spanLongStringLit}[1]{#1}
\newcommand{\spanCharLit}[1]{#1}
\newcommand{\spanEscapeSequence}[1]{#1}
\newcommand{\spanOperator}[1]{#1}
\newcommand{\spanPunctuation}[1]{#1}
\newcommand{\spanComment}[1]{\emph{#1}}
\newcommand{\spanLongComment}[1]{\emph{#1}}
\newcommand{\spanRegularExpression}[1]{#1}
\newcommand{\spanTagStart}[1]{#1}
\newcommand{\spanTagEnd}[1]{#1}
\newcommand{\spanKey}[1]{#1}
\newcommand{\spanValue}[1]{#1}
\newcommand{\spanRawData}[1]{#1}
\newcommand{\spanAssembler}[1]{#1}
\newcommand{\spanPreprocessor}[1]{#1}
\newcommand{\spanDirective}[1]{#1}
\newcommand{\spanCommand}[1]{#1}
\newcommand{\spanRule}[1]{#1}
\newcommand{\spanHyperlink}[1]{#1}
\newcommand{\spanLabel}[1]{#1}
\newcommand{\spanReference}[1]{#1}
\newcommand{\spanOther}[1]{#1}
\newcommand{\spantok}[1]{\frame{#1}}

\tableofcontents \newpage
\rsthA{Introduction}\label{introduction}
\begin{quote}"With Great Power Comes Great Responsibility." -- Spider Man's Uncle\end{quote}
This document is a tutorial about Nim's macro system. A macro is a function that is executed at compile time and transforms a Nim syntax tree into a different tree.

Examples of things that can be implemented in macros:

\begin{itemize}\item An assert macro that prints both sides of a comparison operator, if the assertion fails. \texttt{myAssert(a == b)} is converted to \texttt{if a != b: quit(\$a " != " \$b)}
\item A debug macro that prints the value and the name of the symbol. \texttt{myDebugEcho(a)} is converted to \texttt{echo "a: ", a}
\item Symbolic differentiation of an expression. \texttt{diff(a*pow(x,3) + b*pow(x,2) + c*x + d, x)} is converted to \texttt{3*a*pow(x,2) + 2*b*x + c}
\end{itemize}
\rsthB{Macro Arguments}\label{introduction-macro-arguments}
The types of macro arguments have two faces. One face is used for the overload resolution, and the other face is used within the macro body. For example, if \texttt{macro foo(arg: int)} is called in an expression \texttt{foo(x)}, \texttt{x} has to be of a type compatible to int, but \emph{within} the macro's body \texttt{arg} has the type \texttt{NimNode}, not \texttt{int}! Why it is done this way will become obvious later, when we have seen concrete examples.

There are two ways to pass arguments to a macro, an argument can be either \texttt{typed} or \texttt{untyped}.

\rsthB{Untyped Arguments}\label{introduction-untyped-arguments}
Untyped macro arguments are passed to the macro before they are semantically checked. This means the syntax tree that is passed down to the macro does not need to make sense for Nim yet, the only limitation is that it needs to be parsable. Usually the macro does not check the argument either but uses it in the transformation's result somehow. The result of a macro expansion is always checked by the compiler, so apart from weird error messages nothing bad can happen.

The downside for an \texttt{untyped} argument is that these do not play well with Nim's overloading resolution.

The upside for untyped arguments is that the syntax tree is quite predictable and less complex compared to its \texttt{typed} counterpart.

\rsthB{Typed Arguments}\label{introduction-typed-arguments}
For typed arguments, the semantic checker runs on the argument and does transformations on it, before it is passed to the macro. Here identifier nodes are resolved as symbols, implicit type conversions are visible in the tree as calls, templates are expanded and probably most importantly, nodes have type information. Typed arguments can have the type \texttt{typed} in the arguments list. But all other types, such as \texttt{int}, \texttt{float} or \texttt{MyObjectType} are typed arguments as well, and they are passed to the macro as a syntax tree.

\rsthB{Static Arguments}\label{introduction-static-arguments}
Static arguments are a way to pass values as values and not as syntax tree nodes to a macro. For example for \texttt{macro foo(arg: static\symbol{91}int\symbol{93})} in the expression \texttt{foo(x)}, \texttt{x} needs to be an integer constant, but in the macro body \texttt{arg} is just like a normal parameter of type \texttt{int}.

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{macros}

\spanKeyword{macro} \spanIdentifier{myMacro}\spanPunctuation{(}\spanIdentifier{arg}\spanPunctuation{:} \spanKeyword{static}\spanPunctuation{\symbol{91}}\spanIdentifier{int}\spanPunctuation{\symbol{93}}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanIdentifier{echo} \spanIdentifier{arg} \spanComment{\# just an int (7), not \symbol{96}\symbol{96}NimNode\symbol{96}\symbol{96}}

\spanIdentifier{myMacro}\spanPunctuation{(}\spanDecNumber{1} \spanOperator{+} \spanDecNumber{2} \spanOperator{*} \spanDecNumber{3}\spanPunctuation{)}
\end{rstpre}
\rsthB{Code Blocks as Arguments}\label{introduction-code-blocks-as-arguments}
It is possible to pass the last argument of a call expression in a separate code block with indentation. For example the following code example is a valid (but not a recommended) way to call \texttt{echo}:

\begin{rstpre}
\spanIdentifier{echo} \spanStringLit{"Hello "}\spanPunctuation{:}
  \spanKeyword{let} \spanIdentifier{a} \spanOperator{=} \spanStringLit{"Wor"}
  \spanKeyword{let} \spanIdentifier{b} \spanOperator{=} \spanStringLit{"ld!"}
  \spanIdentifier{a} \spanOperator{\&} \spanIdentifier{b}
\end{rstpre}
For macros this way of calling is very useful; syntax trees of arbitrary complexity can be passed to macros with this notation.

\rsthB{The Syntax Tree}\label{introduction-the-syntax-tree}
In order to build a Nim syntax tree one needs to know how Nim source code is represented as a syntax tree, and how such a tree needs to look like so that the Nim compiler will understand it. The nodes of the Nim syntax tree are documented in the \href{macros.html}{macros} module. But a more interactive way to explore the Nim syntax tree is with \texttt{macros.treeRepr}, it converts a syntax tree into a multi line string for printing on the console. It can be used to explore how the argument expressions are represented in tree form and for debug printing of generated syntax tree. \texttt{dumpTree} is a predefined macro that just prints its argument in tree representation, but does nothing else. Here is an example of such a tree representation:

\begin{rstpre}
\spanIdentifier{dumpTree}\spanPunctuation{:}
  \spanKeyword{var} \spanIdentifier{mt}\spanPunctuation{:} \spanIdentifier{MyType} \spanOperator{=} \spanIdentifier{MyType}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:}\spanFloatNumber{123.456}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:}\spanStringLit{"abcdef"}\spanPunctuation{)}

\spanComment{\# output:}
\spanComment{\#   StmtList}
\spanComment{\#     VarSection}
\spanComment{\#       IdentDefs}
\spanComment{\#         Ident "mt"}
\spanComment{\#         Ident "MyType"}
\spanComment{\#         ObjConstr}
\spanComment{\#           Ident "MyType"}
\spanComment{\#           ExprColonExpr}
\spanComment{\#             Ident "a"}
\spanComment{\#             FloatLit 123.456}
\spanComment{\#           ExprColonExpr}
\spanComment{\#             Ident "b"}
\spanComment{\#             StrLit "abcdef"}
\end{rstpre}
\rsthB{Custom Semantic Checking}\label{introduction-custom-semantic-checking}
The first thing that a macro should do with its arguments is to check if the argument is in the correct form. Not every type of wrong input needs to be caught here, but anything that could cause a crash during macro evaluation should be caught and create a nice error message. \texttt{macros.expectKind} and \texttt{macros.expectLen} are a good start. If the checks need to be more complex, arbitrary error messages can be created with the \texttt{macros.error} proc.

\begin{rstpre}
\spanKeyword{macro} \spanIdentifier{myAssert}\spanPunctuation{(}\spanIdentifier{arg}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanIdentifier{arg}\spanOperator{.}\spanIdentifier{expectKind} \spanIdentifier{nnkInfix}
\end{rstpre}
\rsthB{Generating Code}\label{introduction-generating-code}
There are two ways to generate the code. Either by creating the syntax tree with expressions that contain a lot of calls to \texttt{newTree} and \texttt{newLit}, or with \texttt{quote do:} expressions. The first option offers the best low level control for the syntax tree generation, but the second option is much less verbose. If you choose to create the syntax tree with calls to \texttt{newTree} and \texttt{newLit} the macro \texttt{macros.dumpAstGen} can help you with the verbosity. \texttt{quote do:} allows you to write the code that you want to generate literally, backticks are used to insert code from \texttt{NimNode} symbols into the generated expression. This means that you can't use backticks within \texttt{quote do:} for anything else than injecting symbols.  Make sure to inject only symbols of type \texttt{NimNode} into the generated syntax tree. You can use \texttt{newLit} to convert arbitrary values into expressions trees of type \texttt{NimNode} so that it is safe to inject them into the tree.

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{macros}

\spanKeyword{type}
  \spanIdentifier{MyType} \spanOperator{=} \spanKeyword{object}
    \spanIdentifier{a}\spanPunctuation{:} \spanIdentifier{float}
    \spanIdentifier{b}\spanPunctuation{:} \spanIdentifier{string}

\spanKeyword{macro} \spanIdentifier{myMacro}\spanPunctuation{(}\spanIdentifier{arg}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanKeyword{var} \spanIdentifier{mt}\spanPunctuation{:} \spanIdentifier{MyType} \spanOperator{=} \spanIdentifier{MyType}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:}\spanFloatNumber{123.456}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:}\spanStringLit{"abcdef"}\spanPunctuation{)}
  
  \spanComment{\# ...}
  
  \spanKeyword{let} \spanIdentifier{mtLit} \spanOperator{=} \spanIdentifier{newLit}\spanPunctuation{(}\spanIdentifier{mt}\spanPunctuation{)}
  
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{quote} \spanKeyword{do}\spanPunctuation{:}
    \spanIdentifier{echo} \spanPunctuation{\symbol{96}}\spanIdentifier{arg}\spanPunctuation{\symbol{96}}
    \spanIdentifier{echo} \spanPunctuation{\symbol{96}}\spanIdentifier{mtLit}\spanPunctuation{\symbol{96}}

\spanIdentifier{myMacro}\spanPunctuation{(}\spanStringLit{"Hallo"}\spanPunctuation{)}
\end{rstpre}
The call to \texttt{myMacro} will generate the following code:

\begin{rstpre}
\spanIdentifier{echo} \spanStringLit{"Hallo"}
\spanIdentifier{echo} \spanIdentifier{MyType}\spanPunctuation{(}\spanIdentifier{a}\spanPunctuation{:} \spanFloatNumber{123.456'f64}\spanPunctuation{,} \spanIdentifier{b}\spanPunctuation{:} \spanStringLit{"abcdef"}\spanPunctuation{)}
\end{rstpre}
\rsthB{Building Your First Macro}\label{introduction-building-your-first-macro}
To give a starting point to writing macros we will show now how to implement the \texttt{myDebug} macro mentioned earlier. The first thing to do is to build a simple example of the macro usage, and then just print the argument. This way it is possible to get an idea of a correct argument should be look like.

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{macros}

\spanKeyword{macro} \spanIdentifier{myAssert}\spanPunctuation{(}\spanIdentifier{arg}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanIdentifier{echo} \spanIdentifier{arg}\spanOperator{.}\spanIdentifier{treeRepr}

\spanKeyword{let} \spanIdentifier{a} \spanOperator{=} \spanDecNumber{1}
\spanKeyword{let} \spanIdentifier{b} \spanOperator{=} \spanDecNumber{2}

\spanIdentifier{myAssert}\spanPunctuation{(}\spanIdentifier{a} \spanOperator{!=} \spanIdentifier{b}\spanPunctuation{)}
\end{rstpre}
\begin{rstpre}
\spanIdentifier{Infix}
  \spanIdentifier{Ident} \spanStringLit{"!="}
  \spanIdentifier{Ident} \spanStringLit{"a"}
  \spanIdentifier{Ident} \spanStringLit{"b"}
\end{rstpre}
From the output it is possible to see that the argument is an infix operator (node kind is "Infix"), as well as that the two operands are at index 1 and 2. With this information the actual macro can be written.

\begin{rstpre}
\spanKeyword{import} \spanIdentifier{macros}

\spanKeyword{macro} \spanIdentifier{myAssert}\spanPunctuation{(}\spanIdentifier{arg}\spanPunctuation{:} \spanIdentifier{untyped}\spanPunctuation{)}\spanPunctuation{:} \spanIdentifier{untyped} \spanOperator{=}
  \spanComment{\# all node kind identifiers are prefixed with "nnk"}
  \spanIdentifier{arg}\spanOperator{.}\spanIdentifier{expectKind} \spanIdentifier{nnkInfix}
  \spanIdentifier{arg}\spanOperator{.}\spanIdentifier{expectLen} \spanDecNumber{3}
  \spanComment{\# operator as string literal}
  \spanKeyword{let} \spanIdentifier{op}  \spanOperator{=} \spanIdentifier{newLit}\spanPunctuation{(}\spanStringLit{" "} \spanOperator{\&} \spanIdentifier{arg}\spanPunctuation{\symbol{91}}\spanDecNumber{0}\spanPunctuation{\symbol{93}}\spanOperator{.}\spanIdentifier{repr} \spanOperator{\&} \spanStringLit{" "}\spanPunctuation{)}
  \spanKeyword{let} \spanIdentifier{lhs} \spanOperator{=} \spanIdentifier{arg}\spanPunctuation{\symbol{91}}\spanDecNumber{1}\spanPunctuation{\symbol{93}}
  \spanKeyword{let} \spanIdentifier{rhs} \spanOperator{=} \spanIdentifier{arg}\spanPunctuation{\symbol{91}}\spanDecNumber{2}\spanPunctuation{\symbol{93}}
  
  \spanIdentifier{result} \spanOperator{=} \spanIdentifier{quote} \spanKeyword{do}\spanPunctuation{:}
    \spanKeyword{if} \spanKeyword{not} \spanPunctuation{\symbol{96}}\spanIdentifier{arg}\spanPunctuation{\symbol{96}}\spanPunctuation{:}
      \spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{AssertionDefect}\spanPunctuation{,}\spanOperator{\$}\spanPunctuation{\symbol{96}}\spanIdentifier{lhs}\spanPunctuation{\symbol{96}} \spanOperator{\&} \spanPunctuation{\symbol{96}}\spanIdentifier{op}\spanPunctuation{\symbol{96}} \spanOperator{\&} \spanOperator{\$}\spanPunctuation{\symbol{96}}\spanIdentifier{rhs}\spanPunctuation{\symbol{96}}\spanPunctuation{)}

\spanKeyword{let} \spanIdentifier{a} \spanOperator{=} \spanDecNumber{1}
\spanKeyword{let} \spanIdentifier{b} \spanOperator{=} \spanDecNumber{2}

\spanIdentifier{myAssert}\spanPunctuation{(}\spanIdentifier{a} \spanOperator{!=} \spanIdentifier{b}\spanPunctuation{)}
\spanIdentifier{myAssert}\spanPunctuation{(}\spanIdentifier{a} \spanOperator{==} \spanIdentifier{b}\spanPunctuation{)}
\end{rstpre}
This is the code that will be generated. To debug what the macro actually generated, the statement \texttt{echo result.repr} can be used, in the last line of the macro. It is also the statement that has been used to get this output.

\begin{rstpre}
\spanKeyword{if} \spanKeyword{not} \spanPunctuation{(}\spanIdentifier{a} \spanOperator{!=} \spanIdentifier{b}\spanPunctuation{)}\spanPunctuation{:}
  \spanKeyword{raise} \spanIdentifier{newException}\spanPunctuation{(}\spanIdentifier{AssertionDefect}\spanPunctuation{,} \spanOperator{\$}\spanIdentifier{a} \spanOperator{\&} \spanStringLit{" != "} \spanOperator{\&} \spanOperator{\$}\spanIdentifier{b}\spanPunctuation{)}
\end{rstpre}
\rsthB{With Power Comes Responsibility}\label{introduction-with-power-comes-responsibility}
Macros are very powerful. A good advice is to use them as little as possible, but as much as necessary. Macros can change the semantics of expressions, making the code incomprehensible for anybody who does not know exactly what the macro does with it. So whenever a macro is not necessary and the same logic can be implemented using templates or generics, it is probably better not to use a macro. And when a macro is used for something, the macro should better have a well written documentation. For all the people who claim to write only perfectly self-explanatory code: when it comes to macros, the implementation is not enough for documentation.

\rsthB{Limitations}\label{introduction-limitations}
Since macros are evaluated in the compiler in the NimVM, macros share all the limitations of the NimVM. They have to be implemented in pure Nim code. Macros can start external processes on the shell, but they cannot call C functions except from those that are built in the compiler.

\rsthA{More Examples}\label{more-examples}
This tutorial can only cover the basics of the macro system. There are macros out there that could be an inspiration for you of what is possible with it.

\rsthB{Strformat}\label{more-examples-strformat}
In the Nim standard library, the \texttt{strformat} library provides a macro that parses a string literal at compile time. Parsing a string in a macro like here is generally not recommended. The parsed AST cannot have type information, and parsing implemented on the VM is generally not very fast. Working on AST nodes is almost always the recommended way. But still \texttt{strformat} is a good example for a practical use case for a macro that is slightly more complex than the \texttt{assert} macro.

\href{https://github.com/nim-lang/Nim/blob/5845716df8c96157a047c2bd6bcdd795a7a2b9b1/lib/pure/strformat.nim\#L280}{Strformat}

\rsthB{Ast Pattern Matching}\label{more-examples-ast-pattern-matching}
Ast Pattern Matching is a macro library to aid in writing complex macros. This can be seen as a good example of how to repurpose the Nim syntax tree with new semantics.

\href{https://github.com/krux02/ast-pattern-matching}{Ast Pattern Matching}

\rsthB{OpenGL Sandbox}\label{more-examples-opengl-sandbox}
This project has a working Nim to GLSL compiler written entirely in macros. It scans recursively though all used function symbols to compile them so that cross library functions can be executed on the GPU.

\href{https://github.com/krux02/opengl-sandbox}{OpenGL Sandbox} 




\end{document}
